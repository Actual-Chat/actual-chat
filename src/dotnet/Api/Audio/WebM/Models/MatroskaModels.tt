<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".cs" encoding="utf-8" #>
<#@ Assembly Name="System.Core.dll" #>
<#@ Assembly Name="System.Xml.dll" #>
<#@ Assembly Name="System.Xml.Linq.dll" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Xml.Linq" #>
<#
    var XmlFile = "../ebml.xml";
    var MatroskaXmlFile = "../ebml_matroska.xml";
    XNamespace ns = "urn:ietf:rfc:8794";
#>
using System;
using System.Collections.Generic;
using System.CodeDom.Compiler;
using System.Runtime.CompilerServices;
using ActualChat.Spans;

// ReSharper disable UnusedAutoPropertyAccessor.Global
// ReSharper disable InconsistentNaming
// ReSharper disable ClassNeverInstantiated.Global
// ReSharper disable IdentifierTypo


//--------------------------------------------------------------------------------------------------------
// <auto-generated>
//     This C# code class was auto-generated at <#= DateTime.Now #>.
//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
//
//     Based on "https://github.com/ietf-wg-cellar/matroska-specification/blob/master/ebml_matroska.xml".
// </auto-generated>
//--------------------------------------------------------------------------------------------------------
namespace ActualChat.Audio.WebM.Models
{
<#
    var isList = new List<string>
    {
        "Seek",
        "Cluster",
        "TrackEntry",
        "SimpleBlock",
        "Block",
        "BlockAdditional",
        "BlockGroup",
        "BlockVirtual",
        "EncryptedBlock",
        "Tag",
        "SimpleTag",
        "Target",
        "ContentCompression",
        "ContentEncoding",
        "CuetrackPosition",
        "CuePoint",
        "CueReference",
        "SignatureSlot",
        "SignatureElementList",
        "SignedElement",
    };

    var isRoot = new List<string>
    {
        "EBML",
        "Segment",
        "Cluster",
    };

    var isBlock = new List<string>
    {
        "Block",
        "BlockAdditional",
        "BlockVirtual",
        "EncryptedBlock",
        "SimpleBlock",
    };

    var elementsEbml = XElement.Load(Path.Combine(Path.GetDirectoryName(Host.TemplateFile), XmlFile)).Elements()
        .Select(e => new Element
        {
            Name = e.Attribute("name").Value.Replace("CRC-32", "CRC32"),
            UseNameInsteadOfBinary = UseNameInsteadOfBinary(e.Attribute("name").Value),
            IsList = isList.Contains(e.Attribute("name").Value),
            IsRoot = isRoot.Contains(e.Attribute("name").Value),
            IsBlock = isBlock.Contains(e.Attribute("name").Value),
            Path = e.Attribute("path").Value,
            Level = e.Attribute("path").Value.Count(c => c == '\\'),
            Id = e.Attribute("id").Value,
            ElementType = e.Attribute("type").Value,
            DefaultValue = e.Attribute("default")?.Value,
            Required = (e.Attribute("minOccurs") != null ? int.Parse(e.Attribute("minOccurs").Value) : 0) > 0,
            Documentation = e.Element(ns + "documentation") != null ? e.Element(ns + "documentation").Value : "",
        });

    var elementsMatroska = XElement.Load(Path.Combine(Path.GetDirectoryName(Host.TemplateFile), MatroskaXmlFile))
        .Elements()
        .Select(e => new Element
        {
            Name = e.Attribute("name").Value,
            UseNameInsteadOfBinary = UseNameInsteadOfBinary(e.Attribute("name").Value),
            IsList = isList.Contains(e.Attribute("name").Value),
            IsRoot = isRoot.Contains(e.Attribute("name").Value),
            IsBlock = isBlock.Contains(e.Attribute("name").Value),
            Path = e.Attribute("path").Value,
            Level = e.Attribute("path").Value.Count(c => c == '\\'),
            Id = e.Attribute("id").Value,
            ElementType = e.Attribute("type").Value,
            DefaultValue = e.Attribute("default")?.Value,
            Required = (e.Attribute("minOccurs") != null ? int.Parse(e.Attribute("minOccurs").Value) : 0) > 0,
            Documentation = e.Element(ns + "documentation") != null ? e.Element(ns + "documentation").Value : "",
        });

    var elements = elementsEbml.Union(elementsMatroska).Concat(new[]
    {
        new Element
        {
            Name = "Unknown",
            UseNameInsteadOfBinary = false,
            IsList = false,
            IsRoot = false,
            IsBlock = false,
            Path = "",
            Level = 0,
            Id = "0x7FFF",
            ElementType = "None",
            DefaultValue = null,
            Required = false,
            Documentation = "Unknown element",
        },
    }).ToList();

    var deprecated = new List<string> { "TrackTimestampScale" };

    var ebml = elements.FirstOrDefault(e => e.Name == "EBML");
    Loop(elements, ebml, "", deprecated);

    var segment = elements.FirstOrDefault(e => e.Name == "Segment");
    Loop(elements, segment, "", deprecated);

    var skip = new List<string> { "Block", "SimpleBlock", "SimpleTag", "TrackTimestampScale" };

    foreach (
        var master in
            elements.Where(e => (e.ElementType == "master" || e.ElementType == "None") && !skip.Contains(e.Name))
                .OrderBy(e => e.Path))
    {
        var className = master.Name;
        if (className == "Tag")
        {
            className = "TagItem";
        }
        if (className == "ContentEncoding")
        {
            className = "ContentEncodingItem";
        }
#>
    [GeneratedCode("MatroskaModels.tt", "1.0.0.0")]
    [MatroskaElementDescriptor(MatroskaSpecification.<#= master.Name #>)]
    public sealed class <#= className #> : <#= master.IsRoot ? "RootEntry" : "BaseModel" #>
    {
        public override EbmlElementDescriptor Descriptor => MatroskaSpecification.<#= master.Name #>Descriptor;

<#
        var subs = master.SubElements.Where(sub => !sub.IsRoot).ToList();
        foreach (var sub in subs)
        {
            var field = sub.Name;
            if (sub.Name == "Tag")
            {
                field = "TagItem";
            }
            if (sub.Name == "ContentEncoding")
            {
                field = "ContentEncodingItem";
            }

            string a;
            if (sub.IsList && field != "SignedElement")
            {
                a =
                    string.Format(
                        new string(' ', 8) + "[MatroskaElementDescriptor(MatroskaSpecification.{0}, typeof({1}))]",
                        sub.Name,
                        field);
            }
            else
            {
                a = string.Format(new string(' ', 8) + "[MatroskaElementDescriptor(MatroskaSpecification.{0})]",
                    sub.Name);
            }
            WriteLine(a);
            WriteLine(new string(' ', 8) + GetProperty(sub, field));
            if (sub != subs.Last())
            {
                WriteLine("");
            }
        }
#>

        public override ulong GetSize() {
            var size = 0UL;
<#
        // TODO: HardCode unknown size for Segment and Cluster. According to the spec Clusters should be child element of the segment, but it's not convenient for streaming.
        if (master.Name == "Segment")
        {
#>
            size = 0xFF_FFFF_FFFF_FFFF;

<#
        }
        if (master.Name == "Cluster")
        {
#>
            if (!IsCompleted)
                return 0xFF_FFFF_FFFF_FFFF;

<#
        }

        if (master.Name != "Segment")
            foreach (var sub in subs)
            {
                var field = sub.Name;
                if (sub.Name == "Tag")
                {
                    field = "TagItem";
                }
                if (sub.Name == "ContentEncoding")
                {
                    field = "ContentEncodingItem";
                }

                var stringEncoding = "";
                if (sub.ElementType == "string")
                {
                    stringEncoding = ", true";
                }
                else if (sub.ElementType == "utf-8")
                {
                    stringEncoding = ", false";
                }

                var name = Pluralize(sub, field);


                if (sub.ElementType != "master" && !(sub.ElementType == "binary" && sub.UseNameInsteadOfBinary))
                {
                    var defaultOffset = "";
                    if (master.Name != "EBML" && sub.Name != "TimestampScale" && sub.Name != "Channels" &&
                        sub.DefaultValue != null && sub.ElementType != "string" && !sub.DefaultValue.Contains("p"))
                    {
                        defaultOffset = "    ";
#>
            if (<#= name #> != <#= sub.DefaultValue #>)
<#
                    }
#>
            <#= defaultOffset #>size += EbmlHelper.GetElementSize(MatroskaSpecification.<#= sub.Name #>, <#=
                        sub.Name == "TrackType" ? "(ulong?)" : "" #><#= name #><#= stringEncoding #>);
<#
                }
                else
                {
#>
            size += EbmlHelper.GetElementSize(MatroskaSpecification.<#= sub.Name #>, <#= name #>);
<#
                }
            }
#>
            return size;
        }
    }

<#
    }
#>

    public static class ModelExt
    {

        public static bool Write(this BaseModel? model, ref SpanWriter writer)
        {
            if (model == null)
                return true;

            switch (model.Descriptor.Identifier.EncodedValue) {
<#
    var masters = elements.Where(e => e.ElementType == "master" || e.IsBlock).OrderBy(e => e.Path).ToList();

    foreach (var master in masters)
    {
        var hasSubs = master.SubElements.Any(sub => !sub.IsRoot);
        if (!hasSubs && !master.IsBlock)
            continue;

        var className = master.Name;
        if (className == "Tag")
        {
            className = "TagItem";
        }
        if (className == "ContentEncoding")
        {
            className = "ContentEncodingItem";
        }
#>
            case MatroskaSpecification.<#= master.Name #>:
                return ((<#= className #>)model).Write(ref writer);
<#
    }
#>
            default:
                throw new EbmlDataFormatException($"Unexpected EBML element '{model.Descriptor.Identifier}'.");
            }
        }

<#
    foreach (var master in elements.Where(e => e.ElementType == "master" && !skip.Contains(e.Name)).OrderBy(e => e.Path)
        )
    {
        var className = master.Name;
        if (className == "Tag")
        {
            className = "TagItem";
        }
        if (className == "ContentEncoding")
        {
            className = "ContentEncodingItem";
        }
#>

        public static bool Write(this <#= className #>? model, ref SpanWriter writer)
        {
            if (model == null)
                return true;

            if (!EbmlHelper.WriteEbmlMasterElement(MatroskaSpecification.<#= master.Name #>, model.GetSize(), ref writer))
                return false;
<#
        var subs = master.SubElements.Where(sub => !sub.IsRoot && !sub.IsBlock).ToList();
        if (subs.Count > 0)
        {
            foreach (var sub in subs)
            {
                var field = sub.Name;
                if (sub.Name == "Tag")
                {
                    field = "TagItem";
                }
                if (sub.Name == "ContentEncoding")
                {
                    field = "ContentEncodingItem";
                }

                var stringEncoding = "";
                if (sub.ElementType == "string")
                {
                    stringEncoding = ", true";
                }
                else if (sub.ElementType == "utf-8")
                {
                    stringEncoding = ", false";
                }

                var name = Pluralize(sub, field);
                if (sub.ElementType != "master" && !(sub.ElementType == "binary" && sub.UseNameInsteadOfBinary))
                {
                    var defaultOffset = "";
                    if (master.Name != "EBML" && sub.Name != "TimestampScale" && sub.Name != "Channels" &&
                        sub.DefaultValue != null && sub.ElementType != "string" && !sub.DefaultValue.Contains("p"))
                    {
                        defaultOffset = "    ";
#>
            if (model.<#= name #> != <#= sub.DefaultValue #>)
<#
                    }
#>
            <#= defaultOffset #>EbmlHelper.WriteEbmlElement(MatroskaSpecification.<#= sub.Name #>, <#=
                            sub.Name == "TrackType" ? "(ulong?)" : "" #>model.<#= name #><#= stringEncoding #>, ref writer);
<#
                }
                else
                {
#>
            model.<#= name #><#= sub.Required ? "" : "?" #>.Write(ref writer);
<#
                }
            }
        }
#>
            return true;
        }
<#
    }
#>


        public static BaseModel CreateInstance(this EbmlElementDescriptor descriptor)
        {
            if (descriptor.Type != EbmlElementType.MasterElement)
                throw new InvalidOperationException("Can't create instances of non-master element.");

            switch (descriptor.Identifier.EncodedValue) {
<#
    foreach (
        var master in elements.Where(e => e.ElementType == "master" && !skip.Contains(e.Name)).OrderBy(e => e.Path))
    {
        var className = master.Name;
        if (className == "Tag") {
            className = "TagItem";
        }
        if (className == "ContentEncoding") {
            className = "ContentEncodingItem";
        }
#>
            case MatroskaSpecification.<#= master.Name #>:
                return new <#= className #>();
<#
    }
#>
            default:
                throw new InvalidOperationException("Unknown master element: " + descriptor.Identifier + ".");
            }
        }

        public static void FillScalar(this BaseModel model, EbmlElementDescriptor containerDescriptor, EbmlElementDescriptor descriptor, int size, ref SpanReader reader)
        {
            switch (containerDescriptor.Identifier.EncodedValue) {
<#
    foreach (var master in masters)
    {
        var hasSubs = master.SubElements.Any(sub => !sub.IsRoot && sub.ElementType != "master" && !sub.IsList);
        if (!hasSubs)
            continue;

        var className = master.Name;
        if (className == "Tag") {
            className = "TagItem";
        }
        if (className == "ContentEncoding") {
            className = "ContentEncodingItem";
        }
#>
            case MatroskaSpecification.<#= master.Name #>:
                ((<#= className #>)model).FillScalar(descriptor, size, ref reader);
                break;
<#
    }
#>
            }
        }

        public static void FillComplex(this BaseModel model, EbmlElementDescriptor containerDescriptor, EbmlElementDescriptor descriptor, BaseModel propertyModel)
        {
            switch (containerDescriptor.Identifier.EncodedValue) {
<#
    foreach (var master in masters)
    {
        var hasComplex = master.SubElements.Any(sub => !sub.IsRoot && sub.ElementType == "master" && !sub.IsList);
        if (!hasComplex || master.IsBlock)
            continue;

        var className = master.Name;
        if (className == "Tag") {
            className = "TagItem";
        }
        if (className == "ContentEncoding") {
            className = "ContentEncodingItem";
        }
#>
            case MatroskaSpecification.<#= master.Name #>:
                ((<#= className #>)model).FillComplex(descriptor, propertyModel);
                break;
<#
    }
#>
            }
        }

        public static void FillListEntry(this BaseModel model, EbmlElementDescriptor containerDescriptor, EbmlElementDescriptor descriptor, object listEntry)
        {
            switch (containerDescriptor.Identifier.EncodedValue) {
<#
    foreach (var master in masters)
    {
        var hasList = master.SubElements.Any(sub => !sub.IsRoot && sub.IsList);
        if (!hasList)
            continue;

        var className = master.Name;
        if (className == "Tag") {
            className = "TagItem";
        }
        if (className == "ContentEncoding") {
            className = "ContentEncodingItem";
        }
#>
            case MatroskaSpecification.<#= master.Name #>:
                ((<#= className #>)model).FillListEntry(descriptor, listEntry);
                break;
<#
    }
#>
            }
        }

<#
    foreach (var master in masters)
    {
        var className = master.Name;
        if (className == "Tag") {
            className = "TagItem";
        }
        if (className == "ContentEncoding") {
            className = "ContentEncodingItem";
        }
        var subs =
            master.SubElements.Where(sub => !sub.IsRoot && sub.ElementType != "master" && !sub.IsList).ToList();
        if (subs.Count > 0) {
#>
        private static void FillScalar(this <#= className #> model, EbmlElementDescriptor descriptor, int size, ref SpanReader reader)
        {
            if (descriptor.Type == EbmlElementType.MasterElement)
                throw new InvalidOperationException("Can't read master elements directly from the reader.");

            switch (descriptor.Identifier.EncodedValue) {
<#
            foreach (var sub in subs)
            {
                var field = sub.Name;
                if (sub.Name == "Tag") {
                    field = "TagItem";
                }
                if (sub.Name == "ContentEncoding") {
                    field = "ContentEncodingItem";
                }
                var propertyName = Pluralize(sub, field);
                var methodSuffix = sub.ElementType switch {
                    "utf-8" => "Utf8String(size)!",
                    "string" => "AsciiString(size)!",
                    "binary" => "Bytes(size)!",
                    "date" => "DateTime()!.Value",
                    "float" => "Float(size)!.Value",
                    "uinteger" => "ULong(size)!.Value",
                    "integer" => "Long(size)!.Value",
                    _ => "???",
                    };
                var methodPrefix = sub.Name == "TrackType"
                    ? "(TrackType?)"
                    : "";
#>
            case MatroskaSpecification.<#= sub.Name #>:
                model.<#= propertyName #> = <#= methodPrefix #>reader.Read<#= methodSuffix #>;
                break;
<#
            }
#>
            default:
                throw new EbmlDataFormatException($"Unexpected EBML element '{descriptor.Identifier}'.");
            }
        }

<#
        }
        var complexSubs =
            master.SubElements.Where(sub => !sub.IsRoot && sub.ElementType == "master" && !sub.IsList)
                .ToList();
        if (complexSubs.Count > 0 && !master.IsBlock)
        {
#>
        private static void FillComplex(this <#= className #> model, EbmlElementDescriptor descriptor, BaseModel propertyModel)
        {
            if (descriptor.Type != EbmlElementType.MasterElement)
                throw new InvalidOperationException("EbmlElementDescriptor should have 'master' type.");

            switch (descriptor.Identifier.EncodedValue) {
<#
            foreach (var sub in complexSubs)
            {
                var field = sub.Name;
                if (sub.Name == "Tag") {
                    field = "TagItem";
                }
                if (sub.Name == "ContentEncoding") {
                    field = "ContentEncodingItem";
                }
                var propertyName = Pluralize(sub, field);
                var optionalSuffix = sub.Required ? "" : "?";
                var cast = $"({field}{optionalSuffix})";
#>
            case MatroskaSpecification.<#= sub.Name #>:
                model.<#= propertyName #> = <#= cast #>propertyModel;
                break;
<#
            }
#>
            default:
                throw new EbmlDataFormatException($"Unexpected EBML element: '{descriptor.Identifier}'.");
            }
        }

<#
        }

        var listSubs =
            master.SubElements.Where(sub => !sub.IsRoot && sub.IsList)
                .ToList();
        if (listSubs.Count > 0) {
#>
        private static void FillListEntry(this <#= className #> model, EbmlElementDescriptor descriptor, object listItem)
        {
            if (descriptor.Type != EbmlElementType.MasterElement && descriptor.Type != EbmlElementType.Binary)
                throw new InvalidOperationException("EbmlElementDescriptor should have 'master' or 'binary' type.");

            switch (descriptor.Identifier.EncodedValue) {
<#
            foreach (var sub in listSubs) {
                var field = sub.Name;
                if (sub.Name == "Tag") {
                    field = "TagItem";
                }
                if (sub.Name == "ContentEncoding") {
                    field = "ContentEncodingItem";
                }
                var propertyName = Pluralize(sub, field);
                var propertyType = GetPropertyType(sub, field);
                var cast = $"({propertyType})";
#>
            case MatroskaSpecification.<#= sub.Name #>: {
                var list = model.<#= propertyName #> as IList<<#= field #>> ?? new List<<#= field #>>(4);
                list.Add((<#= field #>)listItem);
                model.<#= propertyName #> = <#= cast #>list;
                break;
            }
<#
            }
#>
            default:
                throw new EbmlDataFormatException($"Unexpected EBML element: '{descriptor.Identifier}'.");
            }
        }

<#
        }
    }
#>
    }
}

<#+
    public bool UseNameInsteadOfBinary(string elementName)
    {
        return elementName.Contains("Block") && elementName != "BlockAddIDExtraData";
    }

    public void Loop(List<Element> all, Element current, string parentPath, List<string> skip)
    {
        current.SubElements = all
            .Where(e => e.Path.StartsWith(parentPath + "\\" + current.Name) && e.Level == current.Level + 1)
            .Where(s => !skip.Contains(s.Name))
            .ToList();
        foreach (var sub in current.SubElements) {
            Loop(all, sub, current.Path, skip);
        }
    }

    public string GetProperty(Element property, string field)
    {
        var propertyType = GetPropertyType(property, field);
        var name = Pluralize(property, field);

        var fixRequired = "";
        if (property.Required && !propertyType.Contains("long") && !propertyType.Contains("float") &&
            !propertyType.Contains("TrackType")) {
            fixRequired = " = null!;";
        }

        var defaultAssignment = "";
        if (property.DefaultValue != null && propertyType != "string" && !property.DefaultValue.Contains("p")) {
            defaultAssignment = " = " + property.DefaultValue + ";";
        }

        return "public " + propertyType + " " + name + " { get; set; }" + fixRequired + defaultAssignment;
    }

    public string GetPropertyType(Element property, string field)
    {
        string propertyType;
        switch (property.ElementType) {
        case "utf-8":
            propertyType = "string";
            break;

        case "string":
            propertyType = "string";
            break;

        case "binary":
            propertyType = property.UseNameInsteadOfBinary ? field : "byte[]";
            break;

        case "date":
            propertyType = "DateTime";
            break;

        case "float":
            propertyType = "float";
            break;

        case "uinteger":
            propertyType = property.Name == "TrackType" ? "TrackType" : "ulong";
            break;

        case "integer":
            propertyType = "long";
            break;

        case "master":
            propertyType = field;
            break;

        default:
            propertyType = "???";
            break;
        }

        if (property.IsList) {
            return $"IReadOnlyList<{propertyType}>" + (!property.Required ? "?" : "");
        }
        return propertyType + (!property.Required || propertyType == "TrackType" ? "?" : "");
    }

    public string Pluralize(Element property, string field)
    {
        var name = field;
        if (property.IsList) {
            if (property.Name.EndsWith("y")) {
                name = property.Name.Replace("y", "ies");
            }
            else {
                name = name + "s";
            }
        }
        return name;
    }


    public class Element
    {
        public string Name;
        public bool UseNameInsteadOfBinary;
        public bool IsList;
        public bool IsRoot;
        public bool IsBlock;
        public string Path;
        public string Id;
        public string ElementType;
        public string? DefaultValue;
        public bool Required;
        public string Documentation;
        public int Level;

        public List<Element> SubElements = new();
    }
#>
