<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".cs" encoding="utf-8" #>
<#@ Assembly Name="System.Core.dll" #>
<#@ Assembly Name="System.Xml.dll" #>
<#@ Assembly Name="System.Xml.Linq.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Linq" #>
<#
    string XmlFile = "ebml.xml";
    string MatroskaXmlFile = "ebml_matroska.xml";
    XNamespace ns = "urn:ietf:rfc:8794";
#>
using System.Collections.Generic;
using System.CodeDom.Compiler;
using System.Linq;
using System.Reflection;
using ActualChat.Audio.WebM;

// ReSharper disable CommentTypo
// ReSharper disable InconsistentNaming
// ReSharper disable ClassNeverInstantiated.Global
// ReSharper disable IdentifierTypo


//--------------------------------------------------------------------------------------------------------
// <auto-generated>
//     This C# code class was auto-generated at <#= DateTime.Now #>.
//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
//
//     Based on "https://github.com/ietf-wg-cellar/matroska-specification/blob/master/ebml_matroska.xml".
// </auto-generated>
//--------------------------------------------------------------------------------------------------------
namespace ActualChat.Audio.WebM
{
    /// <summary>
    /// Contains the EBML elements specified by the Matroska project (https://matroska.org/technical/specs/index.html)
    /// </summary>
    [GeneratedCode("MatroskaSpecification.tt", "1.0.0.0")]
    internal static class MatroskaSpecification
    {
<#
    var isList = new List<string>
    {
        "Cluster",
        "TrackEntry",
        "SimpleBlock",
        "Block",
        "BlockAdditional",
        "BlockGroup",
        "BlockVirtual",
        "EncryptedBlock",
        "Tag",
        "SimpleTag",
        "Target",
        "ContentCompression",
        "ContentEncoding",
        "CuetrackPosition",
        "CuePoint",
        "CueReference",
        "SignatureSlot",
        "SignatureElementList",
        "SignedElement"
    };

    var elementsEbml = XElement.Load(Path.Combine(Path.GetDirectoryName(this.Host.TemplateFile), XmlFile)).Elements()
        .Select(e => new
        {
            Name = e.Attribute("name").Value.Replace("CRC-32", "CRC32"),
            Path = e.Attribute("path").Value,
            Id = e.Attribute("id").Value,
            IsList = isList.Contains(e.Attribute("name").Value),
            ElementType = e.Attribute("type").Value,
            DefaultValue = e.Attribute("default")?.Value,
            Required = (e.Attribute("minOccurs") != null ? int.Parse(e.Attribute("minOccurs").Value) : 0) > 0,
            Documentation = e.Element(ns + "documentation") != null ? e.Element(ns + "documentation").Value : ""
        });

    var elementsMatroska = XElement.Load(Path.Combine(Path.GetDirectoryName(this.Host.TemplateFile), MatroskaXmlFile)).Elements()
        .Select(e => new
        {
            Name = e.Attribute("name").Value,
            Path = e.Attribute("path").Value,
            Id = e.Attribute("id").Value,
            IsList = isList.Contains(e.Attribute("name").Value),
            ElementType = e.Attribute("type").Value,
            DefaultValue = e.Attribute("default")?.Value,
            Required = (e.Attribute("minOccurs") != null ? int.Parse(e.Attribute("minOccurs").Value) : 0) > 0,
            Documentation = e.Element(ns + "documentation") != null ? e.Element(ns + "documentation").Value : ""
        });

    var elements = elementsEbml.Union(elementsMatroska).Concat(new []
    {
        new
        {
            Name = "Unknown",
            Path = "",
            Id = "0x7FFF",
            IsList = false,
            ElementType = "None",
            DefaultValue = (string)null,
            Required = false,
            Documentation = "Unknown element"
        }
    }).OrderBy(e => e.Path).ToList();
#>
        private static readonly Dictionary<VInt, EbmlElementDescriptor> _elementDescriptorsByVInt = new(<#=elements.Count#>);
        private static readonly Dictionary<ulong, EbmlElementDescriptor> _elementDescriptorsByIdentifier = new(<#=elements.Count#>);

        /// <summary>
        /// Gets a dictionary of all Matroska elements.
        /// </summary>
        public static IReadOnlyDictionary<VInt, EbmlElementDescriptor> ElementDescriptors => _elementDescriptorsByVInt;

        /// <summary>
        /// Gets a dictionary of all Matroska elements.
        /// </summary>
        public static IReadOnlyDictionary<ulong, EbmlElementDescriptor> ElementDescriptorsByIdentifier => _elementDescriptorsByIdentifier;

        static MatroskaSpecification()
        {
            var fields = typeof(MatroskaSpecification).GetFields(BindingFlags.Public | BindingFlags.Static);

            foreach (FieldInfo field in fields.Where(ft => ft.FieldType == typeof(EbmlElementDescriptor)))
            {
                var value = (EbmlElementDescriptor)field.GetValue(null)!;
                _elementDescriptorsByVInt.Add(value.Identifier, value);
            }

            foreach (FieldInfo field in fields.Where(ft => ft.FieldType == typeof(ulong)))
            {
                var identifier = (ulong)field.GetValue(null)!;
                _elementDescriptorsByIdentifier.Add(identifier, _elementDescriptorsByVInt[VInt.FromEncoded(identifier)]);
            }
        }

<#
    foreach (var element in elements)
    {
        string elementType;
        switch (element.ElementType)
        {
            case "master":
                elementType = "MasterElement";
                break;

            case "utf-8":
                elementType = "Utf8String";
                break;

            case "string":
                elementType = "AsciiString";
                break;

            case "binary":
                elementType = "Binary";
                break;

            case "date":
                elementType = "Date";
                break;

            case "float":
                elementType = "Float";
                break;

            case "uinteger":
                elementType = "UnsignedInteger";
                break;

            case "integer":
                elementType = "SignedInteger";
                break;

            default:
                elementType = element.ElementType;
                break;
        }
        var defaultValue = element.DefaultValue == null ? "null" : $"\"{element.DefaultValue}\"";
#>
        /// <summary><#=(element.Required ? "[Required] " : "")#><#=element.Documentation.Replace("\n", "").Replace("      ", "")#></summary>
        public const ulong <#=element.Name#> = <#=element.Id#>;
        public static readonly EbmlElementDescriptor <#=element.Name#>Descriptor
            = new (<#=element.Name#>, nameof(<#=element.Name#>), EbmlElementType.<#=elementType#>, <#= defaultValue#>, <#=element.IsList.ToString().ToLowerInvariant()#>);

<#
    }
#>
    }
}
