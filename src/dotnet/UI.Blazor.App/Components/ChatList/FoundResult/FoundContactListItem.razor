@namespace ActualChat.UI.Blazor.App.Components
@using SearchUI = ActualChat.UI.Blazor.App.Services.SearchUI
@inherits ComputedRenderStateComponent<FoundContactListItem.Model>
@{
    var m = State.Value;
    var chat = m.Chat ?? Chat;
    DebugLog?.LogDebug("Rendered: #{ChatTitle}, ChatId='{ChatId}'", chat.Title, chat.Id);
    var lastTextEntry = m.LastTextEntry;
    var audioState = m.AudioState;
    var isListeningOrRecording = audioState.IsListening || audioState.IsRecording;
    var text = string.IsNullOrEmpty(m.LastTextEntryText) ? "There is no messages yet." : m.LastTextEntryText;
    var textCls = m.Chat?.Kind == ChatKind.Peer ? "two-line" : "";
    _renderedModel = m;
}

<NavbarItem
    Class="high-item"
    Url="@($"/chat/{chat.Id}")"
    ReplaceOnPrefix="/chat/"
    IsSelected="@m.IsSelected">
    <ChildContent>
        <div class="c-container">
            <ChatIcon Chat="@chat" ShowPresence="@true"/>
            <div class="c-description">
                <span class="c-chat-title">
                    <span>@chat.Title</span>
                    <span class="c-incut"></span>
                    @if (lastTextEntry != null && !isListeningOrRecording) {
                        <LastEntryTime LastEntry="@lastTextEntry"/>
                    }
                </span>
                @if (m.Place != null) {
                    <div class="c-place-info text-caption-3">
                        @m.Place.Title
                    </div>
                }
                @if (lastTextEntry != null) {
                    <div class="c-last-message">
                        @if (chat.Kind != ChatKind.Peer && !lastTextEntry.IsSystemEntry) {
                            <span class="c-name">
                                <AuthorName
                                    AuthorSid="@lastTextEntry.AuthorId"
                                    ShowDetailsOnClick="false"
                                    ShowAsYou="true"/>
                            </span>
                            <span class="c-colon">:</span>
                        }
                        <span class="c-text @textCls">
                            @text
                        </span>
                    </div>
                }
            </div>
        </div>
    </ChildContent>
    <Ending/>
</NavbarItem>

@code {
    // Settings data-bubble attributes inside a component instead providing them from ChatList as additional attributes,
    // allows to avoid unnecessary OnParametersSet call during rendering ChatList and correspondingly
    // it allows to avoid extra ComputeState call and Rendering.
    private ILogger? _log;
    private Model? _renderedModel;
    private ChatEntryId _hasBeenReadEntryId;

    [Inject] private ChatUIHub Hub { get; init; } = null!;
    private ChatUI ChatUI => Hub.ChatUI;
    private ChatListUI ChatListUI => Hub.ChatListUI;
    private SearchUI SearchUI => Hub.SearchUI;
    private ScreenSize ScreenSize => Hub.BrowserInfo.ScreenSize.Value;
    private IAuthors Authors => Hub.Authors;
    private IChats Chats => Hub.Chats;
    private IPlaces Places => Hub.Places;
    private Session Session => Hub.Session();

    private ILogger Log => _log ??= Hub.LogFor(GetType());
    private ILogger? DebugLog => Constants.DebugMode.ChatListRelated ? Log : null;

    [Parameter, EditorRequired] public ChatListKind ListKind { get; set; } = ChatListKind.All;
    [Parameter, EditorRequired] public Chat Chat { get; set; } = SpecialChat.Unavailable;
    [Parameter] public bool IsLastItemInBlock { get; set; }
    [Parameter] public bool IsFirstItem { get; set; }

    public FoundContactListItem()
        => Options = ComputedStateComponentOptions.RecomputeStateOnParameterChange;

    // protected override void OnInitialized() {
    //     DebugLog?.LogDebug("OnInitialized: {ListKind} #{Index}", ListKind, Index);
    // }
    //
    // protected override void OnParametersSet() {
    //     DebugLog?.LogDebug("OnParametersSet: {ListKind} #{Index}", ListKind, Index);
    // }

    protected override bool ShouldRender() {
        if (_renderedModel == null)
            return true;

        var m = State.LastNonErrorValue;
        var isTheSame = m == _renderedModel;
        return !isTheSame;
    }

    protected override ComputedState<Model>.Options GetStateOptions()
        => ComputedStateComponent.GetStateOptions(GetType(),
            t => new ComputedState<Model>.Options {
                InitialValue = new (),
                UpdateDelayer = FixedDelayer.NextTick,
                Category = ComputedStateComponent.GetStateCategory(t),
            });

    protected override async Task<Model> ComputeState(CancellationToken cancellationToken)
    {
         // We intentionally use .ConfigureAwait(false) here: this is one of the most frequently called methods.
         // Properties are copied to local vars because of this.
        var chat = Chat;
        var chatTitle = chat.Title;
        var chatId = chat.Id;
        var placeId = chatId.PlaceChatId.PlaceId;
        var place = placeId.IsNone ? null : await Places.Get(Session, placeId, cancellationToken).ConfigureAwait(false);
        DebugLog?.LogDebug("-> ComputeState: #{ChatTitle}", chatTitle);
        var chatState = await ChatUI.GetState(chatId, false, cancellationToken).ConfigureAwait(false);
        if (chatState == null) {
            DebugLog?.LogDebug("<- ComputeState: #{ChatTitle}, No ChatState", chatTitle);
            return Model.None;
        }
        DebugLog?.LogDebug("<- ComputeState: #{ChatTitle}, OK, ChatId={ChatId}", chatTitle, chatId);
        var lastEntry = chatState.Info.LastTextEntry;
        return new() {
            Chat = chatState.Chat,
            Place = place,
            AudioState = chatState.AudioState,
            IsSelected = chatState.IsSelected,
            LastTextEntry = lastEntry,
            LastTextEntryText = chatState.Info.LastTextEntryText,
        };
    }

    private async Task<bool> IsUnreadByOthers(ChatEntry entry, AuthorId ownAuthorId, CancellationToken cancellationToken) {
        var chat = Chat;
        if (_hasBeenReadEntryId == entry.Id)
            return false;

        var isOwnMessage = !ownAuthorId.IsNone && ownAuthorId == entry.AuthorId;
        if (!isOwnMessage)
            return false;

        if (chat.HasSingleAuthor)
            return false;

        var readPositionsStat = await Chats.GetReadPositionsStat(Session, entry.ChatId, cancellationToken).ConfigureAwait(false);
        var canCalculateHasRead = readPositionsStat.CanCalculateHasReadByAnotherAuthor(entry);
        // Do not show `Unread` label for old messages (before the feature was introduced)
        // until we have at least more or less good enough read positions stat.
        if (!canCalculateHasRead)
            return false;

        var hasBeenRead = readPositionsStat.HasReadByAnotherAuthor(entry, ownAuthorId);
        if (hasBeenRead)
            _hasBeenReadEntryId = entry.Id; // Remember that message has been read, so we don't need to recalculate it on next ComputeState cycle.
        return !hasBeenRead;
    }

    // Nested types

    public sealed record Model {
        public static readonly Model None = new();

        public Chat? Chat { get; init; }
        public Place? Place { get; init; }
        public ChatAudioState AudioState { get; init; }
        public string LastTextEntryText { get; init; } = "";
        public ChatEntry? LastTextEntry { get; init; }
        public bool IsSelected { get; init; }
    }
}
