@using BlazorContextMenu
@inherits ComputedStateComponent<ContactListNavbarWidget.Model>
@{
    var m = State.LatestNonErrorValue ?? Model.None;
    var mustPlayPinned = m.MustPlayPinned;
    var isPlaying = mustPlayPinned && m.IsPlaying;
    var mustPlayPinnedClass = "pin-toggle play-pinned"
        + (mustPlayPinned ? "" : " opacity-50")
        + (isPlaying ? " on" : mustPlayPinned ? "" : " off");

    RenderFragment RenderItem(ContactModel c) =>
        @<NavbarItem
             Url="@($"/chat/{c.ShortChatId.UrlEncode()}")"
             IsOnline="@c.IsOnline"
             IsActive="@(m.ActiveChatId == c.ShortChatId || m.ActiveChatId == c.FullChatId)">
            <ChildContent>
                <ContextMenuTrigger MouseButtonTrigger="MouseButtonTrigger.Right" MenuId="@ContactContextMenu.Id" Data="@c.Contact">
                    <div class="flex-x items-center gap-x-2">
                        <UserAuthorCircle UserId="@c.UserId" ShowsPresence="true"/>
                        <div>@c.Contact.Name</div>
                    </div>
                </ContextMenuTrigger>
            </ChildContent>
            <Ending>
                <ChatListPlaybackToggle ChatId="@c.FullChatId" Class="chat-menu-btn blackout"/>
                <ChatListRecordingToggle ChatId="@c.FullChatId" Class="chat-menu-btn blackout"/>
                <ContextMenuToggleTrigger MenuId="@ContactContextMenu.Id" Data="@c.Contact">
                    <div class="flex">
                        <Button Class="btn-round chat-menu-btn blackout">
                            <svg class="w-6 h-6 fill-current" xlmns="http://www.w3.org/2000/svg" viewBox="-1 -1 26 26">
                                <path fill-rule="evenodd" clip-rule="evenodd" d="M12 7C13.104 7 14 6.104 14 5C14 3.896 13.104 3 12 3C10.896 3 10 3.896 10 5C10 6.104 10.896 7 12 7ZM12 10C10.896 10 10 10.896 10 12C10 13.104 10.896 14 12 14C13.104 14 14 13.104 14 12C14 10.896 13.104 10 12 10ZM10 19C10 17.896 10.896 17 12 17C13.104 17 14 17.896 14 19C14 20.104 13.104 21 12 21C10.896 21 10 20.104 10 19Z"/>
                            </svg>
                        </Button>
                        <div class="fixed -right-2">
                            <div class="placement -mt-2">
                                @* <div class="bg-blue-500 w-6 h-6"></div> *@
                            </div>
                        </div>
                    </div>
                </ContextMenuToggleTrigger>
            </Ending>
        </NavbarItem>;

    RenderFragment RenderTab(ContactGroup group, string title) =>
        @<Tab Title="@title" Id="@group.ToString()" Class="flex-y relative overflow-y-hidden h-full contacts-tab">
            <div class="overflow-x-hidden overflow-y-auto custom-scrollbar h-full flex-y my-2">
                @if (group == Group.Value) {
                    @if (m.PinnedContacts.Length > 0) {
                        <div class="pinned-contacts">
                            @foreach (var c in m.PinnedContacts) {
                                @RenderItem(c)
                            }
                        </div>
                        <div class="mx-4 mb-2 border-b border-bg-04"></div>

                        if (m.UnpinnedContacts.Length > 0) {
                            <div class="unpinned-contacts custom-scrollbar">
                                @foreach (var c in m.UnpinnedContacts) {
                                    @RenderItem(c)
                                }
                            </div>
                        }
                    } else {
                        <div class="unpinned-contacts custom-scrollbar">
                            @foreach (var c in m.UnpinnedContacts) {
                                @RenderItem(c)
                            }
                        </div>
                    }
                }
            </div>
        </Tab>;
}

<NavbarGroup Title="Contacts" Class="navbar-contacts" Id="contacts">
    <ChildContent>
        <TabPanel BottomHill="true" ActiveTabChanged="OnActiveTabChanged" TabsClass="wide-left-panel-tabs">
            @RenderTab(ContactGroup.All, "All")
            @RenderTab(ContactGroup.Recent, "Recent")
            @RenderTab(ContactGroup.Favorites, "Favorites")
        </TabPanel>
        <ContactContextMenu/>
    </ChildContent>
</NavbarGroup>

@code {
    [Inject] private Session Session { get; init; } = null!;
    [Inject] private IUserContacts Contacts { get; init; } = null!;
    [Inject] private IUserPresences UserPresences { get; init; } = null!;
    [Inject] private ChatUI ChatUI { get; init; } = null!;
    [Inject] private SearchUI SearchUI { get; init; } = null!;
    [Inject] private IRecentEntries RecentEntries { get; init; } = null!;
    private IMutableState<ContactGroup> Group { get; set; } = null!;

    protected override async Task OnInitializedAsync() {
        await base.OnInitializedAsync();

        Group = StateFactory.NewMutable<ContactGroup>();
    }

    protected override ComputedState<Model>.Options GetStateOptions()
        => new() {
            InitialValue = Model.None,
            UpdateDelayer = UpdateDelayer.MinDelay,
        };

    protected override async Task<Model> ComputeState(CancellationToken cancellationToken) {
        var group = await Group.Use(cancellationToken).ConfigureAwait(false);
        var userContacts = await ListContacts(group, cancellationToken);
        var criteria = await SearchUI.Criteria.Use(cancellationToken).ConfigureAwait(false);
        if (!criteria.IsNullOrEmpty())
            userContacts = userContacts.Where(x => x.Name.Contains(criteria)).ToImmutableArray();

        var contacts = await userContacts
            .Select(async userContact => {
                var presence = await UserPresences.Get(userContact.TargetUserId, cancellationToken).ConfigureAwait(false);
                return new ContactModel(userContact) {
                    IsOnline = presence is Presence.Online or Presence.Recording,
                    FullChatId = ParsedChatId.FormatFullPeerChatId(userContact.OwnerUserId, userContact.TargetUserId),
                    ShortChatId = ParsedChatId.FormatShortPeerChatId(userContact.TargetUserId),
                    UserId = userContact.TargetUserId,
                };
            })
            .Collect()
            .ConfigureAwait(false);

        var pinnedChatIds = await ChatUI.PinnedChatIds.Use(cancellationToken).ConfigureAwait(false);
        var pinnedContacts = contacts
            .Where(c => pinnedChatIds.Contains(c.FullChatId))
            .OrderBy(c => c.Contact.Name)
            .ToArray();
        var unpinnedContacts = contacts
            .Where(c => !pinnedChatIds.Contains(c.FullChatId))
            .OrderBy(c => c.Contact.Name)
            .ToArray();

        var activeChatId = await ChatUI.ActiveChatId.Use(cancellationToken).ConfigureAwait(false);
        var isPlaying = await ChatUI.IsPlaying.Use(cancellationToken).ConfigureAwait(false);
        var mustPlayPinned = await ChatUI.MustPlayPinnedContactChats.Use(cancellationToken).ConfigureAwait(false);

        return new Model {
            PinnedContacts = pinnedContacts,
            UnpinnedContacts = unpinnedContacts,
            ActiveChatId = activeChatId,
            IsPlaying = isPlaying,
            MustPlayPinned = mustPlayPinned,
        };
    }

    private async Task<ImmutableArray<UserContact>> ListContacts(ContactGroup group, CancellationToken cancellationToken)
    {
        var contacts = await Contacts.List(Session, cancellationToken);
        switch (group) {
            case ContactGroup.All:
                return contacts;
            case ContactGroup.Favorites:
                return contacts.Where(x => x.IsFavorite).ToImmutableArray();
            case ContactGroup.Recent:
                var recent = await RecentEntries.ListUserContactIds(Session, 20, cancellationToken).ConfigureAwait(false);
                return contacts.Where(x => recent.Contains(x.Id)).ToImmutableArray();
            default:
                throw new ArgumentOutOfRangeException(nameof(group), group, null);
        }
    }

    public sealed record Model {
        public static Model None { get; } = new();

        public ContactModel[] PinnedContacts { get; init; } = Array.Empty<ContactModel>();
        public ContactModel[] UnpinnedContacts { get; init; } = Array.Empty<ContactModel>();
        public Symbol ActiveChatId { get; init; }
        public bool IsPlaying { get; init; }
        public bool MustPlayPinned { get; init; }
    }

    public sealed record ContactModel(UserContact Contact) {
        public string FullChatId { get; init; } = "";
        public string ShortChatId { get; init; } = "";
        public bool IsOnline { get; init; }
        public string UserId { get; init; } = "";
    };

    private void OnActiveTabChanged(Tab tab) {
        Group.Value = Enum.Parse<ContactGroup>(tab.Id);
    }
}
