@using ActualChat.Users.UI.Blazor.Services
@inherits ComputedStateComponent<ContactListNavbarWidget.Model>
@{
    var m = State.LatestNonErrorValue;

    RenderFragment RenderTab(ContactTab tab, string title) =>
        @<Tab Title="@title" Id="@tab.ToString()" Class="-flex-y relative overflow-y-auto custom-scrollbar h-full contacts-tab">
            <div class="h-full flex-y my-2">
                <ContactList Contacts="m.PinnedContacts" Kind="ContactListKind.Pinned"/>
                <ContactList Contacts="m.UnpinnedContacts" Kind="ContactListKind.Unpinned"/>
            </div>
        </Tab>;
}

<NavbarGroup Title="Contacts" Class="navbar-contacts" Id="contacts">
    <ChildContent>
        <div class="-flex-y w-full h-full">
            <ActiveChatsNavbarWidget/>

            <TabPanel BottomHill="true" Class="overflow-y-hidden" ActiveTabChanged="OnActiveTabChanged" TabsClass="left-panel-tabs">
                @RenderTab(ContactTab.Recent, "Recent")
                @RenderTab(ContactTab.All, "A-Z")
                @* @RenderTab(ContactTab.Favorites, "Favorites") *@
            </TabPanel>
        </div>
        <ContactMenu/>
    </ChildContent>
</NavbarGroup>

@code {
    [Inject] private Session Session { get; init; } = null!;
    [Inject] private IAccounts Accounts { get; init; } = null!;
    [Inject] private IUserContacts Contacts { get; init; } = null!;
    [Inject] private ChatUI ChatUI { get; init; } = null!;
    [Inject] private SearchUI SearchUI { get; init; } = null!;
    [Inject] private IRecentEntries RecentEntries { get; init; } = null!;
    private IMutableState<ContactTab> Group { get; set; } = null!;

    protected override void OnInitialized() {
        base.OnInitialized();
        Group = StateFactory.NewMutable<ContactTab>();
    }

    protected override ComputedState<Model>.Options GetStateOptions()
        => new() {
            InitialValue = Model.None,
            UpdateDelayer = UpdateDelayer.MinDelay,
        };

    protected override async Task<Model> ComputeState(CancellationToken cancellationToken) {
        var account = await Accounts.Get(Session, cancellationToken).ConfigureAwait(false);
        if (!account.IsActive())
            return Model.None;

        var group = await Group.Use(cancellationToken).ConfigureAwait(false);
        var contacts = await ListContacts(group, cancellationToken).ConfigureAwait(false);
        var activeChatId = await ChatUI.ActiveChatId.Use(cancellationToken).ConfigureAwait(false);
        var activeContactId = GetActiveContactId(account.User.Id);

        var searchPhrase = await SearchUI.GetSearchPhrase(cancellationToken).ConfigureAwait(false);
        if (!searchPhrase.IsEmpty)
            contacts = (
                from contact in contacts
                let rank = searchPhrase.GetMatchRank(contact.Name)
                where rank > 0 || contact.TargetUserId == activeContactId
                orderby rank descending
                select contact
                ).ToList();

        var pinnedChatIds = await ChatUI.PinnedChatIds.Use(cancellationToken).ConfigureAwait(false);
        var pinnedContacts = contacts
            .Where(c => pinnedChatIds.ContainsKey(c.GetFullPeerChatId()))
            .ToList();
        var unpinnedContacts = contacts
            .Where(c => !pinnedChatIds.ContainsKey(c.GetFullPeerChatId()))
            .ToList();

        return new Model {
            PinnedContacts = pinnedContacts,
            UnpinnedContacts = unpinnedContacts,
        };

        Symbol GetActiveContactId(string userId) {
            var targetUserId = ParsedChatId.TryParse(activeChatId, out var parsedChatId)
                ? parsedChatId.GetPeerChatTargetUserId(userId)
                : Symbol.Empty;
            return contacts.All(c => c.TargetUserId != targetUserId)
                ? Symbol.Empty
                : // No active contact in the current group
                targetUserId;
        }
    }

    private async Task<List<UserContact>> ListContacts(ContactTab tab, CancellationToken cancellationToken)
    {
        var contacts = await Contacts.List(Session, cancellationToken);
        switch (tab) {
            case ContactTab.All:
                return contacts.ToList();
            case ContactTab.Favorites:
                return contacts.Where(x => x.IsFavorite).ToList();
            case ContactTab.Recent:
                return await RecentEntries
                    .OrderByRecency(Session, contacts, RecencyScope.UserContact, Constants.Contact.MaxRecentContacts, cancellationToken)
                    .ConfigureAwait(false);
            default:
                throw new ArgumentOutOfRangeException(nameof(tab), tab, null);
        }
    }

    private void OnActiveTabChanged(Tab? tab)
        => Group.Value = tab == null ? ContactTab.All : Enum.Parse<ContactTab>(tab.Id);

    public enum ContactTab
    {
        All = 0,
        Favorites,
        Recent,
    }

    public sealed record Model {
        public static Model None { get; } = new() {
            PinnedContacts = new List<UserContact>(),
            UnpinnedContacts = new List<UserContact>(),
        };

        public List<UserContact> PinnedContacts { get; init; } = null!;
        public List<UserContact> UnpinnedContacts { get; init; } = null!;
    }
}
