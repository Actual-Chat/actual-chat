@using BlazorContextMenu
@inherits ComputedStateComponent<ContactListNavbarWidget.Model>
@{
    var m = State.LatestNonErrorValue;

    RenderFragment RenderTab(ContactGroup group, string title) =>
        @<Tab Title="@title" Id="@group.ToString()" Class="-flex-y relative overflow-y-hidden h-full contacts-tab">
            <div class="overflow-x-hidden overflow-y-auto custom-scrollbar h-full flex-y my-2">
                @if (group == Group.Value) {
                    @if (m.PinnedContacts.Length > 0) {
                        <div class="pinned-contacts">
                            @foreach (var c in m.PinnedContacts) {
                                <ContextMenuTrigger MouseButtonTrigger="MouseButtonTrigger.Right" MenuId="@ContactMenu.MenuId" Data="@c">
                                    <ContactNavItem Contact="c"/>
                                </ContextMenuTrigger>
                            }
                        </div>
                        <div class="mx-4 mb-2 border-b border-bg-04"></div>

                        if (m.UnpinnedContacts.Length > 0) {
                            <div class="unpinned-contacts custom-scrollbar">
                                @foreach (var c in m.UnpinnedContacts) {
                                    <ContextMenuTrigger MouseButtonTrigger="MouseButtonTrigger.Right" MenuId="@ContactMenu.MenuId" Data="@c">
                                        <ContactNavItem Contact="c"/>
                                    </ContextMenuTrigger>
                                }
                            </div>
                        }
                    } else {
                        <div class="unpinned-contacts custom-scrollbar">
                            @foreach (var c in m.UnpinnedContacts) {
                                <ContextMenuTrigger MouseButtonTrigger="MouseButtonTrigger.Right" MenuId="@ContactMenu.MenuId" Data="@c">
                                    <ContactNavItem Contact="c"/>
                                </ContextMenuTrigger>
                            }
                        </div>
                    }
                }
            </div>
        </Tab>;
}

<NavbarGroup Title="Contacts" Class="navbar-contacts" Id="contacts">
    <ChildContent>
        <div class="-flex-y w-full h-full">
            <ActiveChatsNavbarWidget/>

            <TabPanel BottomHill="true" ActiveTabChanged="OnActiveTabChanged" TabsClass="wide-left-panel-tabs">
                @RenderTab(ContactGroup.All, "All")
                @RenderTab(ContactGroup.Recent, "Recent")
                @RenderTab(ContactGroup.Favorites, "Favorites")
            </TabPanel>
        </div>
        <ContactMenu/>
    </ChildContent>
</NavbarGroup>

@code {
    [Inject] private Session Session { get; init; } = null!;
    [Inject] private IAccounts Accounts { get; init; } = null!;
    [Inject] private IUserContacts Contacts { get; init; } = null!;
    [Inject] private ChatUI ChatUI { get; init; } = null!;
    [Inject] private SearchUI SearchUI { get; init; } = null!;
    [Inject] private IRecentEntries RecentEntries { get; init; } = null!;
    private IMutableState<ContactGroup> Group { get; set; } = null!;

    protected override void OnInitialized() {
        base.OnInitialized();
        Group = StateFactory.NewMutable<ContactGroup>();
    }

    protected override ComputedState<Model>.Options GetStateOptions()
        => new() {
            InitialValue = Model.None,
            UpdateDelayer = UpdateDelayer.MinDelay,
        };

    protected override async Task<Model> ComputeState(CancellationToken cancellationToken) {
        var account = await Accounts.Get(Session, cancellationToken).ConfigureAwait(false);
        if (!account.IsActive())
            return Model.None;

        var group = await Group.Use(cancellationToken).ConfigureAwait(false);
        var contacts = await ListContacts(group, cancellationToken).ConfigureAwait(false);
        var activeChatId = await ChatUI.ActiveChatId.Use(cancellationToken).ConfigureAwait(false);
        var activeContactId = GetActiveContactId(account.User.Id);

        var searchPhrase = await SearchUI.GetSearchPhrase(cancellationToken).ConfigureAwait(false);
        if (!searchPhrase.IsEmpty)
            contacts = (
                from contact in contacts
                let rank = searchPhrase.GetMatchRank(contact.Name)
                where rank > 0 || contact.TargetUserId == activeContactId
                orderby rank descending, contact.Name
                select contact
                ).ToImmutableArray();

        var pinnedChatIds = await ChatUI.PinnedChatIds.Use(cancellationToken).ConfigureAwait(false);
        var pinnedContacts = contacts
            .Where(c => pinnedChatIds.ContainsKey(c.GetFullPeerChatId()))
            .ToArray();
        var unpinnedContacts = contacts
            .Where(c => !pinnedChatIds.ContainsKey(c.GetFullPeerChatId()))
            .ToArray();

        return new Model {
            PinnedContacts = pinnedContacts,
            UnpinnedContacts = unpinnedContacts,
        };

        Symbol GetActiveContactId(string userId)
        {
            var targetUserId = ParsedChatId.TryParse(activeChatId, out var parsedChatId)
                ? parsedChatId.GetPeerChatTargetUserId(userId)
                : Symbol.Empty;
            return contacts.All(c => c.TargetUserId != targetUserId)
                ? Symbol.Empty
                : // No active contact in the current group
                targetUserId;
        }
    }

    private async Task<ImmutableArray<UserContact>> ListContacts(ContactGroup group, CancellationToken cancellationToken)
    {
        var contacts = await Contacts.List(Session, cancellationToken);
        switch (group) {
            case ContactGroup.All:
                return contacts;
            case ContactGroup.Favorites:
                return contacts.Where(x => x.IsFavorite).ToImmutableArray();
            case ContactGroup.Recent:
                var recent = await RecentEntries.ListUserContactIds(Session, 20, cancellationToken).ConfigureAwait(false);
                return contacts.Where(x => recent.Contains(x.Id)).ToImmutableArray();
            default:
                throw new ArgumentOutOfRangeException(nameof(group), group, null);
        }
    }


    private void OnActiveTabChanged(Tab? tab) {
        Group.Value = tab == null ? ContactGroup.All : Enum.Parse<ContactGroup>(tab.Id);
    }
    public sealed record Model {
        public static Model None { get; } = new();

        public UserContact[] PinnedContacts { get; init; } = Array.Empty<UserContact>();
        public UserContact[] UnpinnedContacts { get; init; } = Array.Empty<UserContact>();
    }
}
