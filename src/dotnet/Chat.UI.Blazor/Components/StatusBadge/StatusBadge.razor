@namespace ActualChat.Chat.UI.Blazor.Components
@inherits ComputedStateComponent<StatusBadge.Model>
@{
    var m = State.Value;
}

<span class="status-badge @m.BadgeClass">
    @switch (Chat) {
        case { Kind: ChatKind.Group or ChatKind.Place, IsPublic: false } when ShowLockIcon:
            <i class="icon-lock text-sm"></i>
            @m.Status
            break;
        case { Kind: ChatKind.Group or ChatKind.Place, IsPublic: true }:
            <i class="icon-globe text-sm"></i>
            @m.Status
            break;
        case { Kind: ChatKind.Peer } when ShowLastSeen:
            <AuthorPresenceText AuthorSid="@m.AuthorSid"/>
            break;
        case { Kind: ChatKind.Peer }:
            @m.Status
            break;
    }
</span>

@code {
    private Chat Chat => ChatContext.Chat;
    private Session Session => ChatContext.Hub.Session();
    private IAuthors Authors => ChatContext.Hub.Authors;

    [Parameter, EditorRequired] public ChatContext ChatContext { get; set; } = null!;
    [Parameter] public bool IsColorful { get; set; } = true;
    [Parameter] public bool ShowLockIcon { get; set; } = true;
    [Parameter] public bool ShowLastSeen { get; set; }

    protected override ComputedState<Model>.Options GetStateOptions()
        => ComputedStateComponent.GetStateOptions(GetType(),
            static t => new ComputedState<Model>.Options() {
                InitialValue = Model.Loading,
                Category = ComputedStateComponent.GetStateCategory(t),
            });

    protected override async Task<Model> ComputeState(CancellationToken cancellationToken) {
        var status = "";
        var badgeClass = "default";
        if (Chat.Kind is ChatKind.Group or ChatKind.Place) {
            status = Chat.IsPublic
                ? Chat.Kind == ChatKind.Place
                    ? "Place\u00A0chat"
                    : "Public"
                : "Private";
            if (IsColorful) {
                badgeClass = "public";
            }
            return new() {
                Status = status,
                BadgeClass = badgeClass,
            };
        }
        var ownAccount = ChatContext.OwnAccount;
        var chatId = Chat.Id;
        if (!chatId.IsPeerChat(out var peerChatId))
            return Model.Loading;

        var peerAccountId = peerChatId.UserIds.OtherThanOrDefault(ownAccount.Id);
        if (peerAccountId.IsNone)
            return Model.Loading;

        var ownAuthor = await Authors.GetOwn(Session, peerChatId, cancellationToken).ConfigureAwait(false);
        var anotherAuthorId = new AuthorId(peerChatId, ownAuthor != null && peerChatId.UserId1 == ownAuthor.UserId ? 2 : 1, AssumeValid.Option);
        var anotherAuthor = await Authors.Get(Session, peerChatId, anotherAuthorId, cancellationToken).ConfigureAwait(false);

        if (anotherAuthor == null)
            return Model.Loading;

        var presence = await Authors.GetPresence(Session, chatId, anotherAuthor.Id, cancellationToken).ConfigureAwait(false);

        status = presence switch {
            Presence.Offline => "Offline",
            Presence.Away => "Away",
            Presence.Online => "Online",
            Presence.Recording => "Online",
            _ => "",
        };
        if (IsColorful) {
            badgeClass = presence switch {
                Presence.Offline => "offline",
                Presence.Away => "away",
                Presence.Online => "online",
                Presence.Recording => "recording",
                _ => "",
            };
        }

        return new() {
            Status = status,
            BadgeClass = badgeClass,
            AuthorSid = anotherAuthorId,
        };
    }

    // Nested types

    public sealed record Model {
        public static readonly Model Loading = new();

        public string Status { get; init; } = "";
        public string BadgeClass { get; init; } = "";
        public string AuthorSid { get; init; } = "";
    }
}
