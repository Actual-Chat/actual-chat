@namespace ActualChat.Chat.UI.Blazor.Components
@using ActualChat.Playback
@using ActualChat.Chat.UI.Blazor.Services
@inherits ComputedStateComponent<ActualChat.Playback.MediaTrackPlaybackState?>
@inject IMediaPlayerService _mediaPlayerService

@if (Words == null) {
    <p class="text">@Entry.Content</p>
} else {
    <p>
        @foreach (var (word, offset, nextOffset) in Words) {
            var cls = "word text-current";
            var playbackState = State.LatestNonErrorValue;
            if (playbackState != null) {
                var playingAt = playbackState.PlayingAt.TotalSeconds;
                if (playingAt >= offset && playingAt < nextOffset)
                    cls = "word text-blue-500";
            }
            <span class="@cls" @onclick="() => HandleWordClick(offset)">@word</span>
        }
    </p>
}

@code {

    [Parameter, EditorRequired]
    public ChatEntry Entry { get; set; } = null!;
    [Parameter]
    public EventCallback<double> PlayClick { get; set; }

    private IReadOnlyCollection<(string,double,double)>? Words { get; set; }

    protected override Task OnParametersSetAsync() {
        if (Entry.TextToTimeMap != null && !Entry.Content.IsNullOrEmpty()) {
            var map = Entry.TextToTimeMap.Value;
            var words = new List<(string, double, double)>();
            var previousBoundary = 0;
            for (var i = 1; i < map.SourcePoints.Length - 1; i++) {
                var boundary = map.SourcePoints[i];
                var currentBoundary = (int)boundary;
                words.Add((Entry.Content[previousBoundary..currentBoundary], map.Map(previousBoundary) ?? 0, map.Map(currentBoundary) ?? map.TargetRange.Max));
                previousBoundary = currentBoundary;
            }
            if (words.Count != 0) {
                words.Add((Entry.Content[previousBoundary..], map.Map(previousBoundary) ?? 0, map.TargetRange.Max));
                Words = words;
            }
        }

        return base.OnParametersSetAsync();
    }

    protected override async Task<MediaTrackPlaybackState?> ComputeState(CancellationToken cancellationToken) {
        var trackId = MediaTrackId.GetAudioTrackId(Entry);
        return await _mediaPlayerService.GetMediaTrackPlaybackState(trackId, cancellationToken);
    }

    private void HandleWordClick(double offset) {
        if (PlayClick.HasDelegate)
            PlayClick.InvokeAsync(offset);
    }

}
