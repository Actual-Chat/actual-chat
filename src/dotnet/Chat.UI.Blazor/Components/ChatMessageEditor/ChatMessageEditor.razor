@namespace ActualChat.Chat.UI.Blazor.Components
@implements IChatMessageEditorBackend
@implements IAsyncDisposable
@using ActualChat.Chat.UI.Blazor.Services
@using ActualChat.Audio.UI.Blazor.Components
@using ActualChat.Chat.UI.Blazor.Module
@using ActualChat.Events
@using ActualChat.Hosting
@using ActualChat.Kvas
@using ActualChat.MediaPlayback
@using ActualChat.Search

<OnUIEvent TEvent="@FocusChatMessageEditor" Handler="OnFocusRequested" />
<OnUIEvent TEvent="@EditMessage" Handler="OnMessageEdit" />
<OnUIEvent TEvent="@CancelMessageEdit" Handler="OnMessageEditCancel" />
<div @ref="Ref" class="chat-message-editor min-h-auto">
    <MentionListManager @key="@MentionListManagerKey" SearchProvider="@MarkupHub.ChatMentionSearchProvider">
        <AttachmentListPreview
            @ref="AttachmentListPreviewRef"
            RemoveRequested="RemoveAttachment"
            ClearAllRequested="ClearAttachments"
            Post="@(_ => Post(clearEditor: true))"/>
        <LinkedMessagePanel />
        <div class="flex-none flex-x justify-items-stretch items-stretch w-full p-0 md:px-3 md:py-2 gap-x-2.5">
            <div class="-flex-y w-full overflow-x-hidden">
                <div class="flex-x gap-x-1.5 px-2 md:px-0 my-1 md:my-0">
                    <div class="post-panel flex-x justify-between outline-none w-full border-bg-01">
                        <ContextMenuToggleTrigger MenuId="@AttachMenu.MenuId" CssClass="self-start">
                            <div class="flex attach-dropdown">
                                <ButtonRound Class="attach-btn">
                                    <i class="icon-attach-2 text-2xl"></i>
                                </ButtonRound>
                                <div class="relative right-12">
                                    <div class="placement"></div>
                                </div>
                            </div>
                        </ContextMenuToggleTrigger>
                        <input class="files-picker" type="file" hidden multiple/>
                        <label for="message-input" class="flex-1 flex-x justify-items-stretch items-center">
                            <SlateEditor @ref="SlateEditorRef" Id="message-input"
                                         Class="message-input -flex-y"
                                         Autofocus="true"
                                         Placeholder="@("#" + Chat.Title)"
                                         Rendered="OnSlateRendered"
                                         Post="text => Post(text)"
                                         Cancel="@(() => OnCancel())"
                                         OpenPrevious="OnOpenPrevious"/>
                            <button class="btn btn-round post-message"
                                    @onclick="_ => Post(clearEditor: true)">
                                <i class="icon-paper-plane text-2xl"></i>
                            </button>
                        </label>
                        <NotifyCallPanel @ref="NotifyCallPanelRef" />
                    </div>
                </div>
                @if (ScreenSizeKind.IsMobile()) {
                    <MobileControlPanel/>
                }
            </div>
            @if (ScreenSizeKind.IsDesktop()) {
                <RecorderPanel/>
            }
        </div>
    </MentionListManager>
    <AttachMenu UploadFilesRequested="OnUploadFilesRequested"/>
</div>

@code {
    private static object MentionListManagerKey { get; } = new();

    private DotNetObjectReference<IChatMessageEditorBackend> BlazorRef { get; set; } = null!;
    private IJSObjectReference JSRef { get; set; } = null!;
    private ElementReference Ref { get; set; }
    private SlateEditor SlateEditorRef { get; set; } = null!;
    private AttachmentListPreview AttachmentListPreviewRef { get; set; } = null!;
    private NotifyCallPanel NotifyCallPanelRef { get; set; } = null!;
    private EditedMarkupConverter EditedMarkupConverter { get; set; } = null!;
    private SyncedStateLease<long?>? LastReadEntryState { get; set; } = null!;

    [Inject] private Session Session { get; init; } = null!;
    [Inject] private ErrorUI ErrorUI { get; init; } = null!;
    [Inject] private ChatUI ChatUI { get; init; } = null!;
    [Inject] private IChats Chats { get; init; } = null!;
    [Inject] private IChatAuthors ChatAuthors { get; init; } = null!;
    [Inject] private MarkupHub MarkupHub { get; init; } = null!;
    [Inject] private UICommander UICommander { get; init; } = null!;
    [Inject] private MomentClockSet Clocks { get; init; } = null!;
    [Inject] private IJSRuntime JS { get; init; } = null!;

    [CascadingParameter] public Chat Chat { get; set; } = null!;
    [CascadingParameter] public ScreenSize ScreenSizeKind { get; set; }

    protected override async Task OnInitializedAsync() {
        EditedMarkupConverter = new EditedMarkupConverter(MarkupHub);
        LastReadEntryState = await ChatUI.LeaseLastReadEntryState(Chat.Id, default).ConfigureAwait(false);
    }

    protected override void OnParametersSet()
        => MarkupHub.ChatId = Chat.Id;

    public async ValueTask DisposeAsync() {
        await JSRef.DisposeSilentlyAsync("dispose");
        JSRef = null!;
        BlazorRef.DisposeSilently();
        BlazorRef = null!;
        LastReadEntryState?.Dispose();
        LastReadEntryState = null!;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender) {
        if (firstRender) {
            BlazorRef = DotNetObjectReference.Create<IChatMessageEditorBackend>(this);
            JSRef = await JS.InvokeAsync<IJSObjectReference>(
                $"{ChatBlazorUIModule.ImportName}.ChatMessageEditor.create",
                Ref, BlazorRef);
        }
    }

    private async Task Post(string? text = null, bool clearEditor = false) {
        text ??= await SlateEditorRef.GetText();
        var attachments = AttachmentListPreviewRef.GetAttachments();
        if (text.IsNullOrEmpty() && !attachments.Any())
            return;

        try {
            if (clearEditor)
                await SlateEditorRef.Clear();
            AttachmentListPreviewRef.Clear();
            StateHasChanged();
            var linked = ChatUI.LinkedChatEntry.Value;
            ChatUI.LinkedChatEntry.Value = null;
            var entryId = linked?.Type == ChatEntryLinkType.Edit
                ? await UpdateMessage(linked.Entry, text)
                : await PostNewMessage(text, linked?.Entry);

            if (LastReadEntryState != null)
                LastReadEntryState.Value = entryId;
            _ = ChatUI.AddActiveChat(Chat.Id);
            _ = TryUpdatePeerChatRecency();

            await JSRef.InvokeVoidAsync("onPostSucceeded");
        }
        catch (Exception e) {
            ErrorUI.ShowError(e);
        }
    }

    private async Task<long> PostNewMessage(string text, ChatEntry? repliedChatEntry) {
        ChatUI.LinkedChatEntry.Value = null;
        UICommander.CancelUpdateDelays();
        return await JSRef.InvokeAsync<long>("postMessage", Chat.Id, text, repliedChatEntry?.Id);
    }

    private async Task<long> UpdateMessage(ChatEntry chatEntry, string text) {
        ChatUI.LinkedChatEntry.Value = null;
        await UICommander.Run(new IChats.UpsertTextEntryCommand(Session, chatEntry.ChatId, chatEntry.Id, text));
        return chatEntry.Id;
    }

    [JSInvokable]
    public void CloseNotifyPanel()
        => NotifyCallPanelRef.OnCloseClick();

    [JSInvokable]
    public bool AddAttachment(int id, string url, string? fileName, string? fileType, int length)
        => AttachmentListPreviewRef.AddAttachment(id, url, fileName, fileType, length);

    private async Task RemoveAttachment(Attachment attachment)
        => await JSRef.InvokeVoidAsync("removeAttachment", attachment.Id);

    private async Task ClearAttachments(ImmutableArray<Attachment> attachments)
        => await JSRef.InvokeVoidAsync("clearAttachments", attachments);

    private async Task EditMessage(ChatEntry chatEntry, CancellationToken cancellationToken)
    {
        ChatUI.LinkedChatEntry.Value = new(ChatEntryLinkType.Edit, chatEntry);
        UICommander.CancelUpdateDelays();

        var editableMarkup = await EditedMarkupConverter.Convert(chatEntry.Content, cancellationToken);
        await SlateEditorRef.SetMarkup(editableMarkup, cancellationToken);
        await SlateEditorRef.Focus(cancellationToken);
        await SlateEditorRef.MoveCursorToEnd(cancellationToken);
    }

    private async Task TryUpdatePeerChatRecency() {
        await Update(RecencyScope.ChatContact, Chat.Id).ConfigureAwait(false);

        if (Chat.ChatType == ChatType.Peer) {
            var contact = await Chats.GetPeerChatContact(Session, Chat.Id, CancellationToken.None).Require().ConfigureAwait(false);
            await Update(RecencyScope.UserContact, contact.Id).ConfigureAwait(false);
        }

        Task Update(RecencyScope scope, string key) {
            var command = new IRecentEntries.UpdateCommand(Session, scope, key, Clocks.SystemClock.UtcNow);
            return UICommander.Run(command, CancellationToken.None);
        }
    }

    private async Task OnSlateRendered()
        => await JSRef.InvokeVoidAsync("onSlateEditorRendered");

    private Task OnFocusRequested(FocusChatMessageEditor @event, CancellationToken cancellationToken)
        => SlateEditorRef.Focus(cancellationToken);

    private async Task OnMessageEdit(EditMessage @event, CancellationToken cancellationToken) {
        var chatEntry = @event.ChatEntry;
        await EditMessage(chatEntry, cancellationToken);
    }

    private async Task OnMessageEditCancel(CancelMessageEdit cancelMessageEdit, CancellationToken cancellationToken) {
        await OnCancel(cancellationToken);
    }

    private async Task OnOpenPrevious() {
        var chatId = ChatUI.ActiveChatId.Value;
        var author = await ChatAuthors.Get(Session, chatId, CancellationToken.None);
        if (author == null)
            return;

        var chatIdRange = await Chats.GetIdRange(Session, chatId, ChatEntryType.Text, CancellationToken.None);
        var lastEditableEntry = await Chats.NewEntryReader(Session, chatId, ChatEntryType.Text).GetLast(chatIdRange, x => x.AuthorId == author.Id && x.StreamId.IsEmpty, CancellationToken.None);
        if (lastEditableEntry == null)
            return;

        await EditMessage(lastEditableEntry, CancellationToken.None);
    }

    private async Task OnUploadFilesRequested()
        => await JSRef.InvokeVoidAsync("showFilesPicker");

    private async Task OnCancel(CancellationToken cancellationToken = default)
    {
        ChatUI.LinkedChatEntry.Value = null;
        UICommander.CancelUpdateDelays();
        await SlateEditorRef.Clear();
        await SlateEditorRef.Focus(cancellationToken);
    }
}
