@namespace ActualChat.Chat.UI.Blazor.Components
@implements IChatMessageEditorBackend
@implements IAsyncDisposable
@using ActualChat.Chat.UI.Blazor.Services
@using ActualChat.Audio.UI.Blazor.Components
@using ActualChat.Chat.UI.Blazor.Module
@using ActualChat.Hosting
@using ActualChat.MediaPlayback

@{
    var placeholder = "#" + Chat.Title;
}

<div @ref="EditorRef" class="chat-message-editor px-1.5 pb-1.5">
    <CascadingValue Value="@MentionListContext" IsFixed="true">
        <ChatMentionsRetriever ChatId="@Chat.Id" />
        <div class="absolute left-0 right-0 px-1.5 pb-1.5 z-50">
            <div class="relative w-full">
                <div class="absolute bottom-0 w-full">
                    <MentionListView Class="bg-secondary" />
                </div>
            </div>
        </div>

        <div class="flex-none flex-x justify-items-stretch items-stretch w-full bg-secondary ">
            <div class="flex-y justify-between outline-none bg-primary w-full rounded-md border-secondary">
                <input class="files-picker" type="file" hidden multiple/>
                <AttachmentListPreview @ref="AttachmentListPreviewRef"
                                       RemoveRequested="@(c => RemoveAttachment(c))" />
                <label for="message-input" class="flex-1 flex-x justify-items-stretch items-center">
                    <div class="flex-none self-center m-3 mr-0">
                        <AttachDropdown UploadFilesRequested="OnUploadFilesRequested"/>
                    </div>
                    <SlateEditor @ref="SlateEditorRef" Id="message-input"
                                 Class="message-input flex-1 -flex-y overflow-y-auto max-h-36 md:max-h-72 my-3 ml-3 mr-1 md:mr-3 break-words outline-none hover:cursor-text text-primary block"
                                 Placeholder="@placeholder"
                                 OnPost="Post" OnRendered="OnSlateEditorRendered"/>
                    <button class="post-message sticky self-end outline-none text-secondary pr-1 py-1 hidden"
                            @onclick="_ => Post()">
                        <svg class="fill-current w-9 h-9 pr-1" viewBox="-4 -4 32 32" id="icon" xmlns="http://www.w3.org/2000/svg">
                            <path d="M24 0l-6 22-8.129-7.239 7.802-8.234-10.458 7.227-7.215-1.754 24-12zm-15 16.668v7.332l3.258-4.431-3.258-2.901z"/>
                        </svg>
                    </button>
                </label>
            </div>
            <div class="recorder-buttons flex-x absolute right-4 bottom-4 z-40 shadow-[0_35px_35px_rgba(0,0,0,0.25)] animate-display-from-right">
                <div class="language-button flex hidden">
                    <ChatLanguageToggle/>
                </div>
                <div class="recorder-button flex">
                    <AudioRecorderToggle ChatId="@Chat.Id" Toggled="@(new EventCallback<bool>(null, OnRecorderButtonToggled))"/>
                </div>
            </div>
        </div>
    </CascadingValue>
</div>

@code {
    [Inject] private IChats Chats { get; init; } = null!;
    [Inject] private ChatPlayers ChatPlayers { get; init; } = null!;
    [Inject] private Session Session { get; init; } = null!;
    [Inject] private ErrorUI ErrorUI { get; init; } = null!;
    [Inject] private MomentClockSet Clocks { get; init; } = null!;
    [Inject] private HostInfo HostInfo { get; init; } = null!;
    [Inject] private IJSRuntime JS { get; init; } = null!;
    [Inject] private MentionListContext MentionListContext { get; set; } = null!;

    private ElementReference EditorRef { get; set; }
    private SlateEditor SlateEditorRef { get; set; } = null!;
    private AttachmentListPreview AttachmentListPreviewRef { get; set; } = null!;
    private IJSObjectReference JSRef { get; set; } = null!;
    private DotNetObjectReference<IChatMessageEditorBackend> BlazorRef { get; set; } = null!;


    [CascadingParameter] public Chat Chat { get; set; } = null!;

    public async ValueTask DisposeAsync()
    {
        if (JSRef != null!)
            await JSRef.DisposeSilentlyAsync("dispose").ConfigureAwait(true);
        // ReSharper disable once ConstantConditionalAccessQualifier
        BlazorRef?.Dispose();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender) {
        if (firstRender) {
            BlazorRef = DotNetObjectReference.Create<IChatMessageEditorBackend>(this);
            JSRef = await JS.InvokeAsync<IJSObjectReference>(
                $"{ChatBlazorUIModule.ImportName}.ChatMessageEditor.create",
                EditorRef, BlazorRef
                ).ConfigureAwait(true);
        }
    }

    private async Task Post(string? text = null) {
        if (text == null)
            text = await SlateEditorRef.GetText();
        var attachments = AttachmentListPreviewRef.GetAttachments();
        if (text.IsNullOrEmpty() && !attachments.Any())
            return;

        try {
            _ = await JSRef.InvokeAsync<string>("postMessage", Chat.Id, text).ConfigureAwait(true);
            await JSRef.InvokeVoidAsync("onPostSucceeded");
            await SlateEditorRef.Clear();
            AttachmentListPreviewRef.Clear();
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception e) {
            ErrorUI.ShowError(e);
        }
    }

    [JSInvokable]
    public bool AddAttachment(int id, string url, string? fileName, string? fileType, int length)
        => AttachmentListPreviewRef.AddAttachment(id, url, fileName, fileType, length);

    private async Task OnSlateEditorRendered() {
        await JSRef.InvokeVoidAsync("onSlateEditorRendered").ConfigureAwait(true);
    }

    private async Task RemoveAttachment(Attachment attachment) {
        await JSRef.InvokeVoidAsync("removeAttachment", attachment.Id).ConfigureAwait(true);
    }

    private async Task OnUploadFilesRequested() {
        await JSRef.InvokeVoidAsync("showFilesPicker").ConfigureAwait(true);
    }

    private Task OnRecorderButtonToggled(bool isRecording) {
        if (isRecording == false)
            return Task.CompletedTask;
        ChatPlayers.StartRealtimePlayback(false);
        return Task.CompletedTask;
    }
}
