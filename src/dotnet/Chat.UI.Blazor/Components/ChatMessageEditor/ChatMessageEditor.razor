@namespace ActualChat.Chat.UI.Blazor.Components
@implements IChatMessageEditorBackend
@implements IAsyncDisposable
@using ActualChat.Chat.UI.Blazor.Services
@using ActualChat.Audio.UI.Blazor.Components
@using ActualChat.Chat.UI.Blazor.Events
@using ActualChat.Chat.UI.Blazor.Module
@using ActualChat.Contacts
@using ActualChat.Hosting
@using ActualChat.Kvas
@using ActualChat.MediaPlayback
@using ActualChat.Search
@using Stl.Locking
@{
    var editorCls = "";
    if (ScreenSize.IsNarrow())
        editorCls = "narrow";
    if (ScreenSize.IsWide())
        editorCls = "wide";
}

<OnUIEvent TEvent="@FocusChatMessageEditorEvent" Handler="OnFocusChatMessageEditorEvent" />
<OnUIEvent TEvent="@EditChatMessageEvent" Handler="OnEditChatMessageEvent" />
<OnUIEvent TEvent="@CancelChatMessageEditEvent" Handler="OnCancelChatMessageEditEvent" />
<div @ref="Ref" class="chat-message-editor min-h-auto @editorCls">
    <MentionListManager @key="@MentionListManagerKey" SearchProvider="@ChatMarkupHub.MentionSearchProvider">
        <AttachmentList
            @key="AttachmentListKey"
            @ref="AttachmentListRef"
            JSRef="JSRef"
            RemoveClick="@(a => RemoveAttachment(a))"
            ClearClick="@(_ => ClearAttachments())"
            PostClick="@(_ => Post())"/>
        <RelatedChatEntryPanel />
        <div class="flex-none flex-x justify-items-stretch items-stretch w-full p-0 md:px-3 md:py-2 gap-x-2.5">
            <div class="post-panel-wrapper">
                <div class="flex-x py-1 md:py-0 bg-07 md:bg-01">
                    <div class="post-panel flex-auto">
                        <div class="flex-x attach-dropdown">
                            <ButtonRound Class="attach-btn">
                                <i class="icon-attach-2 text-2xl"></i>
                            </ButtonRound>
                            <input class="file-picker" type="file" hidden multiple/>
                        </div>
                        <label for="message-input" class="flex-auto flex-x justify-items-stretch items-center">
                            <MarkupEditor
                                @key="MarkupEditorKey"
                                @ref="MarkupEditorRef"
                                MentionNamer="@ChatMarkupHub.MentionNamer"
                                HtmlConverter="@ChatMarkupHub.EditorHtmlConverter"
                                Id="message-input"
                                Class="message-input -flex-y"
                                Autofocus="Autofocus"
                                Placeholder="@("#" + Chat.Title)"
                                Post="text => Post(text)"
                                Cancel="@(() => OnCancel())"
                                OpenPrevious="OnOpenPrevious"/>
                        </label>
                        <button class="btn btn-round post-message swiftclick-ignore"
                                @onmousedown="@(_ => Post())"
                                @onmousedown:preventDefault="true">
                            <i class="icon-paper-plane text-2xl"></i>
                        </button>
                        <NotifyCallPanel @ref="NotifyCallPanelRef" />
                    </div>
                </div>
                @if (ScreenSize.IsNarrow()) {
                    <div class="audio-panel-wrapper">
                        <ChatAudioPanel/>
                    </div>
                }
            </div>
            @if (ScreenSize.IsWide()) {
                <ChatAudioPanel/>
            }
        </div>
    </MentionListManager>
</div>

@code {
    private static object MentionListManagerKey { get; } = new();
    private static object AttachmentListKey { get; } = new();
    private static object MarkupEditorKey { get; } = new();

    private bool Autofocus => ScreenSize.IsWide();
    private DotNetObjectReference<IChatMessageEditorBackend> BlazorRef { get; set; } = null!;
    private IJSObjectReference JSRef { get; set; } = null!;
    private ElementReference Ref { get; set; }
    private MarkupEditor MarkupEditorRef { get; set; } = null!;
    private AttachmentList AttachmentListRef { get; set; } = null!;
    private NotifyCallPanel NotifyCallPanelRef { get; set; } = null!;
    private IChatMarkupHub ChatMarkupHub { get; set; } = null!;
    private SyncedStateLease<ChatPosition>? ReadPositionState { get; set; } = null!;

    [Inject] private Session Session { get; init; } = null!;
    [Inject] private IChats Chats { get; init; } = null!;
    [Inject] private IAuthors Authors { get; init; } = null!;
    [Inject] private IContacts Contacts { get; init; } = null!;
    [Inject] private KeyedFactory<IChatMarkupHub, ChatId> ChatMarkupHubFactory { get; init; } = null!;
    [Inject] private ChatUI ChatUI { get; init; } = null!;
    [Inject] private ActiveChatsUI ActiveChatsUI { get; init; } = null!;
    [Inject] private ErrorUI ErrorUI { get; init; } = null!;
    [Inject] private TuneUI TuneUI { get; init; } = null!;
    [Inject] private UICommander UICommander { get; init; } = null!;
    [Inject] private MomentClockSet Clocks { get; init; } = null!;
    [Inject] private IJSRuntime JS { get; init; } = null!;
    [Inject] private HostInfo HostInfo { get; init; } = null!;

    [CascadingParameter] public Chat Chat { get; set; } = null!;
    [CascadingParameter] public ScreenSize ScreenSize { get; set; }

    public async ValueTask DisposeAsync() {
        await JSRef.DisposeSilentlyAsync("dispose");
        JSRef = null!;
        BlazorRef.DisposeSilently();
        BlazorRef = null!;
        ReadPositionState?.DisposeSilently();
        ReadPositionState = null!;
    }

    protected override async Task OnParametersSetAsync() {
        var chatId = Chat.Id;
        var oldChatId = ChatMarkupHub?.ChatId ?? default;
        if (oldChatId == chatId)
            return;

        ChatMarkupHub = ChatMarkupHubFactory[chatId];
        ReadPositionState.DisposeSilently();
        ReadPositionState = null;
        ReadPositionState = await ChatUI.LeaseReadPositionState(chatId, default);

        if (JSRef != null!) {
            // Only when rendered
            await ClearAttachments();
            await MarkupEditorRef.Clear(Autofocus);
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender) {
        if (firstRender) {
            BlazorRef = DotNetObjectReference.Create<IChatMessageEditorBackend>(this);
            JSRef = await JS.InvokeAsync<IJSObjectReference>(
                $"{ChatBlazorUIModule.ImportName}.ChatMessageEditor.create",
                Ref, BlazorRef);
            await MarkupEditorRef.WhenReady;
            await JSRef.InvokeVoidAsync("onMarkupEditorReady", MarkupEditorRef.JSRef);
        }
    }

    // Backend API

    [JSInvokable]
    public void CloseNotifyPanel()
        => NotifyCallPanelRef.Close();

    [JSInvokable]
    public bool AddAttachment(int id, string url, string? fileName, string? fileType, int length)
        => AttachmentListRef.Add(id, url, fileName, fileType, length);

    // Private methods
    [Inject] private BannerUI BannerUI { get; set; } = null!;

    private async Task Post(string? text = null) {
        text ??= await MarkupEditorRef.GetText();
        text = text.Trim();
        var attachments = AttachmentListRef.Attachments;
        if (text.IsNullOrEmpty() && !attachments.Any())
            return;

        _ = TuneUI.Play("send-message");
        try {
            AttachmentListRef.Attachments = ImmutableArray<Attachment>.Empty;
            _ = MarkupEditorRef.Clear();

            var relatedChatEntry = ChatUI.RelatedChatEntry.Value;
            var relatedChatEntryId = relatedChatEntry?.Id ?? default;
            ChatUI.HideRelatedEntry(updateUI: false);

            long readEntryLid;
            if (relatedChatEntry is { Kind: RelatedEntryKind.Edit }) {
                if (relatedChatEntryId.IsNone)
                    throw new InternalError("Invalid ChatUI.RelatedChatEntry value.");
                await UICommander.Run(new IChats.UpsertTextEntryCommand(Session, relatedChatEntryId.ChatId, relatedChatEntryId.LocalId, text));
                readEntryLid = relatedChatEntryId.LocalId;

            } else {
                var repliedEntryLid = relatedChatEntryId.IsNone ? (long?)null : relatedChatEntryId.LocalId;
                if (HostInfo is { AppKind: AppKind.MauiApp, Platform: Platform.iOS }) {
                    // iOS doesn't allow to post from JS, so we have to use workaround here
                    // TODO: add support for attachments on iOS
                    var command = new IChats.UpsertTextEntryCommand(Session, Chat.Id, null, text) {
                        RepliedChatEntryId = repliedEntryLid,
                    };
                    var chatEntry = await UICommander.Run(command, CancellationToken.None);
                    readEntryLid = chatEntry.Value.LocalId;
                } else {
                    readEntryLid = await JSRef.InvokeAsync<long>("post", Chat.Id, text, repliedEntryLid);
                }
            }

            if (ReadPositionState != null && ReadPositionState.Value.EntryLid < readEntryLid)
                ReadPositionState.Value = new ChatPosition(readEntryLid);
            _ = ActiveChatsUI.AddActiveChat(Chat.Id);
            await ClearAttachments();
        }
        catch (Exception e) {
            AttachmentListRef.Attachments = attachments;
            ErrorUI.ShowError(e);
        }
    }

    private async Task Edit(ChatEntry chatEntry, CancellationToken cancellationToken)
    {
        ChatUI.ShowRelatedEntry(RelatedEntryKind.Edit, chatEntry.Id, focusOnEditor: true);
        await MarkupEditorRef.SetText(chatEntry.Content, mustFocus: false);
    }

    private ValueTask ShowFilePicker()
        => JSRef.InvokeVoidAsync("showFilePicker");

    private ValueTask RemoveAttachment(Attachment attachment) {
        AttachmentListRef.Attachments = AttachmentListRef.Attachments.Remove(attachment);
        return JSRef.InvokeVoidAsync("removeAttachment", attachment.Id);
    }

    private ValueTask ClearAttachments() {
        AttachmentListRef.Attachments = ImmutableArray<Attachment>.Empty;
        return JSRef.InvokeVoidAsync("clearAttachments");
    }

    // Event handlers

    private async Task OnOpenPrevious() {
        var chatId = ChatUI.SelectedChatId.Value;
        if (chatId.IsNone)
            return;

        var author = await Authors.GetOwn(Session, chatId, CancellationToken.None);
        if (author == null)
            return;

        var chatIdRange = await Chats.GetIdRange(Session, chatId, ChatEntryKind.Text, CancellationToken.None);
        var idTileLayer = ChatEntryReader.IdTileStack.Layers[1]; // 5*4 = scan by 20 entries
        var chatEntryReader = Chats.NewEntryReader(Session, chatId, ChatEntryKind.Text, idTileLayer);
        var lastEditableEntry = await chatEntryReader.GetLast(
            chatIdRange,
            x => x.AuthorId == author.Id && x is { HasMediaEntry: false, IsStreaming: false },
            1000, // Max. 1000 entries to scan upwards
            CancellationToken.None);
        if (lastEditableEntry == null)
            return;

        await Edit(lastEditableEntry, CancellationToken.None);
    }

    private async Task OnCancel(CancellationToken cancellationToken = default)
    {
        ChatUI.HideRelatedEntry();
        await MarkupEditorRef.Clear(mustFocus: true);
    }

    // UIEventHub event handlers

    private async Task OnFocusChatMessageEditorEvent(FocusChatMessageEditorEvent @event, CancellationToken cancellationToken)
        => await MarkupEditorRef.Focus();

    private async Task OnEditChatMessageEvent(EditChatMessageEvent @event, CancellationToken cancellationToken) {
        var chatEntry = @event.Entry;
        await Edit(chatEntry, cancellationToken);
    }

    private async Task OnCancelChatMessageEditEvent(CancelChatMessageEditEvent @event, CancellationToken cancellationToken) {
        await OnCancel(cancellationToken);
    }
}
