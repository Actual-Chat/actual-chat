@using ActualChat.Chat.UI.Blazor.Module
@implements IAttachmentListBackend
@implements IAsyncDisposable
@namespace ActualChat.Chat.UI.Blazor.Components

<input @ref="FilePickerRef" type="file" hidden multiple/>

@if (_attachments.Count > 0) {
    <div class="attachment-list-wrapper">
        <div class="flex-1 flex-x justify-between p-2 pb-0">
            <span class="flex font-medium items-center min-h-6">
                @_attachments.Count file@(_attachments.Count == 0 ? "" : "s")
            </span>
            <Button Class="btn-sm clear-attachments-btn" Click="_ => Clear()">
                Remove all
            </Button>
        </div>
        <ul class="attachment-list custom-scrollbar-x">
            @foreach (var attachment in _attachments) {
                var uploadStyle = $"width: {attachment.Progress}%;";
                var uploadProgressClass = "attachment-upload-progress";
                if (attachment.Uploaded) {
                    uploadProgressClass += " attachment-upload-completed";
                }
                <li class="attachment-wrapper">
                    <div class="flex-y relative">
                        <div class="attachment-item">
                            <ButtonSquare Click="@(() => OnRemoveClick(attachment))" Class="remove-attachment-btn">
                                <i class="icon-trash03 text-2xl font-thin text-04"></i>
                            </ButtonSquare>
                            @if (attachment.IsImage) {
                                <img src="@attachment.Url" alt="image"/>
                            } else {
                                <div class="flex items-center justify-center p-3">
                                    <img src="/dist/images/attachment.svg" alt="attachment" class="h-12">
                                </div>
                            }
                        </div>
                        <div class="attachment-filename" title="@attachment.FileName">
                            @attachment.FileName
                        </div>
                        <div class="@uploadProgressClass" style="@uploadStyle"></div>
                    </div>
                </li>
            }
            @if (_attachments.Count < 10) {
                <li class="attachment-wrapper flex min-w-34 justify-center">
                    <ButtonRound Class="add-attachment" Click="@OnAddClick">
                        <i class="icon-plus text-2xl text-icons-01"></i>
                    </ButtonRound>
                </li>
            }
        </ul>
    </div>
}

@code {
    private readonly object _lock = new();
    private readonly TaskCompletionSource<Unit> _whenReadySource = TaskCompletionSourceExt.New<Unit>();
    private ImmutableList<Attachment> _attachments = ImmutableList<Attachment>.Empty;
    private DotNetObjectReference<IAttachmentListBackend> BlazorRef { get; set; } = null!;
    private ElementReference FilePickerRef { get; set; }

    [Inject] private ErrorUI ErrorUI { get; init; } = null!;
    [Inject] private IJSRuntime JS { get; init; } = null!;

    public IJSObjectReference JSRef { get; private set; } = null!;
    public Task WhenReady => _whenReadySource.Task;
    public bool IsUploading => _attachments.Any(x => !x.Uploaded);

    public async ValueTask DisposeAsync() {
        _whenReadySource.TrySetCanceled();
        await JSRef.DisposeSilentlyAsync("dispose");
        JSRef = null!;
        BlazorRef.DisposeSilently();
        BlazorRef = null!;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender) {
        if (firstRender) {
            BlazorRef = DotNetObjectReference.Create<IAttachmentListBackend>(this);
            JSRef = await JS.InvokeAsync<IJSObjectReference>($"{ChatBlazorUIModule.ImportName}.AttachmentList.create",
                BlazorRef,
                FilePickerRef);
            _whenReadySource.TrySetResult(default);
        }
    }

    public async Task Clear() {
        lock (_lock)
            _attachments = ImmutableList<Attachment>.Empty;

        await InvokeClear();
        StateHasChanged();
    }

    public ResetIntent PopSnapshot() {
        var attachments = PopAttachments();
        StateHasChanged();

        var mediaIds = attachments.Where(x => x.Uploaded).Select(x => x.MediaId).ToImmutableArray();
        return new (mediaIds, () => Rollback(attachments), InvokeClear);

        ImmutableList<Attachment> PopAttachments()
        {
            lock (_lock) {
                var backup = _attachments;
                _attachments = ImmutableList<Attachment>.Empty;
                return backup;
            }
        }
    }

    private void Rollback(ImmutableList<Attachment> attachments)
    {
        lock (_lock)
            _attachments = attachments;
        StateHasChanged();
    }

    [JSInvokable]
    public bool OnAttachmentAdded(int id, string url, string? fileName, string? fileType, int length) {
        var error = TryAdd();
        if (!error.IsNullOrEmpty()) {
            ErrorUI.ShowError(error);
            return false;
        }

        StateHasChanged();
        return true;

        string? TryAdd() {
            if (length > Constants.Attachments.FileSizeLimit) {
                return "File is too big. Max file size: 8Mb.";
            }

            if (_attachments.Count >= Constants.Attachments.FileCountLimit) {
                return "Too many files. Max allowed number is 10.";
            }

            _attachments = _attachments.Add(new(id, url, fileName ?? "", fileType ?? "", length));
            return null;
        }
    }

    [JSInvokable]
    public void OnUploadProgress(int id, int progress) {
        UpdateAttachment(id, x => x with { Progress = progress });
        StateHasChanged();
    }

    [JSInvokable]
    public void OnUploadSucceed(int id, MediaId mediaId) {
        UpdateAttachment(id, x => x with { MediaId = mediaId });
        StateHasChanged();
    }

    private Task OnAddClick()
        => JSRef.InvokeVoidAsync("showFilePicker").AsTask();

    private Task OnRemoveClick(Attachment attachment) {
        lock (_lock)
            _attachments = _attachments.Remove(attachment);

        return JSRef.InvokeVoidAsync("remove", attachment.Id).AsTask();
    }

    private void UpdateAttachment(int id, Func<Attachment, Attachment> updater) {
        lock (_lock) {
            var i = _attachments.FindIndex(x => x.Id == id);
            if (i < 0)
                return;

            _attachments = _attachments.SetItem(i, updater(_attachments[i]));
        }
    }

    private ValueTask InvokeClear()
        => JSRef.InvokeVoidAsync("clear");

    public sealed class ResetIntent : IAsyncDisposable {
        private readonly Func<ValueTask> _confirm;
        private readonly Action _rollback;
        private bool _isRolledBack;
        public ImmutableArray<MediaId> Attachments { get; }

        internal ResetIntent(ImmutableArray<MediaId> attachments, Action rollback, Func<ValueTask> confirm) {
            Attachments = attachments;
            _rollback = rollback;
            _confirm = confirm;
        }

        public void Rollback() {
            _rollback();
            _isRolledBack = true;
        }

        public ValueTask DisposeAsync() {
            return !_isRolledBack ? _confirm() : ValueTask.CompletedTask;
        }
    }

    private record Attachment(int Id, string Url, string FileName, string FileType, int Length, int Progress = 0, MediaId MediaId = default)
    {
        public bool IsImage => FileType?.OrdinalIgnoreCaseStartsWith("image") ?? false;
        public bool Uploaded => Progress == 100 && !MediaId.IsNone;
    }
}
