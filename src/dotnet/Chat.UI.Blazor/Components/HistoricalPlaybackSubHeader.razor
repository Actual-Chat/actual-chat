@inherits ComputedStateComponent<HistoricalPlaybackSubHeader.Model>
@namespace ActualChat.Chat.UI.Blazor.Components
@using ActualChat.Chat.UI.Blazor.Services
@using ActualChat.MediaPlayback
@{
    var m = State.ValueOrDefault ?? Model.NotPlaying;
    if (m == Model.NotPlaying)
        return;
    var timeZoneConverter = LiveTime.TimeZoneConverter;
}

<div class="historical-playback-sub-header">
    <div class="historical-playback-sub-header-content">
        <div class="flex-x self-center">
            <ButtonRound Title="Backward" Click="@OnBackward" Class="transparent hover-primary-icon">
                <i class="icon-rewind-left-fill text-2xl"></i>
            </ButtonRound>
            @if (m.IsPaused) {
                <ButtonRound Title="Play" Click="@OnResume" Class="transparent primary-icon">
                    <i class="icon-play-fill text-2xl"></i>
                </ButtonRound>
            } else {
                <ButtonRound Title="Pause" Click="@OnPause" Class="transparent hover-primary-icon">
                    <i class="icon-pause-fill text-2xl"></i>
                </ButtonRound>
                <ButtonRound Title="Stop" Click="@OnStop" Class="transparent primary-icon">
                    <i class="icon-Stop-fill text-2xl"></i>
                </ButtonRound>
            }
            <ButtonRound Title="Fast-forward" Click="@OnFastForward" Class="transparent hover-primary-icon">
                <i class="icon-rewind-right-fill text-2xl"></i>
            </ButtonRound>
        </div>

        @* Position *@
        @* Replace position with playing chat title *@
        <div class="flex-1 flex-x justify-center">
            <div class="flex-y">
                @if (m.DisplayChatTitle) {
                    <div class="c-text">@m.Title</div>
                }
                <div class="c-text">
                    @if (m.PlayingAt is { } playingAt) {
                        var localTime = timeZoneConverter.ToLocalTime(playingAt);
                        var absoluteTime = $"{localTime.ToLongDateString()} at {localTime.ToShortTimeString()}";
                        var relativeTime = LiveTime.GetDeltaText(playingAt, Clocks.SystemClock.Now);
                        <span>
                            Playing audio recorded
                            <span class="c-moment" title="@absoluteTime">@relativeTime</span>
                        </span>
                    }
                </div>
            </div>
        </div>

        <div class="flex-x self-center">
            @* Speed Selector *@
            <ButtonRound Title="Close" Click="OnStop" Class="transparent hover-primary-icon">
                <i class="icon-close-fill text-2xl"></i>
            </ButtonRound>
        </div>
    </div>
</div>

@code {
    [Inject] private ChatPlayers ChatPlayers { get; init; } = null!;
    [Inject] private IActivePlaybackInfo ActivePlaybackInfo { get; init; } = null!;
    [Inject] private ILiveTime LiveTime { get; init; } = null!;
    [Inject] private MomentClockSet Clocks { get; init; } = null!;
    [Inject] private IChats Chats { get; init; } = null!;
    [Inject] private Session Session { get; init; } = null!;

    [CascadingParameter] public Chat ChatViewChat { get; set; } = null!;

    protected override async Task OnInitializedAsync()
        => await LiveTime.WhenInitialized.ConfigureAwait(false);

    protected override ComputedState<Model>.Options GetStateOptions()
        => new() {
            UpdateDelayer = UpdateDelayer.ZeroDelay,
            InitialValue = Model.NotPlaying,
        };

    protected override async Task<Model> ComputeState(CancellationToken cancellationToken) {
        var chatId = await ChatPlayers.HistoricalPlaybackChatId.Use(cancellationToken).ConfigureAwait(false);
        if (chatId.IsEmpty)
            return Model.NotPlaying;
        var chat = await Chats.Get(Session, chatId, cancellationToken).ConfigureAwait(false);
        var chatTitle = chat?.Title ?? "";
        var player = await ChatPlayers.Get(chatId, ChatPlayerKind.Historical, cancellationToken).ConfigureAwait(false);
        var historicalChatPlayer = player as HistoricalChatPlayer;
        var playback = historicalChatPlayer?.Playback;
        if (playback == null) {
            // There is no playback. This may happen if playback is not started yet or is being restarting.
            // Keep previous state.
            return State.ValueOrDefault ?? Model.NotPlaying;
        }
        var isPaused = await playback.IsPaused.Use(cancellationToken).ConfigureAwait(false);
        var playbackStates = await playback.PlayingTracks.Use(cancellationToken).ConfigureAwait(false);
        Moment? playingAt = null;
        foreach (var playbackState in playbackStates) {
            var actualPlaybackState = await ActivePlaybackInfo.GetTrackPlaybackState(playbackState.TrackInfo.TrackId, cancellationToken);
            if (actualPlaybackState == null)
                continue;
            var trackInfo = playbackState.TrackInfo;

            playingAt ??= trackInfo.RecordedAt + actualPlaybackState.PlayingAt;
        }
        if (!playingAt.HasValue && State.ValueOrDefault != null) {
            // Try to keep last state to avoid blinks
            var m = State.LatestNonErrorValue;
            if (m.ChatId == chatId &&
                m.ChatPlayer == historicalChatPlayer &&
                m.Title == chatTitle &&
                m.IsPaused == isPaused)
                return m;
        }

        return new Model {
            ChatId = chatId,
            PlayingAt = playingAt,
            ChatPlayer = historicalChatPlayer,
            IsPaused = isPaused,
            Title = chatTitle,
            DisplayChatTitle = chatId != ChatViewChat.Id
        };
    }

    private Task OnStop() {
        ChatPlayers.StopPlayback();
        return Task.CompletedTask;
    }

    private void OnResume() {
        var m = State.LatestNonErrorValue;
        if (m.ChatPlayer == null)
            return;
        _ = m.ChatPlayer.Playback.Resume(default);
    }

    private void OnPause() {
        var m = State.LatestNonErrorValue;
        if (m.ChatPlayer == null)
            return;
        _ = m.ChatPlayer.Playback.Pause(default);
    }

    private void OnFastForward()
        => _ = PlayAt(TimeSpan.FromSeconds(15));

    private void OnBackward()
        => _ = PlayAt(TimeSpan.FromSeconds(-15));

    private async Task PlayAt(TimeSpan shift, CancellationToken cancellationToken = default)
    {
        var m = State.LatestNonErrorValue;
        var moment = m.PlayingAt;
        if (!moment.HasValue || m.ChatPlayer == null)
            return;
        var newMoment = await m.ChatPlayer.GetRewindMoment(moment.Value, shift, cancellationToken).ConfigureAwait(false);
        if (!newMoment.HasValue)
            return;
        ChatPlayers.StartHistoricalPlayback(m.ChatId, newMoment.Value);
    }

    public sealed record Model
    {
        public static Model NotPlaying { get; } = new();

        public DateTime? PlayingAt { get; init; }
        public bool IsPaused { get; init; }
        public HistoricalChatPlayer? ChatPlayer { get; init; }
        public string Title { get; init; } = "";
        public Symbol ChatId { get; init; }
        public bool DisplayChatTitle { get; init; }
    }
}
