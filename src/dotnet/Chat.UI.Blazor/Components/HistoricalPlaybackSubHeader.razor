@inherits ComputedStateComponent<HistoricalPlaybackSubHeader.Model>
@namespace ActualChat.Chat.UI.Blazor.Components
@using ActualChat.Chat.UI.Blazor.Services
@using ActualChat.MediaPlayback
@{
    var m = State.ValueOrDefault ?? Model.NotPlaying;
    if (m == Model.NotPlaying)
        return;
    var timeZoneConverter = LiveTime.TimeZoneConverter;
}

<div class="historical-playback-sub-header">
    <div class="historical-playback-sub-header-content">
        <div class="flex-x self-center">
            <ButtonRound Title="Backward" Click="@OnBackward">
                <i class="icon-rewind-left-fill text-xl"></i>
            </ButtonRound>
            @if (m.IsPaused) {
                <ButtonRound Title="Play" Click="@OnPlay">
                    <i class="icon-play-fill text-xl"></i>
                </ButtonRound>
            } else {
                <ButtonRound Title="Pause" Click="@OnPause">
                    <i class="icon-pause-fill text-xl"></i>
                </ButtonRound>
            }
            <ButtonRound Title="Stop" Click="@OnStop">
                <i class="icon-Stop-fill text-xl"></i>
            </ButtonRound>
            <ButtonRound Title="Fast-forward" Click="@OnFastForward">
                <i class="icon-rewind-right-fill text-xl"></i>
            </ButtonRound>
        </div>

        @* Position *@
        @* Replace position with playing chat title *@
        <div class="flex-1 flex-x justify-center">
            <div class="c-text">
                @if (m.PlayingAt is { } playingAt) {
                    var localTime = timeZoneConverter.ToLocalTime(playingAt);
                    var absoluteTime = $"{localTime.ToLongDateString()} at {localTime.ToShortTimeString()}";
                    var relativeTime = LiveTime.GetDeltaText(playingAt, Clocks.SystemClock.Now);
                    <span>
                        Playing audio recorded
                        <span class="c-moment" title="@absoluteTime">@relativeTime</span>
                    </span>
                }
            </div>
        </div>

        <div class="flex-x self-center">
            @* Speed Selector *@
            <ButtonRound Title="Close" Click="OnStop">
                <i class="icon-close-fill text-xl"></i>
            </ButtonRound>
        </div>
    </div>
</div>

@code {
    [Inject] private ChatPlayers ChatPlayers { get; init; } = null!;
    [Inject] private IActivePlaybackInfo ActivePlaybackInfo { get; init; } = null!;
    [Inject] private ILiveTime LiveTime { get; init; } = null!;
    [Inject] private MomentClockSet Clocks { get; init; } = null!;

    [CascadingParameter] public Chat Chat { get; set; } = null!;

    protected override async Task OnInitializedAsync()
        => await LiveTime.WhenInitialized.ConfigureAwait(false);

    protected override ComputedState<Model>.Options GetStateOptions()
        => new() {
            UpdateDelayer = UpdateDelayer.ZeroDelay,
            InitialValue = Model.NotPlaying,
        };

    protected override async Task<Model> ComputeState(CancellationToken cancellationToken) {
        var player = await ChatPlayers.Get(Chat.Id, ChatPlayerKind.Historical, cancellationToken).ConfigureAwait(false);
        if (player is not HistoricalChatPlayer historicalChatPlayer)
            return Model.NotPlaying;

        var playback = player.Playback;
        var isPlaying = await playback.IsPlaying.Use(cancellationToken).ConfigureAwait(false);
        if (!isPlaying) {
            // If the player still has playing task but playback is not playing,
            // apparently it is awaiting next track is fetched.
            // So it make sense to keep header status for a while.
            if (player.WhenPlaying != null && State.LatestNonErrorValue.PlayingAt.HasValue) {
                // Invalidate to force recompute to check if the player is really stopped or not.
                Computed.GetCurrent()!.Invalidate(TimeSpan.FromMilliseconds(100));
                return State.LatestNonErrorValue;
            }
            return Model.NotPlaying;
        }

        var playbackStates = await playback.PlayingTracks.Use(cancellationToken).ConfigureAwait(false);
        Moment? playingAt = null;
        foreach (var playbackState in playbackStates) {
            var actualPlaybackState = await ActivePlaybackInfo.GetTrackPlaybackState(playbackState.TrackInfo.TrackId, cancellationToken);
            if (actualPlaybackState == null)
                continue;
            var trackInfo = playbackState.TrackInfo;

            playingAt ??= trackInfo.RecordedAt + actualPlaybackState.PlayingAt;
        }

        return new Model {
            PlayingAt = playingAt,
            ChatPlayer = historicalChatPlayer
        };
    }

    private Task OnStop() {
        ChatPlayers.StopPlayback();
        return Task.CompletedTask;
    }

    private void OnPlay() {
    }

    private void OnPause() {

    }

    private void OnFastForward()
        => _ = PlayAt(TimeSpan.FromSeconds(15));

    private void OnBackward()
        => _ = PlayAt(TimeSpan.FromSeconds(-15));

    private async Task PlayAt(TimeSpan shift, CancellationToken cancellationToken = default)
    {
        var m = State.LatestNonErrorValue;
        var moment = m.PlayingAt;
        if (!moment.HasValue || m.ChatPlayer == null)
            return;
        var newMoment = await m.ChatPlayer.GetRewindMoment(moment.Value, shift, cancellationToken).ConfigureAwait(false);
        if (!newMoment.HasValue)
            return;
        ChatPlayers.StartHistoricalPlayback(Chat.Id, newMoment.Value);
    }

    public sealed record Model
    {
        public static Model NotPlaying { get; } = new();

        public DateTime? PlayingAt { get; init; }

        public bool IsPaused { get; init; }

        public HistoricalChatPlayer? ChatPlayer { get; init; }
    }
}
