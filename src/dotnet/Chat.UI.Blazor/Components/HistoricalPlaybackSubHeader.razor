@inherits ComputedStateComponent<HistoricalPlaybackSubHeader.Model>
@namespace ActualChat.Chat.UI.Blazor.Components
@using ActualChat.Chat.UI.Blazor.Services
@using ActualChat.MediaPlayback
@using Timer = System.Timers.Timer;
@using System.Timers

@{
    var m = State.ValueOrDefault ?? Model.NotPlaying;
    if (m == Model.NotPlaying)
        return;
}

<div class="historical-playback-sub-header">
    <div class="historical-playback-sub-header-content relative">
        <div class="flex-x self-center">
            <ButtonRound Title="Backward" Click="@OnBackward" Class="transparent hover-primary-icon mobile-hidden">
                <i class="icon-rewind-left-fill text-2xl"></i>
            </ButtonRound>
            @if (m.IsPaused) {
                <ButtonRound Title="Play" Click="@OnResume" Class="transparent primary-icon">
                    <i class="icon-play-fill text-2xl"></i>
                </ButtonRound>
            } else {
                <ButtonRound Title="Pause" Click="@OnPause" Class="transparent hover-primary-icon">
                    <i class="icon-pause-fill text-2xl"></i>
                </ButtonRound>
                <ButtonRound Title="Stop" Click="@OnStop" Class="transparent primary-icon mobile-hidden">
                    <i class="icon-Stop-fill text-2xl"></i>
                </ButtonRound>
            }
            <ButtonRound Title="Fast-forward" Click="@OnFastForward" Class="transparent hover-primary-icon mobile-hidden">
                <i class="icon-rewind-right-fill text-2xl"></i>
            </ButtonRound>
        </div>

        <div class="flex-1"></div>

        @* Position *@
        @* Replace position with playing chat title *@
        <div class="absolute left-52 flex-x items-center ">
            <ChatAuthorCirclesGroup
                Class="historical-playback-active-authors-panel mobile-hidden"
                MaxIconCount="4"
                Size="SquareSize.Size6"
                AuthorIds="@m.AuthorIds" />
            <div class="flex-y">
                @if (m.DisplayChatTitle) {
                    <div class="c-text">
                        <a href="@Links.ChatPage(m.ChatId)" class="cursor-pointer hover:underline">@m.Title</a>
                    </div>
                }
                <div class="c-text mobile-hidden">
                    @if (m.PlayingAt is { } playingAt) {
                        var localTime = TimeZoneConverter.ToLocalTime(playingAt);
                        var absoluteTime = $"{localTime.ToLongDateString()} at {localTime.ToShortTimeString()}";
                        var relativeTime = LiveTime.GetDeltaText(playingAt, Clocks.SystemClock.Now);
                        <span>
                            Playing audio recorded
                            <span class="c-moment" title="@absoluteTime">@relativeTime</span>
                        </span>
                    }
                </div>
            </div>
        </div>

        <div class="flex-x self-center self-end">
            @* Speed Selector *@
            <ButtonRound Title="Close" Click="OnStop" Class="transparent hover-primary-icon">
                <i class="icon-close-fill text-2xl"></i>
            </ButtonRound>
        </div>
    </div>
</div>

@code {
    private RewindController? _rewindController;

    [Inject] private ChatPlayers ChatPlayers { get; init; } = null!;
    [Inject] private IActivePlaybackInfo ActivePlaybackInfo { get; init; } = null!;
    [Inject] private TimeZoneConverter TimeZoneConverter { get; init; } = null!;
    [Inject] private ILiveTime LiveTime { get; init; } = null!;
    [Inject] private MomentClockSet Clocks { get; init; } = null!;
    [Inject] private IChats Chats { get; init; } = null!;
    [Inject] private Session Session { get; init; } = null!;

    [CascadingParameter] public Chat ChatViewChat { get; set; } = null!;

    protected override ComputedState<Model>.Options GetStateOptions()
        => new() {
            UpdateDelayer = UpdateDelayer.Instant,
            InitialValue = Model.NotPlaying,
        };

    protected override async Task<Model> ComputeState(CancellationToken cancellationToken) {
        var chatId = await ChatPlayers.HistoricalPlaybackChatId.Use(cancellationToken).ConfigureAwait(false);
        if (chatId.IsEmpty)
            return Model.NotPlaying;
        var chat = await Chats.Get(Session, chatId, cancellationToken).ConfigureAwait(false);
        var chatTitle = chat?.Title ?? "";
        var player = await ChatPlayers.Get(chatId, ChatPlayerKind.Historical, cancellationToken).ConfigureAwait(false);
        var historicalChatPlayer = player as HistoricalChatPlayer;
        var playback = historicalChatPlayer?.Playback;
        if (playback == null) {
            // There is no playback. This may happen if playback is not started yet or is being restarting.
            // Keep previous state.
            return State.ValueOrDefault ?? Model.NotPlaying;
        }
        var isPaused = await playback.IsPaused.Use(cancellationToken).ConfigureAwait(false);
        var playbackStates = await playback.PlayingTracks.Use(cancellationToken).ConfigureAwait(false);
        var authorIds = ImmutableArray<Symbol>.Empty;
        Moment? playingAt = null;
        foreach (var playbackState in playbackStates) {
            var trackInfo = playbackState.TrackInfo;
            var chatAudioTrackInfo = trackInfo as ChatAudioTrackInfo;
            if (chatAudioTrackInfo != null) {
                var authorId = chatAudioTrackInfo.AudioEntry.AuthorId;
                if (!authorIds.Contains(authorId))
                    authorIds = authorIds.Add(authorId);
            }
            var actualPlaybackState = await ActivePlaybackInfo.GetTrackPlaybackState(trackInfo.TrackId, cancellationToken);
            if (actualPlaybackState == null)
                continue;
            playingAt ??= trackInfo.RecordedAt + actualPlaybackState.PlayingAt;
        }
        if (!playingAt.HasValue && State.ValueOrDefault != null) {
            // Try to keep last state to avoid blinks
            var m = State.LatestNonErrorValue;
            if (m.ChatId == chatId &&
                m.ChatPlayer == historicalChatPlayer &&
                m.Title == chatTitle &&
                m.IsPaused == isPaused)
                return m;
        }

        return new Model {
            ChatId = chatId,
            PlayingAt = playingAt,
            ChatPlayer = historicalChatPlayer,
            IsPaused = isPaused,
            Title = chatTitle,
            DisplayChatTitle = chatId != ChatViewChat.Id,
            AuthorIds = authorIds
        };
    }

    private Task OnStop() {
        ChatPlayers.StopPlayback();
        return Task.CompletedTask;
    }

    private void OnResume() {
        var m = State.LatestNonErrorValue;
        if (m.ChatPlayer == null)
            return;
        _ = m.ChatPlayer.Playback.Resume(default);
    }

    private void OnPause() {
        var m = State.LatestNonErrorValue;
        if (m.ChatPlayer == null)
            return;
        _ = m.ChatPlayer.Playback.Pause(default);
    }

    private void OnFastForward()
        => Rewind(TimeSpan.FromSeconds(15));

    private void OnBackward()
        => Rewind(TimeSpan.FromSeconds(-15));

    private void Rewind(TimeSpan shift) {
        _rewindController ??= new RewindController(OnRewindRequested);
        var m = State.LatestNonErrorValue;
        var moment = m.PlayingAt;
        if (!moment.HasValue || m.ChatPlayer == null)
            return;
        _rewindController.Rewind(m.ChatId, moment.Value, shift);
    }

    private void OnRewindRequested(Symbol chatId, DateTime momentFrom, TimeSpan shift) {
        _ = InvokeAsync(() => {
            var m = State.LatestNonErrorValue;
            if (m.ChatPlayer != null && m.ChatPlayer.ChatId == chatId)
                _ = PlayAt(m.ChatPlayer, momentFrom, shift);
        });
    }

    private async Task PlayAt(HistoricalChatPlayer chatPlayer, DateTime from, TimeSpan shift, CancellationToken cancellationToken = default)
    {
        var newMoment = await chatPlayer.GetRewindMoment(from, shift, cancellationToken).ConfigureAwait(false);
        if (!newMoment.HasValue)
            return;
        ChatPlayers.StartHistoricalPlayback(chatPlayer.ChatId, newMoment.Value);
    }

    public sealed record Model
    {
        public static Model NotPlaying { get; } = new();

        public DateTime? PlayingAt { get; init; }
        public bool IsPaused { get; init; }
        public HistoricalChatPlayer? ChatPlayer { get; init; }
        public string Title { get; init; } = "";
        public Symbol ChatId { get; init; }
        public bool DisplayChatTitle { get; init; }
        public ImmutableArray<Symbol> AuthorIds { get; init; }
    }

    internal class RewindController
    {
        private Timer _rewindTimer;
        private Symbol _chatId;
        private DateTime _rewindFrom;
        private TimeSpan _rewindSpan;

        public RewindController(Action<Symbol, DateTime, TimeSpan> onRewindRequested)
        {
            _rewindTimer = new Timer(300) { AutoReset = false };
            _rewindTimer.Elapsed += (s,e) => onRewindRequested(_chatId, _rewindFrom, _rewindSpan);
        }

        public void Rewind(Symbol chatId, DateTime moment, TimeSpan shift)
        {
            if (!_rewindTimer.Enabled) {
                _chatId = chatId;
                _rewindFrom = moment;
                _rewindSpan = shift;
                _rewindTimer.Start();
            } else {
                _rewindTimer.Stop();
                _rewindSpan += shift;
                if (_chatId == chatId)
                    _rewindTimer.Start();
            }
        }
    }
}
