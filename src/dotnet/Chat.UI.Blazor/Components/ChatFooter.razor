@using ActualChat.Chat.UI.Blazor.Pages
@inherits ComputedStateComponent<ChatFooter.Model>
@{
    var m = State.Value;
    var chat = m.Chat;
}

<div class="writable-chat-footer">
    @if (ReferenceEquals(chat, SpecialChat.Loading)) {
        // Render skeletons until State is computed
        <chat-view-footer-skeleton/>
    } else if (chat.Id.IsNone) {
        <ReadOnlyChatFooter FooterText="@string.Empty" />
    } else {
        @if (m.CanPost) {
            <ChatMessageEditor @key="@chat.Id.Value" Chat="@chat" />
        } else if (m.CanJoin) {
            <div class="chat-footer">
                @if (!m.IsGuest) {
                    <div>
                        <span class="inline-flex">To post or talk,</span>
                        <Button Click="@(() => OnJoin(m.Chat.Id))" Class="btn-sm btn-primary">Join this chat</Button>
                    </div>
                } else {
                    <div class="signin-footer">
                        <div class="inline-flex">
                            <SignInMenu ButtonClass="w-full"/>
                        </div>
                        @if (!m.OtherUserId.IsNone) {
                            <span class="inline-flex mx-2 mr-1 items-center">to chat with</span>
                            <AccountName UserSid="@m.OtherUserId.Id"/>
                        } else if (m.CanJoinWithGuestAccount) {
                            <span class="inline-flex mx-2 items-center">or</span>
                            <Button Click="@(() => OnJoin(m.Chat.Id))" Class="inline-flex btn-outline">Join anonymously</Button>
                        } else {
                            <span class="inline-flex ml-2 items-center">to join this chat</span>
                        }
                    </div>
                }
            </div>
        } else {
            <ReadOnlyChatFooter/>
        }
    }
</div>

@code {
    [Inject] private Session Session { get; init; } = null!;
    [Inject] private IAccounts Accounts { get; init; } = null!;
    [Inject] private IAvatars Avatars { get; init; } = null!;
    [Inject] private IChats Chats { get; init; } = null!;
    [Inject] private ChatUI ChatUI { get; init; } = null!;
    [Inject] private ModalUI ModalUI { get; init; } = null!;
    [Inject] private UICommander UICommander { get; init; } = null!;
    [Inject] private NavigationManager Nav { get; init; } = null!;

    public ChatFooter() {
        Options = ComputedStateComponentOptions.RecomputeOnParametersSet; // Intended
    }

    protected override ComputedState<Model>.Options GetStateOptions() {
        return new() {
            InitialValue = Model.Loading,
            Category = GetStateCategory(),
        };
    }

    protected override async Task<Model> ComputeState(CancellationToken cancellationToken) {
        // This method is !non-synchronized, so it can't use any parameters, etc.
        // You should use .ConfigureAwait(false) here.

        var chatId = await ChatUI.SelectedChatId.Use(cancellationToken).ConfigureAwait(false);
        if (chatId.IsNone)
            return Model.NoChatSelected;

        var chat = await Chats.Get(Session, chatId, cancellationToken).ConfigureAwait(false);
        if (chat == null)
            return Model.Unavailable;

        var account = await Accounts.GetOwn(Session, cancellationToken).ConfigureAwait(false);
        var otherUserId = chatId.IsPeerChat(out var peerChatId)
            ? peerChatId.UserIds.OtherThan(account.Id)
            : default;
        var canPost = chat.Rules.CanWrite();
        var canJoin = !canPost && chat.Rules.CanJoin();
        var hasMultipleAvatars = false;
        var canJoinWithGuestAccount = false;
        var canJoinAnonymously = false;
        if (canJoin) {
            if (account.IsGuestOrNone) {
                canJoinWithGuestAccount = chat.AllowGuestAuthors;
            } else {
                canJoinAnonymously = chat.AllowAnonymousAuthors;
                var avatars = await Avatars.ListOwnAvatarIds(Session, cancellationToken).ConfigureAwait(false);
                hasMultipleAvatars = avatars.Length > 1 || canJoinAnonymously;
            }
        }

        return new() {
            Chat = chat,
            OtherUserId = otherUserId,
            IsGuest = account.IsGuestOrNone,
            CanPost = canPost,
            CanJoin = canJoin,
            HasMultipleAvatars = hasMultipleAvatars,
            CanJoinWithGuestAccount = canJoinWithGuestAccount,
            CanJoinAnonymously = canJoinAnonymously,
        };
    }

    private async Task OnJoin(ChatId chatId) {
        var m = State.Value;
        if (!m.HasMultipleAvatars) {
            var command = new IAuthors.JoinCommand(Session, chatId);
            await UICommander.Run(command);
            return;
        }

        await ModalUI.Show(new AvatarSelectModal.Model(ChatId.None, m.CanJoinAnonymously, JoinWithAvatar));

        async Task JoinWithAvatar(AvatarFull avatar) {
            var command = new IAuthors.JoinCommand(Session, chatId, avatar.Id, JoinAnonymously: avatar.IsAnonymous);
            await UICommander.Run(command);
        }
    }

    public sealed class Model {
        public static Model Loading { get; } = new() { Chat = SpecialChat.Loading };
        public static Model Unavailable { get; } = new() { Chat = SpecialChat.Unavailable };
        public static Model NoChatSelected { get; } = new() { Chat = SpecialChat.NoChatSelected };

        public Chat Chat { get; init; } = null!;
        public UserId OtherUserId { get; init; }
        public bool IsGuest { get; init; }
        public bool CanPost { get; init; }
        public bool CanJoin { get; init; }
        public bool HasMultipleAvatars { get; init; }
        public bool CanJoinWithGuestAccount { get; init; }
        public bool CanJoinAnonymously { get; init; }
    }
}
