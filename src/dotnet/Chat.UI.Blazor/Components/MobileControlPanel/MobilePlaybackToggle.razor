@namespace ActualChat.Chat.UI.Blazor.Components
@inherits ComputedStateComponent<SingleChatPlaybackState>
@{
    var m = State.LatestNonErrorValue;
    if (m.ChatId.IsEmpty)
        return; // Not computed yet

    var playingHistoricalClass = m.IsPlayingHistorical ? "opacity-60" : "";
    var cls = $"{(m.IsListening ? "on" : "off")} {playingHistoricalClass}";
    var lastRenderedState = _lastRenderedState ?? m;
    var isListeningChange = (lastRenderedState.IsListening, m.IsListening);
    var wrapperCls = isListeningChange switch {
        (false, true) => "listen-off-to-on",
        (true, false) => "listen-on-to-off",
        (_, false) => "listen-off",
        (_, true) => "listen-on",
    };
    _lastRenderedState = m;
}

<div class="@wrapperCls playback-wrapper mobile-button">
    <ButtonRound Click="@OnListenClick" Class="@cls">
        <i class="icon-listen text-2xl"></i>
    </ButtonRound>
    <ButtonRound Click="@OnListenClick" Class="loud-btn">
        <i class="icon-volume-up text-2xl"></i>
    </ButtonRound>
</div>

@code {
    private SingleChatPlaybackState? _lastRenderedState;

    [Inject] private ChatPlayers ChatPlayers { get; init; } = null!;
    [Inject] private ChatUI ChatUI { get; init; } = null!;

    [Parameter, EditorRequired] public string ChatId { get; set; } = "";

    private void OnListenClick()
        => _ = ChatUI.SetListeningState(ChatId, !State.LatestNonErrorValue.IsListening);

    protected override ComputedState<SingleChatPlaybackState>.Options GetStateOptions()
        => new() {
            InitialValue = SingleChatPlaybackState.None,
            UpdateDelayer = FixedDelayer.Instant,
        };

    protected override Task<SingleChatPlaybackState> ComputeState(CancellationToken cancellationToken)
        => ChatUI.GetSingleChatPlaybackState(ChatId, cancellationToken);
}
