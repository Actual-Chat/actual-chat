@using Stl.Extensibility
@using ActualChat.MediaPlayback
@inherits ComputedMarkupViewBase<PlayableTextMarkup, PlayableTextMarkupView.Model>
@attribute [MatchFor(typeof(PlayableTextMarkup), typeof(IMarkupView))]
@{
    var m = State.LatestNonErrorValue;
}
<span class="playable-text-markup whitespace-break-spaces">
    @for (var i = 0; i < Markup.Words.Length; i++) {
        var word = Markup.Words[i];
        var status = m.Map != null ? m.Map[i] : WordPlayback.None;
        var cls = GetPlayingClass(status);
        <span class="@cls" @onclick="_ => OnClick(word.TextRange.Start)">@word.Value</span>
    }
</span>

@code {
    private ILogger? _log;
    private ILogger Log => _log ??= Services.LogFor(GetType());

    [Inject] private IActivePlaybackInfo ActivePlaybackInfo { get; init; } = null!;

    private async Task OnClick(int startIndex) {
        // Let's store everything locally to make sure we can safely "leave" Blazor dispatcher's "thread"
        var markup = Markup;
        var entry = Entry;
        var chatId = entry.ChatId;
        var audioEntryId = entry.AudioEntryId.GetValueOrDefault(); // It's there for sure, otherwise click won't work

        var startTimeOpt = markup.TextToTimeMap.TryMap(startIndex);
        if (startTimeOpt is not { } startTime)
            return;

        var session = Services.GetRequiredService<Session>();
        var chats = Services.GetRequiredService<IChats>();
        var chatEntryReader = chats.NewEntryReader(session, chatId, ChatEntryType.Audio);
        var audioEntry = await chatEntryReader.Get(audioEntryId, default).ConfigureAwait(false);
        if (audioEntry == null) {
            Log.LogWarning("Can't play: audio entry with Id = {Id} doesn't exist", audioEntryId);
            return; // We can't do much in this case
        }

        var startAt = audioEntry.BeginsAt + TimeSpan.FromSeconds(startTime - 0.25);
        var chatPlayers = Services.GetRequiredService<ChatPlayers>();
        chatPlayers.StartHistoricalPlayback(chatId, startAt);
    }

    protected override ComputedState<Model>.Options GetStateOptions()
        => new() { InitialValue = Model.None };

    protected override async Task<Model> ComputeState(CancellationToken cancellationToken) {
        // Let's store everything locally to make sure we can safely "leave" Blazor dispatcher's "thread"
        var audioEntryId = Entry.AudioEntryId;
        if (audioEntryId == null)
            return Model.None;

        var timeRange = Markup.TimeRange;
        if (timeRange.IsEmpty)
            return Model.None;

        var trackId = ChatAudioTrackInfo.ComposeTrackId(Entry.ChatId, audioEntryId.GetValueOrDefault());
        if (await ActivePlaybackInfo.GetTrackInfo(trackId, cancellationToken).ConfigureAwait(false) is not ChatAudioTrackInfo trackInfo)
            return Model.None;

        var playbackState = await ActivePlaybackInfo.GetTrackPlaybackState(trackId, cancellationToken).ConfigureAwait(false);
        if (playbackState == null || playbackState.IsCompleted)
            return Model.None;

        var playingAt = (float)(trackInfo.RecordedAt + playbackState.PlayingAt - trackInfo.AudioEntry.BeginsAt).TotalSeconds;
        var playingAtNearbyRange = new Range<float>(playingAt - 2f, playingAt + 2f);
        if (!playingAtNearbyRange.Overlaps(timeRange))
            return Model.None;

        var map = new WordPlayback[Markup.Words.Length];
        for (var i = 0; i < Markup.Words.Length; i++) {
            var word = Markup.Words[i];
            var isWordPlaying = word.TimeRange.Move(-0.5f, 0.3f).Contains(playingAt);
            map[i] = isWordPlaying ? WordPlayback.Playing : WordPlayback.None;
        }

        for (var i = 0; i < Markup.Words.Length; i++) {
            var prev = i > 0 ? map[i - 1] : WordPlayback.None;
            var current = map[i];
            var next = i < map.Length - 1 ? map[i + 1] : WordPlayback.None;
            var actual = current;
            if (current == WordPlayback.Playing) {
                if (prev == WordPlayback.None)
                    actual |= WordPlayback.PlayingStart;
                if (next == WordPlayback.None)
                    actual |= WordPlayback.PlayingEnd;
            }
            map[i] = actual;
        }

        return new Model { Map = map };
    }

    private string GetPlayingClass(WordPlayback status) {
        if (status == WordPlayback.None)
            return "";
        if (status.HasFlag(WordPlayback.Playing)) {
            var cls = "playing-blue";
            var start = status.HasFlag(WordPlayback.PlayingStart);
            var end = status.HasFlag(WordPlayback.PlayingEnd);
            if (start && end)
                cls += " playing-start-end";
            else if (start)
                cls += " playing-start";
            else if (end)
                cls += " playing-end";
            return cls;
        }
        return "";
    }

    [Flags] public enum WordPlayback {
        None = 0x00,
        Playing = 0x10,
        PlayingStart = 0x11,
        PlayingEnd = 0x12,
    }

    public record Model {
        public static readonly Model None = new Model();

        public WordPlayback[]? Map { get; init; }
    }
}
