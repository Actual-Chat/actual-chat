@namespace ActualChat.Chat.UI.Blazor.Components
@using ActualChat.Chat.UI.Blazor.Module
@using ActualChat.UI.Blazor.Events
@inherits ComputedStateComponent<AuthorList.Model>
@{
    var m = State.Value;
}

<div class="flex flex-col h-full px-5 py-3 people-tab">
    <div class="flex-auto flex-y gap-y-1">
        <div class="text-caption-1 text-02">Active — @m.OnlineAuthorIds.Length</div>
        @foreach (var authorId in m.OnlineAuthorIds) {
            @if (authorId == _ownAuthor?.Id) {
                <AuthorBadge
                    @key="@authorId"
                    AuthorSid="@authorId"
                    ShowPresence="true"
                    NameClass="font-medium text-02"
                    Click="OnSelfClick"/>
            } else {
                <AuthorBadge
                    @key="@authorId"
                    AuthorSid="@authorId"
                    ShowPresence="true"
                    NameClass="font-medium text-02"
                    Click="@(_ => AuthorUI.Show(authorId))"/>
            }
        }
        <div class="text-caption-1 text-02">Offline — @m.OfflineAuthorIds.Length</div>
        @foreach (var authorId in m.OfflineAuthorIds) {
            <AuthorBadge
                @key="@authorId"
                AuthorSid="@authorId"
                ShowPresence="true"
                NameClass="font-medium text-02"
                Click="@(_ => AuthorUI.Show(authorId))"/>
        }
    </div>
</div>

@code {
    [Inject] private IAuthors Authors { get; init; } = null!;
    [Inject] private Session Session { get; init; } = null!;
    [Inject] private AuthorUI AuthorUI { get; init; } = null!;
    [Inject] private UIEventHub UIEventHub { get; init; } = null!;

    [CascadingParameter] public Chat Chat { get; set; } = null!;

    private AuthorFull? _ownAuthor;

    protected override ComputedState<Model>.Options GetStateOptions()
        => new() {
            InitialValue = Model.None,
            Category = GetStateCategory(),
        };

    protected override async Task<Model> ComputeState(CancellationToken cancellationToken) {
        var allAuthorIds = await Authors.ListAuthorIds(Session, Chat.Id, cancellationToken);
        _ownAuthor = await Authors.GetOwn(Session, Chat.Id, cancellationToken);
        var onlineAuthorIds = new List<AuthorId>();
        var offlineAuthorIds = new List<AuthorId>();
        var presences = await allAuthorIds
            .Select(async authorId => {
                var presence = await Authors.GetPresence(Session, Chat.Id, authorId, cancellationToken).ConfigureAwait(false);
                return (authorId, presence);
            })
            .Collect(); // Add concurrency
        foreach (var (authorId, presence) in presences) {
            if (presence is Presence.Online or Presence.Recording) {
                onlineAuthorIds.Add(authorId);
            } else {
                offlineAuthorIds.Add(authorId);
            }
        }

        return new() {
            OnlineAuthorIds = onlineAuthorIds.ToImmutableArray(),
            OfflineAuthorIds = offlineAuthorIds.ToImmutableArray(),
        };
    }

    private Task OnAuthorClick(AuthorId authorId)
        => AuthorUI.Show(authorId);

    private void OnSelfClick()
        => _ = UIEventHub.Publish(new ShowSettingsEvent());

    public sealed class Model {
        public static Model None { get; } = new();
        public ImmutableArray<AuthorId> OnlineAuthorIds { get; init; } = ImmutableArray<AuthorId>.Empty;
        public ImmutableArray<AuthorId> OfflineAuthorIds { get; init; } = ImmutableArray<AuthorId>.Empty;
    }
}
