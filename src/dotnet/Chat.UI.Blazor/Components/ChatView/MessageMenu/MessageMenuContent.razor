@namespace ActualChat.Chat.UI.Blazor.Components
@using ActualChat.Chat.UI.Blazor.Events
@inherits ComputedStateComponent<MessageMenuContent.Model>
@{
    var m = State.Value;
    var entry = ChatMessageModel.Entry;
    var showPlayButton = ScreenSize.IsNarrow() && entry.AudioEntryId != null;
    var canEditOrDelete = m is { CanWrite: true, IsOwnEntry: true } && entry is { Kind: ChatEntryKind.Text, IsStreaming: false };
    var messageLink = Links.Chat(entry.Id).ToAbsolute(UrlMapper);
}

<div class="message-menu">
    <ReactionSelect Entry="@entry"/>
    @if (showPlayButton) {
        <MessageMenuPlay Entry="@entry" IsMenu="true"/>
    }
    @if (canEditOrDelete) {
        <MenuEntry
            Icon="icon-edit"
            Class="important-item"
            FocusOnEditor="true"
            Text="Edit"
            Click="@(() => Edit(entry))">
        </MenuEntry>
    }
    @if (m.CanWrite) {
        <MenuEntry
            Icon="icon-reply"
            FocusOnEditor="true"
            Text="Reply"
            Click="@(() => Reply(entry))">
        </MenuEntry>
    }
    @if (!ClickedLinkUrl.IsNullOrEmpty()) {
        <CopyTrigger Tooltip="" CopyText="@ClickedLinkUrl" Class="ac-menu-item !p-0">
            <MenuEntry
                Icon="icon-copy"
                Text="Copy link">
            </MenuEntry>
        </CopyTrigger>
    }
    <CopyTrigger Tooltip="" CopyText="@messageLink" Class="ac-menu-item !p-0">
        <MenuEntry
            Icon="icon-link-2"
            Text="Copy message link">
        </MenuEntry>
    </CopyTrigger>
    @if (canEditOrDelete) {
        <MenuEntrySeparator />
        <MenuEntry
            Class="warning-item"
            Icon="icon-trash03"
            Text="Delete message"
            Click="@(() => ChatUI.ShowDeleteMessageModal(new ChatMessageModel(entry)))">
        </MenuEntry>
    }
</div>

@code{
    [Inject] private Session Session { get; init; } = null!;
    [Inject] private IChats Chats { get; init; } = null!;
    [Inject] private IAuthors Authors { get; init; } = null!;
    [Inject] private ChatEditorUI ChatEditorUI { get; init; } = null!;
    [Inject] private ChatUI ChatUI { get; init; } = null!;
    [Inject] private ClipboardUI ClipboardUI { get; init; } = null!;
    [Inject] private FeedbackUI FeedbackUI { get; init; } = null!;
    [Inject] private UrlMapper UrlMapper { get; init; } = null!;

    [Parameter, EditorRequired] public ChatMessageModel ChatMessageModel { get; set; } = null!;
    [Parameter] public string? ClickedLinkUrl { get; set; }
    [CascadingParameter] public ScreenSize ScreenSize { get; set; }

    protected override ComputedState<Model>.Options GetStateOptions()
        => new() {
            InitialValue = Model.None,
            Category = GetStateCategory(),
        };

    protected override async Task<Model> ComputeState(CancellationToken cancellationToken)
    {
        var chatEntry = ChatMessageModel.Entry;
        var chatId = chatEntry.ChatId;
        var requestAuthor = await Authors.GetOwn(Session, chatId, CancellationToken.None);
        var rules = await Chats.GetRules(Session, chatId, cancellationToken).ConfigureAwait(false);
        // Default scheduler is used from here
        var canWrite = rules.CanWrite();

        return new Model {
            CanWrite = canWrite,
            IsOwnEntry = requestAuthor != null && requestAuthor.Id == chatEntry.AuthorId,
        };
    }

    private Task Reply(ChatEntry chatEntry)
        => ChatEditorUI.ShowRelatedEntry(RelatedEntryKind.Reply, chatEntry.Id, focusOnEditor: true);

    private Task Edit(ChatEntry chatEntry)
        => ChatEditorUI.Edit(chatEntry);

    public sealed record Model {
        public static readonly Model None = new();

        public bool IsOwnEntry { get; init; }
        public bool CanWrite { get; init; }
    }
}
