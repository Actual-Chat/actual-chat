@namespace ActualChat.Chat.UI.Blazor.Components
@using ActualChat.Transcription
@implements IAsyncDisposable
@{
    var diff = CalculateDiff(_lastTranscriptText, Transcript.Text);
    _lastTranscriptText = Transcript.Text;
}

<p class="@Class chat-message-transcript">
    @if (ShowEntryType) {
        <span class="chat-entry-type-marker icon-volume-up"></span>
    }@*
    *@<span class="retained">@diff.RetainedPart</span>@*
    *@<span class="changes">@diff.ChangedPart</span>
</p>

@code {
    private string _lastTranscriptText = "";

    [Inject] private ILogger<ChatMessageTranscript> Log { get; init; } = null!;
    [Inject] private ITranscriptStreamer TranscriptStreamer { get; init; } = null!;
    [Inject] private BlazorCircuitContext CircuitContext { get; init; } = null!;

    [Parameter] public string Class { get; set; } = "";
    [Parameter, EditorRequired, ParameterComparer(typeof(ByReferenceParameterComparer))]
    public ChatMessageModel Model { get; set; } = null!;
    [Parameter] public bool ShowEntryType { get; set; }

    private CancellationTokenSource? RestartCts { get; set; }
    private Transcript Transcript { get; set; } = new();

    public override Task SetParametersAsync(ParameterView parameters)
        => this.HasChangedParameters(parameters) ? base.SetParametersAsync(parameters) : Task.CompletedTask;

    public ValueTask DisposeAsync() {
        RestartCts?.CancelAndDisposeSilently();
        return ValueTask.CompletedTask;
    }

    protected override void OnParametersSet() {
        if (CircuitContext.IsPrerendering)
            return;

        RestartCts?.CancelAndDisposeSilently();
        RestartCts = new();
        var cancellationToken = RestartCts.Token;
        BackgroundTask.Run(
            () => ReadTranscript(Model, cancellationToken),
            Log, "ReadTranscript failed",
            cancellationToken);
    }

    private async Task ReadTranscript(ChatMessageModel model, CancellationToken cancellationToken) {
        try {
            var entry = model.Entry;
            var diffs = TranscriptStreamer.GetTranscriptDiffStream(entry.StreamId, cancellationToken);
            var circuitDispatcher = CircuitContext.Dispatcher;
            var transcripts = diffs.ApplyDiffs(cancellationToken);
            await foreach (var transcript in transcripts.ConfigureAwait(false)) {
                await circuitDispatcher.InvokeAsync(() => {
                    Transcript = transcript;
                    StateHasChanged();
                }).ConfigureAwait(false);
            }
        }
        catch (Exception e) {
            if (e.GetType().FullName != "Microsoft.AspNetCore.SignalR.HubException")
                throw;
            if (!e.Message.Contains(nameof(OperationCanceledException)))
                throw;
            // Not fully sure if it's the case, but it seems that sometimes SignalR
            // wraps OperationCanceledException into HubException, so here we suppress it.
        }
    }

    private Diff CalculateDiff(string prevTranscript, string newTranscript) {
        if (prevTranscript == "")
            return new Diff("", newTranscript);
        var diffStartIndex = 0;
        for (int i = 0; i < Math.Min(prevTranscript.Length, newTranscript.Length); i++) {
            if (!StringComparer.OrdinalIgnoreCase.Equals(prevTranscript[i], newTranscript[i]))
                break;
            diffStartIndex++;
        }
        if (diffStartIndex == 0)
            return new Diff("", newTranscript);
        if (diffStartIndex >= newTranscript.Length)
            return new Diff(newTranscript, "");
        var retainedPart = newTranscript.Substring(0, diffStartIndex);
        var changedPart = newTranscript.Substring(diffStartIndex);
        return new Diff(retainedPart, changedPart);
    }

    private record Diff(string RetainedPart, string ChangedPart);
}
