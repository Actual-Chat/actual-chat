@namespace ActualChat.Chat.UI.Blazor.Components
@inherits ComputedStateComponent<ChatMessage.Model?>
@using ActualChat.Hosting
@using Microsoft.AspNetCore.Components.Rendering
@using System.Diagnostics.CodeAnalysis

@{
    var model = State.LatestNonErrorValue;
}

@if (model == null) {
    return;
}

@{
    var message = model.Message;
    var entry = message.Entry;
    var timestamp = TimeZoneConverter.ToLocalTime(entry.BeginsAt).ToShortTimeString();

    var showHeader = message.IsBlockStart;
    var showPicture = showHeader;
    var marginClass = message.IsBlockEnd ? "mb-3" : "mb-0";
    var ownMessageClass = model.PrincipalId == message.Entry.AuthorId ? "own-message" : "";
    var highlightClass = model.IsHighlighted ? "chat-message-highlighted" : "";
    var repliedClass = model.IsReplied ? "replied-message" : "";
    var isReply = entry.RepliedChatEntryId != null;
    var selfQuoted = model.RepliedChatMessage?.Entry.AuthorId == model.Message.Entry.AuthorId;
    var mentionClass = model.IsMentioned && !selfQuoted ? "mention" : "";

}

@if (message.DateLine.HasValue) {
    <ChatMessageDateLine Date="@message.DateLine.GetValueOrDefault()"/>
}
@if (message.IsFirstUnread) {
    <Separator Title="new" Class="new-separator" TitleClass="new-separator-title"/>
}

<div class="@ownMessageClass @mentionClass @marginClass @highlightClass @repliedClass message-wrapper">

    <div class="flex-y truncate">
        @if (isReply) {
            <QuotedMessage Message="@model.RepliedChatMessage"/>
        }

        <div class="chat-message group px-1.5 py-0.5 relative">
            @if (showPicture || isReply) {
                <div class="m-1.5">
                    <ChatMessageAuthorCircle AuthorId="@entry.AuthorId" Click="@OnChatAuthorClick"/>
                </div>
            } else {
                <div class="w-10 mr-2 mt-1">
                    <span class="chat-message-timestamp-secondary text-03 text-xs invisible float-right mr-1 mt-0.5">@timestamp</span>
                </div>
            }
            <div class="flex-1 overflow-hidden mb-1 mt-1">
                @if (showHeader || isReply) {
                    <div class="header chat-message-header ml-1">
                        <ChatAuthorName AuthorId="@entry.AuthorId" Class="font-bold text-03"/>
                        <ChatMessageTimestamp Moment="entry.BeginsAt"/>
                        &nbsp;
                        <span class="text-02 opacity-20 text-xxs">id=@entry.Id</span>
                    </div>
                }
                <div class="content message-content rounded-sm">
                    @if (entry.IsStreaming) {
                        <ChatMessageTranscript Model="@message" Class="mx-1"/>
                    } else {
                        <p class="chat-message-markup mx-1">
                            <CascadingValue Value="@entry">
                                <MarkupView Markup="@model.Markup"/>
                            </CascadingValue>
                        </p>
                    }
                </div>
                @if (model.Attachments.Length > 0) {
                    <div class="message-attachments">
                        @foreach (var attachment in model.Attachments) {
                            var isImage = attachment.ContentType.StartsWith("image", StringComparison.OrdinalIgnoreCase);
                            @if (isImage) {
                                <ImageAttachment Attachment="@attachment"/>
                            } else {
                                <FileAttachment Attachment="@attachment"/>
                            }
                        }
                    </div>
                }
            </div>
        </div>
    </div>

    @if (!message.IsQuote) {
        <CascadingValue Value="@message">
            <ContextMenuOld
                Class="chat-message-menu "
                ButtonClass="show-on-hover message-menu-button">
                <ButtonTemplate>
                    <svg class="w-6 h-6 fill-current" xlmns="http://www.w3.org/2000/svg" viewBox="-1 -1 26 26">
                        <path d="M6 12c0 1.657-1.343 3-3 3s-3-1.343-3-3 1.343-3 3-3 3 1.343 3 3zm9 0c0 1.657-1.343 3-3 3s-3-1.343-3-3 1.343-3 3-3 3 1.343 3 3zm9 0c0 1.657-1.343 3-3 3s-3-1.343-3-3 1.343-3 3-3 3 1.343 3 3z"/>
                    </svg>
                </ButtonTemplate>
                <MenuTemplate>
                    <MessageContextMenu />
                </MenuTemplate>
            </ContextMenuOld>
        </CascadingValue>
    }

</div>

@code {
    [Inject] private ChatUI ChatUI { get; init; } = null!;
    [Inject] private Session Session { get; init; } = null!;
    [Inject] private IChatAuthors ChatAuthor { get; init; } = null!;
    [Inject] private IChats Chats { get; init; } = null!;
    [Inject] private TimeZoneConverter TimeZoneConverter { get; init; } = null!;
    [Inject] private IMarkupParser MarkupParser { get; init; } = null!;
    [Inject] private ICommander Commander { get; init; } = null!;
    [Inject] private IEventAggregator EventAggregator { get; init; } = null!;
    [Inject] private IJSRuntime JS { get; init; } = null!;

    [Parameter, EditorRequired, ParameterComparer(typeof(ByValueParameterComparer))]
    public ChatMessageModel Message { get; set; } = null!;

    private ChatEntryReader Reader => Chats.NewEntryReader(Session, Message.Entry.ChatId, ChatEntryType.Text);

    public override Task SetParametersAsync(ParameterView parameters)
        => this.HasChangedParameters(parameters) ? base.SetParametersAsync(parameters) : Task.CompletedTask;

    protected override async Task OnInitializedAsync() {
        await TimeZoneConverter.WhenInitialized.ConfigureAwait(false);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender) {
        await base.OnAfterRenderAsync(firstRender).ConfigureAwait(false);
    }

    protected override async Task<Model?> ComputeState(CancellationToken cancellationToken) {
        var principalId = await ChatAuthor
            .GetPrincipalId(Session, Message.Entry.ChatId, CancellationToken.None)
            .ConfigureAwait(false);

        var attachments = await LoadAttachments(cancellationToken).ConfigureAwait(false);
        var repliedChatMessage = await GetRepliedChatMessage(cancellationToken).ConfigureAwait(false);
        var markup = GetMarkup();
        var isMentioned = IsMentioned(markup, repliedChatMessage, principalId);
        var isReplied = Message.Entry == (await ChatUI.LinkedChatEntry.Use(cancellationToken))?.ChatEntry;
        var isHighlighted = Message.Entry.Id == await ChatUI.HighlightedChatEntryId.Use(cancellationToken);
        return new (Message, markup, principalId, attachments, isMentioned, repliedChatMessage, isHighlighted, isReplied);
    }

    private Markup GetMarkup()
    {
        return Message.Entry.AudioEntryId == null || Message.IsQuote
            ? MarkupParser.Parse(Message.Entry.Content)
            : new PlayableTextMarkup(Message.Entry.Content, Message.Entry.TextToTimeMap);
    }

    private async Task<ChatMessageModel?> GetRepliedChatMessage(CancellationToken cancellationToken) {
        if (Message.Entry.RepliedChatEntryId == null)
            return null;

        var repliedChatEntry = await Reader.Get(Message.Entry.RepliedChatEntryId.Value, CancellationToken.None)
            .ConfigureAwait(false);

    // TODO: show 'message was deleted' if replied message was removed
        if (repliedChatEntry == null)
            return null;

        return new ChatMessageModel(repliedChatEntry) {
            IsBlockStart = true,
            IsQuote = true,
        };
    }

    private void OnChatAuthorClick()
        => ChatUI.ShowChatAuthorDialog(Message.Entry.AuthorId);

    private async Task OnQuoteClick() {
        if (Message.IsQuote) {
            await EventAggregator.Publish(new NavigateToChatEntry(Message.Entry.Id)).ConfigureAwait(false);
            ChatUI.HighlightedChatEntryId.Value = Message.Entry.Id;
        }
    }

    private bool IsMentioned(Markup markup, ChatMessageModel? repliedChatMessage, Symbol principalId)
    {
        if (repliedChatMessage?.Entry.AuthorId == principalId)
            return true;

        return MarkupValidator.ContainsMention.IsValid(markup) && MarkupValidator.ContainsAuthorMention(principalId).IsValid(markup);
    }

    private async Task<ImmutableArray<TextEntryAttachment>> LoadAttachments(CancellationToken cancellationToken) {
        if (!Message.Entry.HasAttachments) {
            return ImmutableArray<TextEntryAttachment>.Empty;
        }

        return await Reader.GetAttachments(Message.Entry.Id, cancellationToken).ConfigureAwait(false);
    }

    public record Model(
        ChatMessageModel Message,
        Markup Markup,
        Symbol PrincipalId,
        ImmutableArray<TextEntryAttachment> Attachments,
        bool IsMentioned,
        ChatMessageModel? RepliedChatMessage,
        bool IsHighlighted,
        bool IsReplied);

}
