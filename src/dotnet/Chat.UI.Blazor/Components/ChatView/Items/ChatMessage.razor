@namespace ActualChat.Chat.UI.Blazor.Components
@inherits ComputedStateComponent<ChatMessage.Model>
@using ActualChat.Hosting
@using Microsoft.AspNetCore.Components.Rendering
@using System.Diagnostics.CodeAnalysis
@{
    var m = _rendered = State.Value;
    var message = _renderedMessage = Message;
    var markup = _renderedMarkup = _markup;
    var entry = message.Entry;

    // Flags
    var isSystem = entry.IsSystemEntry;
    var isReply = m.RepliedEntry != null;
    var isForward = !entry.ForwardedAuthorId.IsNone;
    var isReplyToOwnMessage = m.RepliedEntry?.AuthorId == entry.AuthorId;
    var showAuthor = !isSystem && (message.IsBlockStart || isReply);

    // Classes
    var systemClass = isSystem ? "system-entry" : "";
    var marginClass = message.IsBlockEnd ? "mb-2" : "mb-0";
    var ownMessageClass = m.OwnAuthorId == message.Entry.AuthorId ? "own-message" : "";
    var highlightClass = m.IsHighlighted ? "chat-message-highlighted" : "";
    var repliedClass = m.IsReplyTarget ? "replied-message" : "";
    var selectedClass = m.IsSelected ? "replied-message" : "";
    var mentionClass = m.IsOwnAuthorMentioned && !isReplyToOwnMessage ? "mention" : "";
    var cls = $"{systemClass} {ownMessageClass} {mentionClass} {marginClass} {highlightClass} {repliedClass} {selectedClass} message-wrapper";
}

@if (message.DateLine.HasValue) {
    <ChatMessageDateLine Date="@message.DateLine.GetValueOrDefault()"/>
    return;
}
@if (message.IsFirstUnreadSeparator) {
    <Separator Title="New messages" TitleClass="new-separator-title"/>
    return;
}
@if (isSystem) {
    <div class="@cls"
         data-hover-menu="@(MenuRef.New<MessageHoverMenu>(Message.Entry.Id, bool.TrueString))"
         data-menu="@(MenuRef.New<MessageMenu>(Message.Entry.Id, bool.TrueString, "", ""))"
         data-menu-placement="@(FloatingPosition.BottomStart.ToPositionString())">
        <div class="chat-message group @cls">
            <div class="c-content">
                <div class="message-content">
                    <p class="chat-message-markup">
                        <CascadingValue Value="@entry" IsFixed="true">
                            <MarkupView Markup="@markup"/>
                        </CascadingValue>
                    </p>
                    @if (entry.HasReactions) {
                        <MessageReactions Entry="@entry"/>
                    }
                </div>
            </div>
        </div>
    </div>
    return;
}

@if (isForward) {
    <div class="@cls forwarded-message"
         data-chat-entry-id="@(Message.Entry.Id)"
         data-hover-menu="@(MenuRef.New<MessageHoverMenu>(Message.Entry.Id, bool.FalseString))"
         data-menu="@(MenuRef.New<MessageMenu>(Message.Entry.Id, bool.FalseString, "", ""))"
         data-menu-placement="@(FloatingPosition.BottomStart.ToPositionString())">
        <div class="chat-message group">
            <div class="c-author-badge">
                @if (m.IsFirstForwarded) {
                    <ChatMessageAuthorCircle
                        AuthorSid="@entry.AuthorId"
                        Click="@(_ => AuthorUI.Show(entry.AuthorId))"/>
                } else {
                    var timestamp = TimeZoneConverter.ToLocalTime(entry.BeginsAt).ToShortTimeString();
                    <div class="c-empty">
                        <span class="chat-message-timestamp-on-hover">@timestamp</span>
                    </div>
                }
            </div>
            <div class="c-content">
                @if (m.IsFirstForwarded) {
                    <div class="c-author-header">
                        <AuthorName AuthorSid="@entry.AuthorId" Class="chat-message-author-name"/>
                        <LiveTimeDeltaText Class="chat-message-timestamp" Moment="@entry.BeginsAt"/>
                    </div>
                }
                @if (m.IsFirstForwarded) {
                    <div class="forwarded-header">
                        <i class="icon-share c-icon"></i>
                        <span class="c-chat-title">Forwarded from </span>
                        @if (m.ForwardedChat != null) {
                            <span class="c-chat-title"
                                  @onclick="() => OnForwardedMessageHeaderClick(entry.ForwardedChatEntryId)">
                                @m.ForwardedChat.Title
                            </span>
                        }
                    </div>
                }
                <div class="forwarded-subheader">
                    @if (m.IsSameForwardedAuthor || m.IsFirstForwarded) {
                        <AuthorName AuthorSid="@entry.ForwardedAuthorId" Class="c-author-name"/>
                        <LiveTimeDeltaText Class="chat-message-timestamp" Moment="@m.ForwardedMoment"/>
                    }
                </div>
                <div class="message-content">
                    @if (isReply) {
                        <ChatMessageQuote Entry="@m.RepliedEntry" IsOwn="@isReplyToOwnMessage"/>
                    }
                    @if (entry.IsStreaming) {
                        <ChatMessageTranscript Model="@message" ShowEntryKind="@Message.ShowEntryKind"/>
                    } else {
                        <p class="chat-message-markup">
                            @if (message.ShowEntryKind) {
                                <ChatEntryKindView Kind="@(entry.HasAudioEntry ? ChatEntryKind.Audio : entry.Kind)"/>
                            }
                            <CascadingValue Value="@entry" IsFixed="true">
                                <MarkupView Markup="@_markup"/>
                            </CascadingValue>
                        </p>
                    }
                </div>
                @if (entry.Attachments.Count > 0) {
                    var (mediaList, fileList) = GetOrderedAttachmentList(entry);
                    <div class="message-attachments">
                        <VisualMediaAttachmentList ImageList="@mediaList" ChatEntry="@entry"/>
                        <div class="message-file-attachments">
                            @foreach (var attachment in fileList) {
                                <FileAttachment Attachment="@attachment"/>
                            }
                        </div>
                    </div>
                }
                @if (entry.HasReactions) {
                    <MessageReactions Entry="@entry"/>
                }
            </div>
        </div>
    </div>
} else {
    <div class="@cls"
         data-chat-entry-id="@(Message.Entry.Id)"
         data-hover-menu="@(MenuRef.New<MessageHoverMenu>(Message.Entry.Id, bool.FalseString))"
         data-menu="@(MenuRef.New<MessageMenu>(Message.Entry.Id, bool.FalseString, "", ""))"
         data-menu-placement="@(FloatingPosition.BottomStart.ToPositionString())">
        <div class="chat-message group">
            <div class="c-author-badge">
                @if (showAuthor) {
                    <ChatMessageAuthorCircle
                        AuthorSid="@entry.AuthorId"
                        Click="@(_ => AuthorUI.Show(entry.AuthorId))"/>
                } else {
                    var timestamp = TimeZoneConverter.ToLocalTime(entry.BeginsAt).ToShortTimeString();
                    <div class="c-empty">
                        <span class="chat-message-timestamp-on-hover">@timestamp</span>
                    </div>
                }
            </div>
            <div class="c-content">
                @if (showAuthor) {
                    <div class="c-author-header">
                        <AuthorName AuthorSid="@entry.AuthorId" Class="chat-message-author-name"/>
                        <LiveTimeDeltaText Class="chat-message-timestamp" Moment="@entry.BeginsAt"/>
                        <div class="text-02 opacity-20 text-xxs">id=@entry.Id</div>
                    </div>
                }
                <div class="message-content">
                    @if (isReply) {
                        <ChatMessageQuote Entry="@m.RepliedEntry" IsOwn="@isReplyToOwnMessage"/>
                    }
                    @if (entry.IsStreaming) {
                        <ChatMessageTranscript Model="@message" ShowEntryKind="@Message.ShowEntryKind"/>
                    } else {
                        <p class="chat-message-markup">
                            @if (message.ShowEntryKind) {
                                <ChatEntryKindView Kind="@(entry.HasAudioEntry ? ChatEntryKind.Audio : entry.Kind)"/>
                            }
                            <CascadingValue Value="@entry" IsFixed="true">
                                <MarkupView Markup="@_markup"/>
                            </CascadingValue>
                        </p>
                    }
                </div>
                @if (entry.Attachments.Count > 0) {
                    var (mediaList, fileList) = GetOrderedAttachmentList(entry);
                    <div class="message-attachments">
                        <VisualMediaAttachmentList ImageList="@mediaList" ChatEntry="@entry"/>
                        <div class="message-file-attachments">
                            @foreach (var attachment in fileList) {
                                <FileAttachment Attachment="@attachment"/>
                            }
                        </div>
                    </div>
                }
                @if (entry.HasReactions) {
                    <MessageReactions Entry="@entry"/>
                }
            </div>
        </div>
    </div>
}

@code {
    private Model? _rendered;
    private ChatMessageModel? _renderedMessage;
    private Markup? _renderedMarkup;
    private IChatMarkupHub _chatMarkupHub = null!;
    private ValueTask<Markup> _markupTask;
    private Markup _markup = Markup.Empty;
    private ChatMessageModel? _lastMessage;
    private ChatMessageModel? _previousMessage;

    [Inject] private Session Session { get; init; } = null!;
    [Inject] private History History { get; init; } = null!;
    [Inject] private IAuthors Authors { get; init; } = null!;
    [Inject] private IChats Chats { get; init; } = null!;
    [Inject] private ChatUI ChatUI { get; init; } = null!;
    [Inject] private ChatEditorUI ChatEditorUI { get; init; } = null!;
    [Inject] private AuthorUI AuthorUI { get; init; } = null!;
    [Inject] private SelectionUI SelectionUI { get; init; } = null!;
    [Inject] private KeyedFactory<IChatMarkupHub, ChatId> ChatMarkupHubFactory { get; init; } = null!;
    [Inject] private TimeZoneConverter TimeZoneConverter { get; init; } = null!;
    [Inject] private UIEventHub UIEventHub { get; init; } = null!;
    [Inject] private IJSRuntime JS { get; init; } = null!;
    // [Inject] private ILogger<ChatMessage> Log { get; init; } = null!;

    // Shortcuts
    private ChatEntry Entry => Message.Entry;
    private ChatId ChatId => Message.Entry.ChatId;

    [Parameter, EditorRequired] public ChatMessageModel Message { get; set; } = null!;

    protected override async Task OnParametersSetAsync() {
        var mustReset = _chatMarkupHub == null!;
        mustReset |= Message != _lastMessage;
        /*
        if (mustReset)
            Log.LogInformation("+ {EntryId}", Entry.Id);
        else {
            var changed = Message != _lastMessage;
            if (changed)
                Log.LogInformation("* {EntryId}", Entry.Id);
            mustReset = changed;
        }
        */
        if (mustReset) {
            _lastMessage = Message;
            _chatMarkupHub = ChatMarkupHubFactory[ChatId];
            _markupTask = _chatMarkupHub.GetMarkup(Entry, MarkupConsumer.MessageView, default);
            _markup = await _markupTask;
            await base.OnParametersSetAsync(); // Triggers recompute
        }
    }

    protected override bool ShouldRender() {
        return !ReferenceEquals(_rendered, State.Value)
            || !ReferenceEquals(_renderedMessage, Message)
            || !ReferenceEquals(_renderedMarkup, _markup);
    }

    protected override ComputedState<Model>.Options GetStateOptions() {
        var initialValue = Model.None;
        var ownAuthorTask = Authors.GetOwn(Session, ChatId, default);
        if (ownAuthorTask.IsCompletedSuccessfully) {
            var ownAuthorId = ownAuthorTask.Result?.Id ?? AuthorId.None;
            initialValue = new Model {
                OwnAuthorId = ownAuthorId,
                RepliedEntry = Entry.RepliedEntryLocalId != null ? ChatEntry.Loading : null,
            };
        }
        return new() {
            InitialValue = initialValue,
            Category = GetStateCategory(),
        };
    }

    protected override async Task<Model> ComputeState(CancellationToken cancellationToken) {
        var entry = Entry;
        var chatId = entry.ChatId;
        var ownAuthor = await Authors.GetOwn(Session, chatId, cancellationToken);
        var ownAuthorId = ownAuthor?.Id ?? AuthorId.None;

        var markup = await _markupTask;
        var repliedEntry = await GetRepliedEntry(cancellationToken);
        var hasAnyMentions = HasAnyMentions(markup);
        var isOwnAuthorMentioned = IsMentioned(markup, repliedEntry, ownAuthorId, hasAnyMentions);
        var relatedChatEntry = await ChatEditorUI.RelatedChatEntry.Use(cancellationToken);
        var isReplyTarget = relatedChatEntry is { Kind: RelatedEntryKind.Reply, Id: var repliedEntryId } && repliedEntryId == entry.Id;
        var isHighlighted = entry.Id == await ChatUI.HighlightedEntryId.Use(cancellationToken);
        var forwardedChat = !entry.ForwardedChatEntryId.IsNone
            ? await Chats.Get(Session, entry.ForwardedChatEntryId.ChatId, cancellationToken)
            : null;
        var selectedChatEntries = await SelectionUI.Selection.Use(cancellationToken);
        var hasSelection = await SelectionUI.HasSelection.Use(cancellationToken);

        var isSameForwardedChat = false;
        var isSameForwardedAuthor = false;
        var isSameAuthor = false;
        var forwardedMoment = entry.BeginsAt;

        if (!entry.ForwardedAuthorId.IsNone) {
            var forwardedEntry = await Chats.GetEntry(Session, entry.ForwardedChatEntryId, cancellationToken);
            forwardedMoment = forwardedEntry?.BeginsAt ?? entry.BeginsAt;
            var splitEntryId = entry.Id.ToString().Split(":");
            var success = int.TryParse(splitEntryId[2], out var parseResult);
            var previousLastPart = success ? (parseResult - 1).ToString() : "";

            var previousEntryId = $"{splitEntryId[0]}:{splitEntryId[1]}:{previousLastPart}";

            var previousEntry = await Chats.GetEntry(Session, ChatEntryId.Parse(previousEntryId), cancellationToken);
            if (previousEntry != null) {
                var previousEntryChat = !previousEntry.ForwardedChatEntryId.IsNone
                    ? await Chats.Get(Session, previousEntry.ForwardedChatEntryId.ChatId, cancellationToken)
                    : null;
                isSameForwardedChat = previousEntryChat == forwardedChat;
                isSameForwardedAuthor = previousEntry.ForwardedAuthorId == entry.ForwardedAuthorId;
                isSameAuthor = previousEntry.AuthorId == entry.AuthorId;
            }
        }

        var result = new Model {
            OwnAuthorId = ownAuthorId,
            RepliedEntry = repliedEntry,
            IsHighlighted = isHighlighted,
            IsReplyTarget = isReplyTarget,
            IsSelected = selectedChatEntries.Contains(entry.Id),
            HasSelection = hasSelection,
            IsOwnAuthorMentioned = isOwnAuthorMentioned,
            ForwardedChat = forwardedChat,
            IsFirstForwarded = !isSameAuthor || !isSameForwardedChat,
            IsSameForwardedAuthor = isSameForwardedAuthor,
            ForwardedMoment = forwardedMoment,
        };
        return result.Equals(_rendered) ? _rendered! : result;
    }

    private async Task<ChatEntry?> GetRepliedEntry(CancellationToken cancellationToken) {
        if (Entry.RepliedEntryLocalId is not { } repliedEntryLocalId)
            return null;

        var repliedEntryId = new ChatEntryId(Message.Entry.ChatId, Message.Entry.Kind, repliedEntryLocalId, AssumeValid.Option);
        var repliedEntry = await Chats.GetEntry(Session, repliedEntryId, cancellationToken)
            ?? ChatEntry.Removed(repliedEntryId);

        return repliedEntry;
    }

    private void OnQuoteClick()
        => ChatUI.HighlightEntry(Message.Entry.Id, navigate: true);

    private void OnForwardedMessageHeaderClick(ChatEntryId entryId)
        => _ = History.NavigateTo(Links.Chat(entryId));

    private bool HasAnyMentions(Markup markup)
        => MarkupValidator.ContainsAnyMention.IsValid(markup);

    private bool IsMentioned(Markup markup,
        ChatEntry? repliedEntry,
        AuthorId authorId,
        bool hasAnyMentions)
    {
        if (authorId.IsNone)
            return false;

        if (repliedEntry?.AuthorId == authorId)
            return true;

        return hasAnyMentions && MarkupValidator.ContainsMention(new MentionId(authorId, AssumeValid.Option)).IsValid(markup);
    }

    private (List<TextEntryAttachment>, List<TextEntryAttachment>) GetOrderedAttachmentList(ChatEntry entry) {
        var mediaList = new List<TextEntryAttachment>();
        var fileList = new List<TextEntryAttachment>();
        foreach (var attachment in entry.Attachments) {
            if (attachment.IsVisualMedia())
                mediaList.Add(attachment);
            else
                fileList.Add(attachment);
        }
        return (mediaList, fileList);
    }

    // Nested types

    public sealed record Model {
        public static readonly Model None = new();

        public AuthorId OwnAuthorId { get; init; }
        public bool IsHighlighted { get; init; }
        public bool IsReplyTarget { get; init; }
        public bool IsOwnAuthorMentioned { get; init; }
        public bool IsSelected { get; init; }
        public bool HasSelection { get; init; }
        public bool IsFirstForwarded { get; init; }
        public bool IsSameForwardedAuthor { get; init; }
        public Moment ForwardedMoment { get; init; }
        public ChatEntry? RepliedEntry { get; init; }
        public Chat? ForwardedChat { get; set; }
    }
}
