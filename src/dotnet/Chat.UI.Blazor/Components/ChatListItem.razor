@using BlazorContextMenu
@using ActualChat.Search
@inherits ComputedStateComponent<ChatListItem.Model>
@{
    var m = _lastRenderedModel = State.LatestNonErrorValue;
    var isVisibleMenu = m.IsListening || m.IsRecording;
    var cls = isVisibleMenu ? "visible-menu" : "invisible-menu";
}

<ContextMenuTrigger MouseButtonTrigger="MouseButtonTrigger.Right" MenuId="@ChatMenu.MenuId" Data="@Chat" CssClass="flex-x items-center gap-x-2">
    <NavbarItem Url="@($"/chat/{Chat.Id}")" IsActive="@m.IsActive">
        <ChildContent>
            <div class="flex-x items-center gap-x-2">
                <ChatIcon Chat="Chat"/>
                <span class="text-ellipsis whitespace-nowrap overflow-hidden">
                    <FoundText Text="@Chat.Title"/>
                </span>
            </div>
        </ChildContent>
        <Ending>
            <div class="@cls">
                @if (ListKind == ChatListKind.Listening) {
                    @if (m.CanRecord) {
                        <ChatListRecordingToggle ChatId="@Chat.Id" Class="chat-menu-btn blackout"/>
                    }
                    <ChatListListenToggle ChatId="@Chat.Id" Class="chat-menu-btn blackout"/>
                    <ActiveChatRemoveButton ChatId="@Chat.Id" Class="chat-menu-btn"/>
                } else {
                    @if (m.CanRecord) {
                        <ChatListRecordingToggle ChatId="@Chat.Id" Class="chat-menu-btn blackout"/>
                    }
                    <ChatListListenToggle ChatId="@Chat.Id" Class="chat-menu-btn blackout"/>
                    <ContextMenuToggleTrigger MenuId="@ChatMenu.MenuId" Data="@Chat">
                        <div class="flex">
                            <ButtonRound
                                Class="chat-menu-btn blackout">
                                <i class="icon-more-vertical text-2xl"></i>
                            </ButtonRound>
                            <div class="relative">
                                <div class="placement">
                                </div>
                            </div>
                        </div>
                    </ContextMenuToggleTrigger>
                }
            </div>
            <UnreadMessageCounter ChatId="@Chat.Id"/>
        </Ending>
    </NavbarItem>
</ContextMenuTrigger>

@code {
    private Model? _lastRenderedModel;

    [Inject] private Session Session { get; init; } = null!;
    [Inject] private IChats Chats { get; init; } = null!;
    [Inject] private ChatUI ChatUI { get; init; } = null!;

    [Parameter, EditorRequired, ParameterComparer(typeof(ByReferenceParameterComparer))]
    public Chat Chat { get; init; } = null!;
    [Parameter, EditorRequired, ParameterComparer(typeof(ByValueParameterComparer))]
    public ChatListKind ListKind { get; init; }

    public override Task SetParametersAsync(ParameterView parameters)
        => this.HasChangedParameters(parameters) ? base.SetParametersAsync(parameters) : Task.CompletedTask;

    protected override bool ShouldRender()
        => ReferenceEquals(_lastRenderedModel, null)
           || State.HasError
           || !ReferenceEquals(_lastRenderedModel, State.LatestNonErrorValue);

    protected override ComputedState<Model>.Options GetStateOptions() {
        return new ComputedState<Model>.Options {
            InitialValue = Model.None,
        };
    }

    protected override async Task<Model> ComputeState(CancellationToken cancellationToken)
    {
        var (rules, isListening, isRecording, isActive) =
            await Chats.GetRules(Session, Chat.Id, cancellationToken)
                .Join(
                    ChatUI.IsListening(Chat.Id),
                    ChatUI.IsRecording(Chat.Id),
                    ChatUI.IsActive(Chat.Id)
                ).ConfigureAwait(false);
        return new(rules.CanWrite(), isListening, isRecording, isActive);
    }

    public record Model(
        bool CanRecord,
        bool IsListening,
        bool IsRecording,
        bool IsActive) {
        public static readonly Model None = new(false, false, false, false);
    }
}
