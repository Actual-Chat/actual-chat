@using BlazorContextMenu
@using ActualChat.Search
@using ActualChat.UI.Blazor.Components.Tooltip
@inherits ComputedStateComponent<ChatListItem.Model>
@{
    var m = _lastRenderedModel = State.LatestNonErrorValue;
    var isVisibleMenu = m.IsListening || m.IsRecording;
    var cls = isVisibleMenu ? "visible-menu" : "invisible-menu";
    var title = m.TitleSearchMatch.Text;
}

<ContextMenuTrigger MouseButtonTrigger="MouseButtonTrigger.Right" MenuId="@ChatMenu.MenuId" Data="@Chat" CssClass="flex-x items-center gap-x-2">
    <NavbarItem Url="@($"/chat/{Chat.Id}")" IsActive="@IsActive">
        <ChildContent>
            <div class="flex-x items-center gap-x-2">
                <Pic Title="@Chat.Title" ContentId="@Chat.Picture" Size="SquareSize.Size10" />
                <span class="text-ellipsis whitespace-nowrap overflow-hidden">
                    @if (m.TitleSearchMatch.Parts.Length == 0) {
                        <span>@title</span>
                    } else {
                        foreach (var part in m.TitleSearchMatch.PartsWithGaps) {
                            var textClass = part.Rank > 0 ? "font-semibold" : "";
                            <span class="@textClass">@(title[part.Range.Start..part.Range.End])</span>
                        }
                    }
                </span>
            </div>
        </ChildContent>
        <Ending>
            <div class="@cls">
                @if (ListKind == ChatListKind.Listening) {
                    @if (m.CanRecord) {
                        <ChatListRecordingToggle ChatId="@Chat.Id" Class="!mr-1"/>
                    }
                    <ChatListListenToggle ChatId="@Chat.Id" Class="!mr-1"/>
                    <ActiveChatRemoveButton ChatId="@Chat.Id"/>
                } else {
                    @if (m.CanRecord) {
                        <ChatListRecordingToggle ChatId="@Chat.Id" Class="!mr-1"/>
                    }
                    <ChatListListenToggle ChatId="@Chat.Id" Class="!mr-1"/>
                    <ContextMenuToggleTrigger MenuId="@ChatMenu.MenuId" Data="@Chat">
                        <div class="flex">
                            <Tooltip
                                Text="More"
                                Position="TooltipPosition.Top">
                                <ButtonRound Class="blackout"
                                        BackRef="@context">
                                    <i class="icon-more-vertical text-2xl"></i>
                                </ButtonRound>
                            </Tooltip>
                            <div class="relative">
                                <div class="placement">
                                </div>
                            </div>
                        </div>
                    </ContextMenuToggleTrigger>
                }
            </div>
            <UnreadMessageCounter ChatId="@Chat.Id"/>
        </Ending>
    </NavbarItem>
</ContextMenuTrigger>

@code {
    private Model? _lastRenderedModel;

    [Inject] private Session Session { get; init; } = null!;
    [Inject] private IChats Chats { get; init; } = null!;
    [Inject] private SearchUI SearchUI { get; init; } = null!;
    [Inject] private ChatUI ChatUI { get; init; } = null!;

    [Parameter, EditorRequired, ParameterComparer(typeof(ByReferenceParameterComparer))]
    public Chat Chat { get; init; } = null!;
    [Parameter, EditorRequired, ParameterComparer(typeof(ByValueParameterComparer))]
    public ChatListKind ListKind { get; init; }
    [Parameter] public bool IsActive { get; init; }

    public override Task SetParametersAsync(ParameterView parameters)
        => this.HasChangedParameters(parameters) ? base.SetParametersAsync(parameters) : Task.CompletedTask;

    protected override bool ShouldRender()
        => ReferenceEquals(_lastRenderedModel, null)
           || State.HasError
           || !ReferenceEquals(_lastRenderedModel, State.LatestNonErrorValue);

    protected override ComputedState<Model>.Options GetStateOptions() {
        return new ComputedState<Model>.Options {
            InitialValue = Model.None,
        };
    }

    protected override async Task<Model> ComputeState(CancellationToken cancellationToken)
    {
        var searchPhrase = await SearchUI.GetSearchPhrase(cancellationToken).ConfigureAwait(false);
        var rules = await Chats.GetRules(Session, Chat.Id, cancellationToken).ConfigureAwait(false);
        var titleSearchMatch = searchPhrase.GetMatch(Chat.Title);
        var listeningChatIds = await ChatUI.ListeningChatIds.Use(cancellationToken).ConfigureAwait(false);
        var isListening = listeningChatIds.Contains(Chat.Id);
        var isRecording = await ChatUI.RecordingChatId.Use(cancellationToken).ConfigureAwait(false) == Chat.Id;
        return new(titleSearchMatch, rules.CanWrite(), isListening, isRecording);
    }

    public record Model(
        SearchMatch TitleSearchMatch,
        bool CanRecord,
        bool IsListening,
        bool IsRecording)
    {
        public static readonly Model None = new("", false, false, false);
    }
}
