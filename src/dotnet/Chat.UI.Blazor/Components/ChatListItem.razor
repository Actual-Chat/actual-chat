@using ActualChat.Search
@inherits ComputedStateComponent<ChatState>
@{
    var m = _lastRenderedModel = State.LatestNonErrorValue;
    var chat = m.Chat;
    var info = m.Info;
    var mediaState = m.MediaState;
    var canWrite = chat.Rules.CanWrite();
    var isMenuVisible = m.IsListening || m.IsRecording;
    var cls = isMenuVisible ? "visible-menu" : "invisible-menu";
}

<NavbarItem
    Url="@($"/chat/{chat.Id}")"
    IsSelected="@m.IsSelected"
    data-menu="@(MenuRef.New<ChatMenu>(chat.Id).ToString())"
    data-menu-trigger="@((MenuTriggers.LongClick | MenuTriggers.RightClick).Format())"
    data-menu-position="@(FloatingPosition.BottomStart.ToPositionString())"
    data-long-press-delay="500">
    <ChildContent>
        <div class="flex-x items-center gap-x-2">
            <ChatIcon Chat="m.Chat"/>
            <div class="flex-none flex-y justify-start items-start">
                <div class="text-headline-1 text-02 text-ellipsis whitespace-nowrap overflow-hidden">
                    <SearchUIHighlighter Text="@m.Chat.Title"/>
                </div>
                @if (info.LastTextEntry != null) {
                    <div class="text-xs text-03 text-ellipsis whitespace-nowrap overflow-hidden">
                        @if (m.Chat.Kind != ChatKind.Peer) {
                            <span>
                                <AuthorName Class="text-xs text-02" AuthorSid="@info.LastTextEntry.AuthorId"/>:
                            </span>
                        }
                        @info.LastTextEntryContent
                    </div>
                }
            </div>
        </div>
    </ChildContent>
    <Ending>
        <div class="@cls">
            @if (ListKind == ChatListKind.Active) {
                if (canWrite) {
                    <ChatListRecordingToggle Chat="@chat" IsRecording="@mediaState.IsRecording" Class="chat-menu-btn blackout"/>
                }
                <ChatListListenToggle MediaState="@mediaState" Class="chat-menu-btn blackout"/>
                <ActiveChatRemoveButton Chat="@chat" Class="chat-menu-btn"/>
            } else {
                @if (canWrite) {
                    <ChatListRecordingToggle Chat="@chat" IsRecording="@mediaState.IsRecording" Class="chat-menu-btn blackout"/>
                }
                <ChatListListenToggle MediaState="@mediaState" Class="chat-menu-btn blackout"/>
                <div class="flex"
                     data-menu="@(MenuRef.New<ChatMenu>(chat.Id).ToString())"
                     data-menu-trigger="@(MenuTriggers.LeftClick.Format())"
                     data-menu-position="@(FloatingPosition.RightStart.ToPositionString())">
                    <ButtonRound
                        ContentClass="!bg-transparent"
                        Class="chat-menu-btn blackout">
                        <i class="icon-more-vertical text-2xl"></i>
                    </ButtonRound>
                    <div class="relative">
                        <div class="placement">
                        </div>
                    </div>
                </div>
            }
        </div>
        <UnreadCount Value="@m.Info.UnreadCount" NotificationMode="@m.Info.UserSettings.NotificationMode"/>
    </Ending>
</NavbarItem>

@code {
    private ChatState? _lastRenderedModel = null;

    [Inject] private ChatUI ChatUI { get; init; } = null!;

    [Parameter, EditorRequired] public ChatInfo ChatInfo { get; init; } = null!;
    [Parameter, EditorRequired] public ChatListKind ListKind { get; init; }

    protected override bool ShouldRender()
        => State.HasError || !ReferenceEquals(_lastRenderedModel, State.LatestNonErrorValue);

    protected override ComputedState<ChatState>.Options GetStateOptions()
        => new() {
            InitialValue = new ChatState(ChatInfo, new ChatMediaState(ChatInfo.Id)),
        };

    protected override async Task<ChatState> ComputeState(CancellationToken cancellationToken)
    {
        var chatState = await ChatUI.GetState(ChatInfo.Id, false, cancellationToken).ConfigureAwait(false);
        return chatState ?? ChatState.None;
    }
}
