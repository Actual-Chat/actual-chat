@using ActualChat.Search
@inherits ComputedStateComponent<ChatState>
@{
    var m = _rendered = State.Value;
    var chat = m.Chat;
    var info = m.Info;
    var lastTextEntry = info.LastTextEntry;
    var audioState = m.AudioState;
    var canWrite = chat.Rules.CanWrite();
    var isActiveChatList = ListKind == ChatListKind.Active;
    var isMenuShown = isActiveChatList || ScreenSize.IsWide();
    var isMenuVisible = m.IsListening || m.IsRecording;
    var cls = isMenuVisible ? "" : "hover-menu";
}

<NavbarItem
    Url="@($"/chat/{chat.Id}")"
    IsSelected="@m.IsSelected"
    data-menu="@(MenuRef.New<ChatMenu>(chat.Id, ListKind.Format()).ToString())"
    data-menu-placement="@(FloatingPosition.BottomStart.ToPositionString())">
    <ChildContent>
        <div class="flex-x items-center gap-x-2">
            <ChatIcon Chat="m.Chat"/>
            <div class="grid justify-start items-start gap-y-1">
                <span class="text-headline-1 text-02 truncate">
                    <SearchUIHighlighter Text="@m.Chat.Title"/>
                </span>
                @if (lastTextEntry != null) {
                    <div class="text-xs text-03 truncate">
                        @if (m.Chat.Kind != ChatKind.Peer && !lastTextEntry.IsSystemEntry) {
                            <span>
                                <AuthorName Class="text-xs text-02 font-medium" AuthorSid="@lastTextEntry.AuthorId" ShowDetailsOnClick="false"/>:
                            </span>
                        }
                        @info.LastTextEntryText
                    </div>
                }
            </div>
        </div>
    </ChildContent>
    <Ending>
        @if (isMenuShown) {
            <div class="@cls menu">
                @if (isActiveChatList) {
                    if (canWrite) {
                        <ChatListRecordingToggle Chat="@chat" IsRecording="@audioState.IsRecording" Class="chat-menu-btn blackout"/>
                    }
                    <ChatListListenToggle AudioState="@audioState" Class="chat-menu-btn blackout"/>
                    <ActiveChatRemoveButton Chat="@chat" IsSelected="@m.IsSelected" Class="chat-menu-btn"/>
                } else {
                    @if (canWrite) {
                        <ChatListRecordingToggle Chat="@chat" IsRecording="@audioState.IsRecording" Class="chat-menu-btn blackout"/>
                    }
                    <ChatListListenToggle AudioState="@audioState" Class="chat-menu-btn blackout"/>
                    <div class="flex"
                         data-menu="@(MenuRef.New<ChatMenu>(chat.Id, ListKind.Format()).ToString())"
                         data-menu-trigger="@MenuTrigger.Primary"
                         data-menu-placement="@(FloatingPosition.RightStart.ToPositionString())">
                        <ButtonRound
                            ContentClass="!bg-transparent"
                            Class="chat-menu-btn blackout">
                            <i class="icon-more-vertical text-2xl"></i>
                        </ButtonRound>
                        <div class="relative">
                            <div class="placement">
                            </div>
                        </div>
                    </div>
                }
            </div>
        }
        <UnreadCount Value="@m.Info.UnreadCount" NotificationMode="@m.Info.UserSettings.NotificationMode" HasMentions="m.Info.HasUnreadMentions"/>
    </Ending>
</NavbarItem>

@code {
    private ChatState? _rendered = null;

    [Inject] private ChatUI ChatUI { get; init; } = null!;

    [CascadingParameter] public ScreenSize ScreenSize { get; init; }
    [Parameter, EditorRequired] public ChatInfo ChatInfo { get; init; } = null!;
    [Parameter, EditorRequired] public ChatListKind ListKind { get; init; }

    protected override bool ShouldRender()
        => State.HasError || !ReferenceEquals(_rendered, State.Value);

    protected override ComputedState<ChatState>.Options GetStateOptions()
        => new() {
            InitialValue = new ChatState(ChatInfo, new ChatAudioState(ChatInfo.Id)),
            Category = GetStateCategory(),
        };

    protected override async Task<ChatState> ComputeState(CancellationToken cancellationToken)
    {
        var chatId = await ChatUI.FixChatId(ChatInfo.Id, cancellationToken).ConfigureAwait(false);
        var chatState = await ChatUI.GetState(chatId, false, cancellationToken).ConfigureAwait(false);
        return chatState ?? ChatState.None;
    }
}
