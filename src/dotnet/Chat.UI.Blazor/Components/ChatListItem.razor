@using ActualChat.Search
@inherits ComputedStateComponent<ChatListItem.Model>
@{
    var m = _lastRenderedModel = State.LatestNonErrorValue;
    var isVisibleMenu = m.IsListening || m.IsRecording;
    var cls = isVisibleMenu ? "visible-menu" : "invisible-menu";
}

<NavbarItem Url="@($"/chat/{Chat.Id}")" IsSelected="@m.IsSelected"
            data-menu="@(MenuTrigger.Format<ChatContextMenu>(Chat.Id))"
            data-menu-trigger="@((MenuTriggers.LongClick | MenuTriggers.RightClick).ToTriggersString())">
    <ChildContent>
        <div class="flex-x items-center gap-x-2">
            <ChatIcon Chat="Chat"/>
            <span class="text-ellipsis whitespace-nowrap overflow-hidden">
                <SearchUIHighlighter Text="@Chat.Title"/>
            </span>
        </div>
    </ChildContent>
    <Ending>
        <div class="@cls">
            @if (ListKind == ChatListKind.Listening) {
                @if (m.CanRecord) {
                    <ChatListRecordingToggle ChatId="@Chat.Id" Class="chat-menu-btn blackout"/>
                }
                <ChatListListenToggle ChatId="@Chat.Id" Class="chat-menu-btn blackout"/>
                <ActiveChatRemoveButton ChatId="@Chat.Id" Class="chat-menu-btn"/>
            } else {
                @if (m.CanRecord) {
                    <ChatListRecordingToggle ChatId="@Chat.Id" Class="chat-menu-btn blackout"/>
                }
                <ChatListListenToggle ChatId="@Chat.Id" Class="chat-menu-btn blackout"/>
                <div class="flex"
                     data-menu="@(MenuTrigger.Format<ChatContextMenu>(Chat.Id))"
                     data-menu-trigger="@(MenuTriggers.LeftClick.ToTriggersString())"
                     data-menu-position="@(FloatingPosition.RightStart.ToPositionString())">
                    <ButtonRound
                        ContentClass="!bg-transparent"
                        Class="chat-menu-btn blackout">
                        <i class="icon-more-vertical text-2xl"></i>
                    </ButtonRound>
                    <div class="relative">
                        <div class="placement">
                        </div>
                    </div>
                </div>
            }
        </div>
        <UnreadMessageCounter ChatId="@Chat.Id"/>
    </Ending>
</NavbarItem>

@code {
    private Model? _lastRenderedModel;

    [Inject] private Session Session { get; init; } = null!;
    [Inject] private IChats Chats { get; init; } = null!;
    [Inject] private ChatUI ChatUI { get; init; } = null!;

    [Parameter, EditorRequired, ParameterComparer(typeof(ByReferenceParameterComparer))]
    public Chat Chat { get; init; } = null!;
    [Parameter, EditorRequired, ParameterComparer(typeof(ByValueParameterComparer))]
    public ChatListKind ListKind { get; init; }

    public override Task SetParametersAsync(ParameterView parameters)
        => this.HasChangedParameters(parameters) ? base.SetParametersAsync(parameters) : Task.CompletedTask;

    protected override bool ShouldRender()
        => ReferenceEquals(_lastRenderedModel, null)
           || State.HasError
           || !ReferenceEquals(_lastRenderedModel, State.LatestNonErrorValue);

    protected override ComputedState<Model>.Options GetStateOptions() {
        return new ComputedState<Model>.Options {
            InitialValue = Model.None,
        };
    }

    protected override async Task<Model> ComputeState(CancellationToken cancellationToken)
    {
        var (rules, isListening, isRecording, isSelected) =
            await Chats.GetRules(Session, Chat.Id, cancellationToken)
                .Join(
                    ChatUI.IsListening(Chat.Id),
                    ChatUI.IsRecording(Chat.Id),
                    ChatUI.IsSelected(Chat.Id)
                ).ConfigureAwait(false);
        return new(rules.CanWrite(), isListening, isRecording, isSelected);
    }

    public record Model(
        bool CanRecord,
        bool IsListening,
        bool IsRecording,
        bool IsSelected) {
        public static readonly Model None = new(false, false, false, false);
    }
}
