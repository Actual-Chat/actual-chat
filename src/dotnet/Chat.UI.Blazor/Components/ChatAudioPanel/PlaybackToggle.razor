@namespace ActualChat.Chat.UI.Blazor.Components
@inherits ComputedStateComponent<PlaybackToggle.Model>
@{
    var rendered = _rendered;
    var m = _rendered = State.Value;
    if (rendered.Chat.Id != m.Chat.Id)
        rendered = m;
    var audioState = m.AudioState;

    var playingHistoricalClass = audioState.IsPlayingHistorical ? "opacity-60" : "";
    var cls = $"{(audioState.IsListening ? "on" : "off")} {playingHistoricalClass}";
    var wrapperCls = (rendered.AudioState.IsListening, audioState.IsListening) switch {
        (false, true) => "listen-off-to-on",
        (true, false) => "listen-on-to-off",
        (_, true) => "listen-on",
        (_, false) => "listen-off",
    };
    _rendered = m;
    var loudBtnCls = "loud-btn " + (m.IsSpeakerphoneOn ? "on" : "off");
}

<div class="@wrapperCls playback-wrapper">
    <ButtonRound Click="@OnListenClick" Class="@cls" MustKeepAwake="@(!audioState.IsListening)">
        <i class="icon-listen text-2xl"></i>
    </ButtonRound>
    @* Temporarily disabled switch between loud speaker and earpiece *@
    @* to have single audio channel controlled with volume buttons  *@
    @* <ButtonRound Click="@OnToggleAudioOutputClick" Class="@loudBtnCls"> *@
    @*     <i class="icon-volume-up text-2xl"></i> *@
    @* </ButtonRound> *@
</div>

@code {
    private Model _rendered = Model.Loading;

    [Inject] private ChatPlayers ChatPlayers { get; init; } = null!;
    [Inject] private ChatAudioUI ChatAudioUI { get; init; } = null!;
    [Inject] private IAudioOutputController AudioOutputController { get; init; } = null!;

    private bool IsLoading => !Chat.Id.IsNone && State.Value.Chat.Id != Chat.Id;
    private bool IsListening => !IsLoading && State.Value.AudioState.IsListening;

    [Parameter, EditorRequired] public Chat Chat { get; set; } = SpecialChat.Unavailable;

    protected override ComputedState<Model>.Options GetStateOptions()
        => new() {
            InitialValue = Model.Loading,
            UpdateDelayer = FixedDelayer.Instant,
            Category = GetStateCategory(),
        };

    protected override async Task<Model> ComputeState(CancellationToken cancellationToken) {
        var audioState = await ChatAudioUI.GetState(Chat.Id);
        var isSpeakerphoneOn = await AudioOutputController.IsSpeakerphoneOn.Use(cancellationToken);
        return new Model(Chat, audioState, isSpeakerphoneOn);
    }

    private void OnListenClick() {
        if (IsLoading)
            return;

        _ = ChatAudioUI.SetListeningState(Chat.Id, !IsListening);
    }

    private void OnToggleAudioOutputClick()
        => AudioOutputController.ToggleSpeakerphone(!AudioOutputController.IsSpeakerphoneOn.Value);


    public sealed record Model(
        Chat Chat,
        ChatAudioState AudioState,
        bool IsSpeakerphoneOn = false
    ) {
        public static Model Loading { get; } = new(SpecialChat.Loading, ChatAudioState.None);
    }
}
