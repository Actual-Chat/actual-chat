@namespace ActualChat.Chat.UI.Blazor.Components
@using ActualChat.Audio.UI.Blazor.Components
@inherits ComputedStateComponent<RecorderToggle.Model>
@{
    var m = State.Value;
    _animator.State = m.IsRecording;
    var animatorClass = "record-" + _animator.Class;
    var applyingChangesClass = m.IsApplyingChanges ? "applying-changes" : "";
}

@if (m.HasMicrophonePermission != false) {
    <div class="recorder-wrapper @animatorClass @applyingChangesClass">
        <ButtonRound
            Class="record-off-btn"
            Click="OnClick"
            MustKeepAwake="true"
            @onpointerup="OnPointerUp"
            @oncontextmenu="OnContextMenu"
            data-context-menu-delay="200">
            <img src="/dist/images/logo-white.svg" alt="logo" class="recorder-icon">
        </ButtonRound>
        <ButtonRound
            Class="record-on-btn"
            Click="OnClick"
            @onpointerup="OnPointerUp"
            @oncontextmenu="OnContextMenu"
            data-context-menu-delay="200">
            <i class="icon-Stop-fill text-2xl"></i>
        </ButtonRound>
    </div>
} else {
    <div class="recorder-wrapper">
        <ButtonRound
            Class="mic-disabled w-14 h-14"
            Click="OnClick">
            <i class="icon-mic-off text-2xl text-04"></i>
        </ButtonRound>
    </div>
}

@code {
    private OnOffAnimator _animator = null!;

    [Inject] private ChatAudioUI ChatAudioUI { get; init; } = null!;
    [Inject] private AudioRecorder AudioRecorder { get; init; } = null!;
    [Inject] private ModalUI ModalUI { get; init; } = null!;

    private bool IsChatChanging => !Chat.Id.IsNone && State.Value.Chat.Id != Chat.Id;
    private bool IsRecording => !IsChatChanging && State.Value.IsRecording;
    private bool IsForcePush { get; set; } = false;

    [Parameter, EditorRequired] public Chat Chat { get; set; } = Chat.None;

    protected override void OnInitialized() {
        _animator = new OnOffAnimator(this, TimeSpan.FromMilliseconds(300));
        base.OnInitialized();
    }

    public override ValueTask DisposeAsync() {
        _animator.Dispose();
        return base.DisposeAsync();
    }

    protected override ComputedState<Model>.Options GetStateOptions()
        => new() {
            InitialValue = Model.Loading,
            UpdateDelayer = FixedDelayer.Instant,
            Category = GetStateCategory(),
        };

    protected override async Task<Model> ComputeState(CancellationToken cancellationToken) {
        var recordingChatId = await ChatAudioUI.GetRecordingChatId();
        var recorderState = await AudioRecorder.State.Use(cancellationToken);
        var hasMicrophonePermission = await AudioRecorder.MicrophonePermission.Cached.Use(cancellationToken);
        var isRecording = recordingChatId == Chat.Id;
        var isApplyingChanges = recorderState.ChatId == Chat.Id && recorderState.IsRecording != isRecording;
        return new Model(Chat, isRecording, isApplyingChanges, hasMicrophonePermission);
    }

    private async Task OnClick() {
        if (IsChatChanging)
            return; // Loading

        if (IsRecording) {
            _ = ChatAudioUI.SetRecordingChatId(default);
        }
        else {
            if (!await AudioRecorder.MicrophonePermission.CheckOrRequest())
                return;

            _ = ChatAudioUI.SetRecordingChatId(Chat.Id);
        }
    }

    private async Task OnContextMenu() {
        if (IsForcePush)
            return;
        if (!await AudioRecorder.MicrophonePermission.CheckOrRequest())
            return;

        IsForcePush = true;
        _ = ChatAudioUI.SetRecordingChatId(Chat.Id);
    }

    private void OnPointerUp() {
        if (!IsForcePush)
            return;

        IsForcePush = false;
        _ = ChatAudioUI.SetRecordingChatId(default);
    }

    // Nested types

    public sealed record Model(
        Chat Chat,
        bool IsRecording = false,
        bool IsApplyingChanges = false,
        bool? HasMicrophonePermission = null
    ) {
        public static Model Loading { get; } = new(ChatUI.Loading, false, true);
    }
}
