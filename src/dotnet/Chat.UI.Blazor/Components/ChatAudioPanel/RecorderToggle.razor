@namespace ActualChat.Chat.UI.Blazor.Components
@using ActualChat.Audio.UI.Blazor.Components
@using ActualChat.Chat.UI.Blazor.Module
@using System.Diagnostics.CodeAnalysis
@inherits ComputedStateComponent<RecorderToggle.Model>
@{
    var m = State.Value;
    _animator.State = m.IsRecordingHere;
    var animatorClass = "record-" + _animator.Class;
    var transitioningClass = m.IsTransitioning || m is { IsRecordingHere: true, IsConnected: false } ? "applying-changes" : "";
    var (showStatus, statusText, statusStyle) = (m.IsRecordingHere, m.IsMicrophoneCaptured, m.IsConnected) switch {
        (false, _, _) => (false, "", ""),
        (_, false, _) => (true, "Starting recording...", "left:4.6rem"),
        (_, _, false) => (true, "Reconnecting...", "left:4rem"),
        _ => (false, "Recording...", "left:3.5rem"), // (true, true, true) => ...
    };
    var tooltipText = showStatus ? "" : statusText;
    var tooltipPosition = showStatus ? FloatingPosition.None : FloatingPosition.Top;
}

@if (m.HasMicrophonePermission != false) {
    @if (showStatus) {
        <div class="narrow-recorder-tooltip">
            <div class="c-tooltip-text">@statusText</div>
            <div class="c-tooltip-arrow" style="@statusStyle"></div>
        </div>
    }
    <div class="recorder-wrapper @animatorClass @transitioningClass">
        @if (showStatus) {
            <div class="c-tooltip">
                <div class="c-tooltip-text">@statusText</div>
                <div class="c-tooltip-arrow" style="@statusStyle"></div>
            </div>
        }
        <ButtonRound
            Class="record-off-btn"
            Click="@OnClick"
            MustKeepAwake="true"
            Tooltip="@tooltipText"
            TooltipPosition="@tooltipPosition"
            @onmouseup="@OnPointerUp"
            @ontouchend="@OnPointerUp"
            @ontouchcancel="@OnPointerUp"
            @oncontextmenu="@OnContextMenu"
            data-context-menu-delay="200">
            <i class="icon-talking text-xl recorder-icon"></i>
        </ButtonRound>
        <ButtonRound
            Class="record-on-btn"
            Click="@OnClick"
            Tooltip="@tooltipText"
            TooltipPosition="@tooltipPosition"
            @onmouseup="@OnPointerUp"
            @ontouchend="@OnPointerUp"
            @ontouchcancel="@OnPointerUp"
            @oncontextmenu="@OnContextMenu"
            data-context-menu-delay="200">
            <i class="icon-stop-fill text-2xl recorder-icon"></i>
        </ButtonRound>
    </div>
} else {
    <div class="recorder-wrapper mic-disabled">
        <ButtonRound
            Class="mic-disabled w-14 h-14"
            Click="@OnClick">
            <i class="icon-mic-off text-2xl text-06"></i>
        </ButtonRound>
    </div>
}

@code {
    private static readonly string JSInitMethod = $"{ChatBlazorUIModule.ImportName}.RecorderToggle.init";
    private OnOffAnimator _animator = null!;

    [Inject] private ChatHub ChatHub { get; init; } = null!;
    private AudioRecorder AudioRecorder => ChatHub.AudioRecorder;
    private ChatAudioUI ChatAudioUI => ChatHub.ChatAudioUI;
    private IJSRuntime JS => ChatHub.JS;

    private bool IsForcePushed { get; set; } = false;
    private bool IsUpdating => !Chat.Id.IsNone && State.Value.Chat.Id != Chat.Id;

    [Parameter, EditorRequired] public Chat Chat { get; set; } = SpecialChat.Unavailable;

    protected override void OnInitialized() {
        _animator = new OnOffAnimator(this, TimeSpan.FromMilliseconds(300));
        base.OnInitialized();
    }

    protected override Task OnInitializedAsync()
        => AudioRecorder.MicrophonePermission.Check(CancellationToken.None);

    protected override async Task OnAfterRenderAsync(bool firstRender) {
        if (!firstRender)
            return;

        await JS.InvokeVoidAsync(JSInitMethod);
    }

    public override ValueTask DisposeAsync() {
        _animator.Dispose();
        return base.DisposeAsync();
    }

    protected override ComputedState<Model>.Options GetStateOptions()
        => new() {
            InitialValue = Model.Loading,
            UpdateDelayer = FixedDelayer.Instant,
            Category = GetStateCategory(),
        };

    protected override async Task<Model> ComputeState(CancellationToken cancellationToken) {
        var chatId = Chat.Id; // Capture to locals to make sure we can use .ConfigureAwait(false) below
        var recordingChatId = await ChatAudioUI.GetRecordingChatId().ConfigureAwait(false);
        var recorderState = await AudioRecorder.State.Use(cancellationToken).ConfigureAwait(false);
        var hasMicrophonePermission = await AudioRecorder.MicrophonePermission.Cached.Use(cancellationToken).ConfigureAwait(false);
        var isRecordingHere = recordingChatId == chatId;
        var isTransitioning =
            recordingChatId == chatId // The recorder records in this chat
            && recorderState.IsRecording != isRecordingHere; // AND it's state is not in sync with the expected one here
        return new Model(
            Chat,
            isRecordingHere,
            recorderState.IsRecording,
            recorderState.IsConnected,
            recorderState.IsVoiceActive,
            hasMicrophonePermission,
            isTransitioning);
    }

    private async Task OnClick() {
        var m = State.Value;
        if (Chat.Id != m.Chat.Id)
            return; // Loading or updating

        if (m.IsRecordingHere) {
            // Stop recording
            _ = ChatAudioUI.SetRecordingChatId(default);
        }
        else {
            // Start recording
            if (!await AudioRecorder.MicrophonePermission.CheckOrRequest())
                return;

            _ = ChatAudioUI.SetRecordingChatId(Chat.Id);
        }
    }

    private async Task OnContextMenu() {
        if (IsForcePushed)
            return;
        if (!await AudioRecorder.MicrophonePermission.CheckOrRequest())
            return;

        IsForcePushed = true;
        _ = ChatAudioUI.SetRecordingChatId(Chat.Id, true);
    }

    private void OnPointerUp() {
        if (!IsForcePushed)
            return;

        IsForcePushed = false;
        _ = ChatAudioUI.SetRecordingChatId(default);
    }

    // Nested types

    public sealed record Model(
        Chat Chat,
        bool IsRecordingHere = false,
        bool IsMicrophoneCaptured = false,
        bool IsConnected = false,
        bool IsVoiceActive = false,
        bool? HasMicrophonePermission = null,
        bool IsTransitioning = false
    ) {
        public static readonly Model Loading = new(SpecialChat.Loading, default, false, true);
    }
}
