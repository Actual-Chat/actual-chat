@namespace ActualChat.Chat.UI.Blazor.Components
@using ActualChat.Notification
@inherits ComputedStateComponent<UnreadMessageCounter.Model>
@{
    var m = State.LatestNonErrorValue ?? Model.None;
    if (m.Count == 0)
        return;

    var bgColor = m.IsSubscribed
        ? "bg-primary"
        : "bg-counter";

    var countText = m.HasMentions ? "@" : m.Count != 0 ? m.Count.Format() : "";
    var cls = $"{bgColor} message-counter-badge";
}

<Badge Class="@cls">
    @countText
</Badge>

@code {
    [Inject] private Session Session { get; init; } = null!;
    [Inject] private INotifications Notifications { get; init; } = null!;
    [Inject] private UnreadMessagesFactory UnreadMessagesFactory { get; init; } = null!;

    private UnreadMessages UnreadMessages { get; set; } = null!;

    [Parameter, EditorRequired] public string ChatId { get; set; } = "";

    protected override Task OnParametersSetAsync() {
        UnreadMessages.DisposeSilently();
        UnreadMessages = UnreadMessagesFactory.Get(ChatId);
        return base.OnParametersSetAsync();
    }

    public override async ValueTask DisposeAsync() {
        await base.DisposeAsync();
        UnreadMessages.DisposeSilently();
    }

    protected override ComputedState<Model>.Options GetStateOptions() {
        return new() {
            InitialValue = Model.None,
            UpdateDelayer = new UpdateDelayer(Services.UIActionTracker(), TimeSpan.FromSeconds(1)) {
                MinDelay = TimeSpan.FromSeconds(0.3), // Prevents blinking on your own updates
            },
        };
    }

    protected override async Task<Model> ComputeState(CancellationToken cancellationToken) {
        var hasMentionsTask = UnreadMessages.HasMentions(cancellationToken);
        var countTask = UnreadMessages.GetCount(cancellationToken);
        var getIsSubscribedTask = Notifications.IsSubscribed(Session, ChatId, cancellationToken);

        // ConfigureAwait(false) from here
        var hasMentions = await hasMentionsTask.ConfigureAwait(false);
        var count = await countTask.ConfigureAwait(false);
        var isSubscribed = await getIsSubscribedTask.ConfigureAwait(false);

        if (!hasMentions && count == 0)
            return Model.None;

        return new() {
            Count = count,
            IsSubscribed = isSubscribed,
            HasMentions = hasMentions,
        };
    }

    public sealed record Model {
        public static readonly Model None = new();

        public bool HasMentions { get; init; }
        public MaybeTrimmed<int> Count { get; init; }
        public bool IsSubscribed { get; init; }
    }
}
