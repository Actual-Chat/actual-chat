@namespace ActualChat.Chat.UI.Blazor.Components
@using ActualChat.Playback
@using ActualChat.Chat.UI.Blazor.Services
@using System.Text.RegularExpressions
@using ActualChat.Chat.UI.Blazor.Components.MarkupParts
@using Stl.Extensibility
@inherits ComputedStateComponent<ActualChat.Playback.MediaTrackPlaybackState?>
@inject IMediaPlayerService _mediaPlayerService

@if (Markup != null) {
    <p class="chat-markup">
        @foreach (var part in Markup.Parts) {
            @RenderPart(part)
        }
    </p>
}

@code {
    [Inject] private IMatchingTypeFinder MatchingTypeFinder { get; set; } = null!;
    [Inject] private MarkupParser MarkupParser { get; set; } = null!;
    private ChatEntry Entry => Model.Entry;
    private Markup? Markup { get; set; } = null!;

    [Parameter, EditorRequired, ParameterComparer(typeof(ByReferenceParameterComparer))]
    public ChatMessageModel Model { get; set; } = null!;

    public override Task SetParametersAsync(ParameterView parameters)
        => this.HasChangedParameters(parameters) ? base.SetParametersAsync(parameters) : Task.CompletedTask;

    protected override async Task OnParametersSetAsync() {
        Markup = await MarkupParser.Parse(Entry.Content, Entry.TextToTimeMap).ConfigureAwait(true);
        _ = State.Recompute();
    }

    protected override async Task<MediaTrackPlaybackState?> ComputeState(CancellationToken cancellationToken) {
        var trackId = ChatMediaPlayer.GetAudioTrackId(Entry);
        return await _mediaPlayerService.GetMediaTrackPlaybackState(trackId, cancellationToken).ConfigureAwait(false);
    }

    // Private methods

    private RenderFragment RenderPart(MarkupPart part) {
        if (part is PlainTextPart) {
            var playbackState = State.ValueOrDefault;
            var partTimeRange = part.TimeRange;
            if (playbackState == null || playbackState.IsCompleted || partTimeRange.IsEmpty)
                return @<PlainTextPartView Entry="@Model.Entry" Part="@part"/>;

            var playingAt = playbackState.PlayingAt.TotalSeconds;
            var playingAtNearbyRange = new Range<double>(playingAt - 1, playingAt + 1);
            if (!playingAtNearbyRange.Overlaps(part.TimeRange))
                return @<PlainTextPartView Entry="@Model.Entry" Part="@part"/>;

            return @<PlainTextPartView Entry="@Model.Entry" Part="@part" PlayingAt="@playingAt"/>;
        }

        var componentType = MatchingTypeFinder.TryFind(part.GetType(), typeof(IMarkupPartView));
        if (componentType == null)
            return @<UnknownPartView Entry="@Model.Entry" Part="@part"/>;

        return builder => {
            var i = 0;
            builder.OpenComponent(i++, componentType);
            builder.AddAttribute(i++, nameof(IMarkupPartView.Entry), Entry);
            builder.AddAttribute(i++, nameof(IMarkupPartView.Part), part);
            builder.CloseComponent();
        };
    }
}
