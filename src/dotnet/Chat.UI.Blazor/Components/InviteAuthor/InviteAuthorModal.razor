@namespace ActualChat.Chat.UI.Blazor.Components
@using ActualChat.Contacts
@using ActualChat.Search
@implements IModalView<InviteAuthorModal.Model>
@implements IDisposable

<DialogFrame Class="invite-author-modal" Title="Invite users" HasCloseButton="true">
    <Body>
    <SearchBox
        @ref="_searchBoxRef"
        Placeholder="Find contacts..."
        MaxLength="@Constants.Chat.MaxSearchFilterLength"
        TextChanged="@OnFilter"/>
    <div class="invite-author-modal-contact-list">
        @foreach (var contact in FilteredContacts) {
            <div class="invite-author-modal-contact-list-item"
                 @key="@contact.Account.Id.Value"
                 @onclick="@(_ => OnContactClick(contact))">
                <AccountCircle UserSid="@contact.Account.Id" ShowPresence="true"/>
                <div class="flex-y grow gap-y-1 overflow-hidden">
                    <span class="text-headline-1 text-02 truncate">
                        <SearchMatchHighlighter Match="@GetMatch(contact.Account.Avatar.Name)"/>
                    </span>
                </div>
                @if (contact.IsExisting) {
                    <Checkbox
                        IsChecked="true"
                        IsDisabled="true"
                        Class="!flex-none"/>
                } else {
                    <Checkbox
                        IsChecked="@contact.IsChecked"
                        Class="!flex-none"
                        Change="@(_ => OnContactClick(contact))"/>
                }
            </div>
        }
    </div>
    </Body>
    <Buttons>
        <div class="btn-group">
            <Button
                Click="OnCancel"
                Class="btn-cancel">
                Cancel
            </Button>
            <Button
                Click="OnInvite"
                Type="@ButtonType.Submit"
                IsDisabled="@(!CanInvite)"
                Class="btn-primary">
                Invite
            </Button>
        </div>
    </Buttons>
</DialogFrame>

@code {
    private SearchBox _searchBoxRef = null!;

    [Inject] private Session Session { get; init; } = null!;
    [Inject] private IContacts Contacts { get; init; } = null!;
    [Inject] private IAuthors Authors { get; init; } = null!;
    [Inject] private IUserPresences UserPresences { get; init; } = null!;
    [Inject] private UICommander UICommander { get; init; } = null!;

    private Chat Chat => ModalModel.Chat; // Shortcut
    private string Filter { get; set; } = "";
    private Contact[] FilteredContacts { get; set; } = Array.Empty<Contact>();
    private Contact[] AllContacts { get; set; } = Array.Empty<Contact>();
    private bool CanInvite { get; set; }
    private CancellationTokenSource DisposeTokenSource { get; }
    private CancellationToken DisposeToken { get; }

    [CascadingParameter] public Modal Modal { get; set; } = null!;
    [Parameter] public Model ModalModel { get; set; } = null!;

    public InviteAuthorModal()
    {
        DisposeTokenSource = new();
        DisposeToken = DisposeTokenSource.Token;
    }

    protected override async Task OnInitializedAsync() {
        var existingUserIds = new HashSet<UserId>(
            await Authors.ListUserIds(Session, Chat.Id, DisposeToken));

        var userContacts = await Contacts.ListUserContacts(Session, DisposeToken);
        var contacts = await userContacts
            .Select(async c => {
                // Fine to use ConfigureAwait(false) here
                var account = c.Account;
                if (account == null)
                    return null;

                var presence = await UserPresences.Get(account.Id, DisposeToken).ConfigureAwait(false);
                return new Contact() {
                    Account = account,
                    Presence = presence,
                    IsExisting = existingUserIds.Contains(account.Id),
                };
            })
            .Collect(); // Add concurrency

        AllContacts = contacts
            .SkipNullItems()
            .OrderBy(x => x.Account.Avatar.Name)
            .ToArray();
        FilteredContacts = AllContacts;
    }

    protected override void OnAfterRender(bool firstRender) {
        if (firstRender)
            _ = _searchBoxRef.Focus();
    }

    public void Dispose()
        => DisposeTokenSource.Cancel();

    private void OnFilter(string filter) {
        Filter = filter;

        FilteredContacts = string.IsNullOrWhiteSpace(filter)
            ? AllContacts.ToArray()
            : AllContacts
                .Where(x => x.Account.Avatar.Name.OrdinalIgnoreCaseContains(filter))
                .ToArray();
    }

    private SearchMatch GetMatch(string text) {
        var searchPhrase = Filter.ToSearchPhrase(true, false);
        return searchPhrase.GetMatch(text);
    }

    private void OnContactClick(Contact contact) {
        if (contact.IsExisting)
            return;

        contact.IsChecked = !contact.IsChecked;
        CanInvite = AllContacts.Any(x => !x.IsExisting && x.IsChecked);
    }

    private async Task OnInvite() {
        CanInvite = false;

        var userIds = AllContacts
            .Where(x => !x.IsExisting && x.IsChecked)
            .Select(x => x.Account.Id)
            .ToArray();
        var createAuthorsCommand = new Authors_Invite(Session, Chat.Id, userIds);
        var (_, error) = await UICommander.Run(createAuthorsCommand, DisposeToken);
        if (error != null)
            return;

        Modal.Close();
    }

    private void OnCancel()
        => Modal.Close();

    // Nested types

    public sealed record Model(Chat Chat);

    private sealed class Contact {
        public Account Account { get; init; } = null!;
        public Presence Presence { get; init; }
        public bool IsExisting { get; init; }
        public bool IsChecked { get; set; }
    }
}
