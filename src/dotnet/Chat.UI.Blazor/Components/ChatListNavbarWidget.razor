@inherits ComputedStateComponent<ChatListNavbarWidget.Model>
@{
    var m = State.LatestNonErrorValue;
    var firstTabTitle = m.EnableIncompleteUI ? "All" : "Chats";
}

<NavbarGroup Title="Chats" Class="navbar-chats" Id="chats" AddClick="OnCreateNewChatClick">
    <ChildContent>
        <div class="flex-y w-full h-full">
            <TabPanel TabsClass="wide-left-panel-tabs" BottomHill="true">
                <Tab Title="@firstTabTitle" Class="-flex-y relative overflow-y-hidden h-full chats-tab">
                    <ListeningChatsNavbarWidget/>
                    <div class="overflow-x-hidden overflow-y-auto custom-scrollbar h-full flex-y my-2">
                        @if (m.PinnedChats.Count > 0) {
                            <ChatsTab ChatList="@m.PinnedChats" ActiveChatId="@m.ActiveChatId" Group="ChatsTab.ChatGroup.Pinned"/>

                            <div class="mx-4 mb-2 border-b border-bg-04"></div>

                            if (m.UnpinnedChats.Count > 0) {
                                <ChatsTab ChatList="@m.UnpinnedChats" ActiveChatId="@m.ActiveChatId" Group="ChatsTab.ChatGroup.Unpinned"/>
                            }
                        } else {
                            <ChatsTab ChatList="@m.UnpinnedChats" ActiveChatId="@m.ActiveChatId" Group="ChatsTab.ChatGroup.Unpinned"/>
                        }
                    </div>
                </Tab>
                @if (m.EnableIncompleteUI) {
                    <Tab Title="Family">
                        <ToBeDone/>
                    </Tab>
                    <Tab Title="Friends">
                        <ToBeDone/>
                    </Tab>
                    <Tab Title="Work">
                        <ToBeDone/>
                    </Tab>
                }
            </TabPanel>
        </div>
        <ChatMenu />
    </ChildContent>
</NavbarGroup>

@code {
    [Inject] private Session Session { get; init; } = null!;
    [Inject] private IAccounts Accounts { get; init; } = null!;
    [Inject] private IChats Chats { get; init; } = null!;
    [Inject] private ChatUI ChatUI { get; init; } = null!;
    [Inject] private ModalUI ModalUI { get; init; } = null!;
    [Inject] private SearchUI SearchUI { get; init; } = null!;
    [Inject] private Features Features { get; init; } = null!;

    protected override ComputedState<Model>.Options GetStateOptions()
        => new() {
            InitialValue = Model.None,
            UpdateDelayer = UpdateDelayer.MinDelay,
        };

    protected override async Task<Model> ComputeState(CancellationToken cancellationToken) {
        var account = await Accounts.Get(Session, cancellationToken).ConfigureAwait(false);
        if (!account.IsActive())
            return Model.None;

        var chats = await Chats.List(Session, cancellationToken).ConfigureAwait(false);

        var activeChatId = await ChatUI.ActiveChatId.Use(cancellationToken).ConfigureAwait(false);
        var parsedChatId = ParsedChatId.Parse(activeChatId);
        if (!parsedChatId.IsValid || parsedChatId.Kind != ChatIdKind.Group)
            activeChatId = Symbol.Empty; // We only display group chats here
        var activeChat = activeChatId.IsEmpty
            ? null
            : await Chats.Get(Session, activeChatId, cancellationToken).ConfigureAwait(false);
        if (activeChat == null)
            activeChatId = Symbol.Empty;
        else if (activeChat is { ChatType: ChatType.Group } && !chats.Any(c => c.Id == activeChat.Id))
            chats = chats.Add(activeChat);

        var keywords = await SearchUI.GetKeywords(cancellationToken).ConfigureAwait(false);
        if (keywords.Count > 0)
            chats = (
                from c in chats
                let rank = SearchUI.GetMatchRank(c.Title, keywords)
                where rank > 0 || c.Id == activeChatId
                orderby rank descending, c.Title
                select c
            ).ToImmutableArray();
        else
            chats = chats.OrderBy(c => c.Title).ToImmutableArray();

        var pinnedChatIds = await ChatUI.PinnedChatIds.Use(cancellationToken).ConfigureAwait(false);
        var pinnedChats = chats
            .Where(c => pinnedChatIds.ContainsKey(c.Id))
            .ToList();
        var unpinnedChats = chats
            .Where(c => !pinnedChatIds.ContainsKey(c.Id))
            .ToList();

        var listenedChatIds = await ChatUI.ListeningChatIds.Use(cancellationToken).ConfigureAwait(false);
        var listenedChats = new List<Chat>();
        foreach (var t in listenedChatIds) {
            var chat = await Chats.Get(Session, t, cancellationToken).ConfigureAwait(false);
            if (chat != null)
                listenedChats.Add(chat);
        }
        listenedChats.Reverse();

        var enableIncompleteUI = await Features.Get<UIFeatures.EnableIncompleteUI, bool>(cancellationToken).ConfigureAwait(false);

        return new Model {
            ActiveChatId = activeChatId,
            PinnedChats = pinnedChats,
            UnpinnedChats = unpinnedChats,
            ListenedChats = listenedChats,
            EnableIncompleteUI = enableIncompleteUI,
        };
    }

    private void OnCreateNewChatClick()
        => ModalUI.Show(new NewChatModal.Model());

    public sealed record Model {
        public static Model None { get; } = new();

        public Symbol ActiveChatId { get; init; }
        public List<Chat> PinnedChats { get; init; } = new ();
        public List<Chat> UnpinnedChats { get; init; } = new ();
        public List<Chat> ListenedChats { get; init; } = new ();
        public bool EnableIncompleteUI { get; init; }
    }
}
