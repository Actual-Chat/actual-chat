@using ActualChat.Chat.UI.Blazor.Events
@inherits ComputedStateComponent<ChatListNavbarWidget.Model>
@{
    var m = State.Value;
    var count = m.AllChats.Select(c => c.UnreadCount).Sum();
    var (title, icon) = _activeTabId switch
    {
        TabId.ByUnreadCount => ("Unread", "icon-sort-by-message"),
        TabId.ByOwnActivity => ("Recent", "icon-sort-by-recent"),
        _ => ("Updated", "icon-sort-by-alphabet"),
        };

    RenderFragment RenderTab(TabId tabId, string tabTitle) =>
        @<Tab
            Title="@tabTitle" Id="@tabId.ToString()"
            Class="chats-tab">
            <TitleContent>
                <span>@tabTitle</span>
                <UnreadCount Value="@count" Click="@OnUnreadBadgeClick"/>
            </TitleContent>
            <ChildContent>
                @if (_activeTabId == tabId) {
                    <div class="flex-y my-2">
                        <ChatList Kind="ChatListKind.Pinned" Chats="@m.PinnedChats"/>
                        <ChatList Kind="ChatListKind.Unpinned" Chats="@m.UnpinnedChats"/>
                    </div>
                }
            </ChildContent>
        </Tab>;
}

<OnUIEvent TEvent="@SelectSortingTypeEvent" Handler="OnSelectSortingTypeEvent" />
<NavbarGroup Title="Chats" Class="navbar-chats" Id="@NavbarGroupIds.Chats">
    <ChildContent>
        <div class="flex-y overflow-y-auto">
            <ActiveChatsNavbarWidget/>
            <div class="border-t-4 border-bg-04"></div>
            <TabPanel
                BottomHill="true"
                Class="md:overflow-y-hidden"
                TabsClass="left-panel-tabs"
                ActiveTabChanged="@OnActiveTabChanged">
                <AdditionalButton>
                    <ButtonRound Class="sort-btn btn-sm"
                                 data-menu="@(MenuRef.New<SortMenu>())"
                                 data-menu-trigger="@(MenuTriggers.Primary.Format())"
                                 data-menu-placement="@(FloatingPosition.BottomStart.ToPositionString())">
                        <i class="@icon text-2xl"></i>
                    </ButtonRound>
                </AdditionalButton>
                <ChildContent>
                    @RenderTab(_activeTabId, title )
                </ChildContent>
            </TabPanel>
        </div>
    </ChildContent>
</NavbarGroup>

@code {
    private TabId _activeTabId;

    [Inject] private Session Session { get; init; } = null!;
    [Inject] private ChatUI ChatUI { get; init; } = null!;
    [Inject] private ModalUI ModalUI { get; init; } = null!;
    [Inject] private SearchUI SearchUI { get; init; } = null!;
    [Inject] private LoadingUI LoadingUI { get; init; } = null!;
    [Inject] private NavigationManager Nav { get; init; } = null!;

    protected override ComputedState<Model>.Options GetStateOptions()
        => new() {
            InitialValue = Model.None,
            UpdateDelayer = FixedDelayer.Instant,
        };

    protected override async Task<Model> ComputeState(CancellationToken cancellationToken) {
        var chats = (await ListChats(_activeTabId)).ToList();

        var searchPhrase = await SearchUI.GetSearchPhrase(cancellationToken);
        if (!searchPhrase.IsEmpty) {
            var selectedChatId = await ChatUI.SelectedChatId.Use(cancellationToken);
            chats = (
                from c in chats
                let rank = searchPhrase.GetMatchRank(c.Chat.Title)
                where rank > 0 || c.Chat.Id == selectedChatId
                orderby c.Contact.IsPinned descending, rank descending
                select c
                ).ToList();
        }

        var pinnedChats = chats
            .TakeWhile(c => c.Contact.IsPinned)
            .ToList();
        var unpinnedChats = chats
            .Skip(pinnedChats.Count)
            .ToList();

        return new Model {
            PinnedChats = pinnedChats,
            UnpinnedChats = unpinnedChats,
        };
    }

    protected override void OnAfterRender(bool firstRender) {
        if (State.Value != Model.None)
            LoadingUI.MarkLoaded();
    }

    private Task<IReadOnlyList<ChatInfo>> ListChats(TabId tabId)
        => tabId switch {
            TabId.ByOwnActivity => ChatUI.List(ChatListOrder.ByOwnUpdateTime),
            TabId.ByAnyActivity => ChatUI.List(ChatListOrder.ByLastEventTime),
            TabId.ByUnreadCount => ChatUI.List(ChatListOrder.ByUnreadCount),
            _ => throw new ArgumentOutOfRangeException(nameof(tabId)),
        };

    private void OnActiveTabChanged(Tab? tab) {
        if (!Enum.TryParse(tab?.Id ?? "", out _activeTabId))
            _activeTabId = default;
        _ = State.Recompute();
    }

    private void OnUnreadBadgeClick() {
        var allChats = State.Value.AllChats;
        var firstUnreadChat = allChats.FirstOrDefault(c => c.UnmutedUnreadCount != 0);
        if (firstUnreadChat == null || firstUnreadChat.Chat.Id == ChatUI.SelectedChatId.Value)
            return;

        Nav.NavigateTo(Links.Chat(firstUnreadChat.Chat.Id));
    }

    private async Task OnSelectSortingTypeEvent(SelectSortingTypeEvent @event, CancellationToken cancellationToken) {
        var tabId = @event.TabId;
        _activeTabId = tabId;
        await State.Recompute(cancellationToken);
    }

    public enum TabId {
        ByOwnActivity,
        ByAnyActivity,
        ByUnreadCount,
    }

    public sealed record Model {
        private static List<ChatInfo> _emptyList = new();

        public static Model None { get; } = new();

        public List<ChatInfo> PinnedChats { get; init; } = _emptyList;
        public List<ChatInfo> UnpinnedChats { get; init; } = _emptyList;
        public IEnumerable<ChatInfo> AllChats => PinnedChats.Concat(UnpinnedChats);
    }
}
