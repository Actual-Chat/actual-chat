@using Stl.Extensibility
@using ActualChat.Contacts
@implements IModalView<InviteAuthor.Model>
@implements IDisposable
@attribute [MatchFor(typeof(Model), typeof(IModalView))]

<DialogFrame Class="invite-chat-author-modal" Title="Invite users" HasCloseButton="true">
    <Body>
    <div class="flex-y h-full w-full">
        <SearchBox
            @ref="_searchBoxRef"
            Class="mt-1"
            Placeholder="Find contacts..."
            MaxLength="@Constants.Chat.MaxSearchFilterLength"
            TextChanged="@OnFilter"/>
        <div class="flex-1 gap-y-1 mt-2 ml-1 mr-2 max-h-[60vh] min-h-[60vh] overflow-y-auto custom-scrollbar">
            @foreach (var contact in FilteredContacts) {
                <div class="flex-x items-center gap-x-2 w-full rounded-md pl-2 hover:bg-02"
                     @key="@contact.Account.Id"
                     @onclick="() => OnContactClick(contact)">
                    @if (contact.IsExisting) {
                        <Checkbox Checked="true" Disabled="true"/>
                    } else {
                        <Checkbox Checked="@contact.IsChecked"/>
                    }
                    <AvatarBadge
                        Avatar="@contact.Account.Avatar"
                        Presence="@contact.Presence"
                        Size="SquareSize.Size8"/>
                </div>
            }
        </div>
    </div>
    </Body>
    <Buttons>
        <div class="btn-group">
            <Button
                Click="OnCancel"
                Class="btn-outline">
                Cancel
            </Button>
            <Button
                Click="OnInvite"
                Type="@ButtonType.Submit"
                IsDisabled="@(!CanInvite)"
                Class="btn-primary">
                Invite
            </Button>
        </div>
    </Buttons>
</DialogFrame>

@code {
    private SearchBox _searchBoxRef = null!;

    [Inject] private Session Session { get; init; } = null!;
    [Inject] private IContacts Contacts { get; init; } = null!;
    [Inject] private IAccounts Accounts { get; init; } = null!;
    [Inject] private IAuthors Authors { get; init; } = null!;
    [Inject] private IUserPresences UserPresences { get; init; } = null!;
    [Inject] private UICommander UICommander { get; init; } = null!;

    private Chat Chat => ModalModel.Chat; // Shortcut
    private Contact[] FilteredContacts { get; set; } = Array.Empty<Contact>();
    private Contact[] AllContacts { get; set; } = Array.Empty<Contact>();
    private bool CanInvite { get; set; }
    private CancellationTokenSource DisposeTokenSource { get; }
    private CancellationToken DisposeToken { get; }

    [CascadingParameter] public BlazoredModalInstance ModalInstance { get; set; } = null!;
    [Parameter] public Model ModalModel { get; set; } = null!;

    public InviteAuthor()
    {
        DisposeTokenSource = new();
        DisposeToken = DisposeTokenSource.Token;
    }

    protected override async Task OnInitializedAsync() {
        var existingUserIds = new HashSet<Symbol>(
            await Authors.ListUserIds(Session, Chat.Id, DisposeToken));

        var userContacts = await Contacts.ListUserContacts(Session, DisposeToken);
        var contacts = await userContacts
            .Select(async c => {
                // Fine to use ConfigureAwait(false) here
                var account = c.Account!;
                var presence = await UserPresences.Get(account.Id, DisposeToken).ConfigureAwait(false);
                return new Contact() {
                    Account = account,
                    Presence = presence,
                    IsExisting = existingUserIds.Contains(account.Id),
                };
            })
            .Collect();

        AllContacts = contacts
            .OrderBy(x => x.Account.Avatar.Name)
            .ToArray();
        FilteredContacts = AllContacts;
    }

    protected override void OnAfterRender(bool firstRender) {
        if (firstRender)
            _ = _searchBoxRef.Focus();
    }

    public void Dispose()
        => DisposeTokenSource.Cancel();

    private void OnFilter(string filter) {
        FilteredContacts = string.IsNullOrWhiteSpace(filter)
            ? AllContacts.ToArray()
            : AllContacts
                .Where(x => x.Account.Avatar.Name.OrdinalIgnoreCaseContains(filter))
                .ToArray();
    }

    private void OnContactClick(Contact contact) {
        if (contact.IsExisting)
            return;

        contact.IsChecked = !contact.IsChecked;
        CanInvite = AllContacts.Any(x => !x.IsExisting && x.IsChecked);
    }

    private async Task OnInvite() {
        CanInvite = false;

        var userIds = AllContacts
            .Where(x => !x.IsExisting && x.IsChecked)
            .Select(x => x.Account.Id)
            .ToArray();
        var createAuthorsCommand = new IAuthors.CreateAuthorsCommand(Session, Chat.Id, userIds);
        var (_, error) = await UICommander.Run(createAuthorsCommand, DisposeToken);
        if (error != null)
            return;

        await ModalInstance.CloseAsync();
    }

    private Task OnCancel()
        => ModalInstance.CloseAsync();

    // Nested types

    public sealed record Model(Chat Chat);

    private sealed class Contact {
        public Account Account { get; init; } = null!;
        public Presence Presence { get; init; }
        public bool IsExisting { get; init; }
        public bool IsChecked { get; set; }
    }
}
