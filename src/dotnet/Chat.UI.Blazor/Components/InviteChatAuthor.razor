@using Stl.Extensibility
@implements IModalView<InviteChatAuthor.Model>
@implements IDisposable
@attribute [MatchFor(typeof(Model), typeof(IModalView))]

<DialogFrame Class="invite-chat-author-modal" Title="Invite users" HasCloseButton="true">
    <Body>
    <div class="flex-y h-full w-full">
        <SearchBox
            @ref="_searchBoxRef"
            Class="mt-1"
            Placeholder="Find contacts..."
            MaxLength="@Constants.Chat.MaxSearchFilterLength"
            TextChanged="@OnFilter"/>
        <div class="flex-1 gap-y-1 mt-2 ml-1 mr-2 max-h-[60vh] min-h-[60vh] overflow-y-auto custom-scrollbar">
            @foreach (var contact in FilteredContacts) {
                <div class="flex-x items-center gap-x-2 w-full rounded-md pl-2 hover:bg-02"
                     @key="@contact.Author.Id"
                     @onclick="() => OnContactClick(contact)">
                    @if (contact.IsExisting) {
                        <Checkbox Checked="true" Disabled="true"/>
                    } else {
                        <Checkbox Checked="@contact.IsChecked"/>
                    }
                    <AuthorBadge
                        Author="@contact.Author"
                        Presence="@contact.Presence"
                        Size="SquareSize.Size8"/>
                </div>
            }
        </div>
    </div>
    </Body>
    <Buttons>
        <div class="btn-group">
            <Button
                Click="OnCancel"
                Class="btn-outline">
                Cancel
            </Button>
            <Button
                Click="OnInvite"
                Type="@ButtonType.Submit"
                IsDisabled="@(!CanInvite)"
                Class="btn-primary">
                Invite
            </Button>
        </div>
    </Buttons>
</DialogFrame>

@code {
    private SearchBox _searchBoxRef;

    [Inject] private Session Session { get; init; } = null!;
    [Inject] private IUserContacts UserContacts { get; init; } = null!;
    [Inject] private IAccounts Accounts { get; init; } = null!;
    [Inject] private IChatAuthors ChatAuthors { get; init; } = null!;
    [Inject] private IUserPresences UserPresences { get; init; } = null!;
    [Inject] private UICommander UICommander { get; init; } = null!;

    [CascadingParameter] public BlazoredModalInstance ModalInstance { get; set; } = null!;
    [Parameter] public Model ModalModel { get; set; } = null!;

    private Contact[] FilteredContacts { get; set; } = Array.Empty<Contact>();
    private Contact[] AllContacts { get; set; } = Array.Empty<Contact>();
    private bool CanInvite { get; set; }
    private CancellationTokenSource DisposeTokenSource { get; } = new();

    protected override async Task OnInitializedAsync() {
        var existingChatUserIds = new HashSet<Symbol>(
            await ChatAuthors.ListUserIds(Session, ModalModel.Chat.Id, DisposeTokenSource.Token));

        var contacts = await UserContacts.List(Session, DisposeTokenSource.Token);
        var resolvedContacts = await contacts
            .Select(async userContact => {
                // Default scheduler is used from here (in this block)
                var userAuthor = await Accounts.GetUserAuthor(userContact.TargetUserId, DisposeTokenSource.Token).ConfigureAwait(false);
                if (userAuthor == null)
                    return null;

                if (string.IsNullOrWhiteSpace(userAuthor.Picture)) {
                    userAuthor = userAuthor with {
                        Picture = $"https://avatars.dicebear.com/api/avataaars/{userAuthor.Name}.svg",
                    };
                }

                var presence = await UserPresences.Get(userContact.TargetUserId, DisposeTokenSource.Token).ConfigureAwait(false);
                return new Contact(userAuthor, presence, existingChatUserIds.Contains(userAuthor.Id));
            })
            .Collect();

        AllContacts = resolvedContacts
            .SkipNullItems()
            .OrderBy(x => x.Author.Name)
            .ToArray();
        FilteredContacts = AllContacts;
    }

    protected override void OnAfterRender(bool firstRender) {
        if (firstRender)
            _ = _searchBoxRef.Focus();
    }

    public void Dispose()
        => DisposeTokenSource.Cancel();

    private void OnFilter(string filter) {
        FilteredContacts = string.IsNullOrWhiteSpace(filter)
            ? AllContacts.ToArray()
            : AllContacts
                .Where(x => x.Author.Name.OrdinalIgnoreCaseContains(filter))
                .ToArray();
    }

    private void OnContactClick(Contact contact) {
        if (contact.IsExisting)
            return;

        contact.IsChecked = !contact.IsChecked;
        CanInvite = AllContacts.Any(x => !x.IsExisting && x.IsChecked);
    }

    private async Task OnInvite() {
        CanInvite = false;

        var userIds = AllContacts
            .Where(x => !x.IsExisting && x.IsChecked)
            .Select(x => x.Author.Id.Value)
            .ToArray();
        var createChatAuthorsCommand = new IChatAuthors.CreateChatAuthorsCommand(Session, ModalModel.Chat.Id, userIds);
        await UICommander.Run(createChatAuthorsCommand, DisposeTokenSource.Token);
        await ModalInstance.CloseAsync();
    }

    private Task OnCancel()
        => ModalInstance.CancelAsync();

    // Nested types

    public sealed record Model(Chat Chat);

    private sealed class Contact {
        public UserAuthor Author { get; }
        public bool IsExisting { get; }
        public Presence Presence { get; }
        public bool IsChecked { get; set; }

        public Contact(UserAuthor author, Presence presence, bool isExisting) {
            Author = author;
            Presence = presence;
            IsExisting = isExisting;
            IsChecked = isExisting;
        }
    }
}
