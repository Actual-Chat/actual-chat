@namespace ActualChat.Chat.UI.Blazor.Components
@using ActualChat.Contacts
@using ActualChat.Search
@inherits FusionComponentBase
@implements IDisposable

@{
    _viewSettings.CanSubmit = CanInvite;
}

<FormBlock>
    <SearchBox
        @ref="_searchBoxRef"
        Placeholder="Find contacts..."
        MaxLength="@Constants.Chat.MaxSearchFilterLength"
        TextChanged="@OnFilter"/>
    <div class="c-contact-list">
        @foreach (var contact in FilteredContacts) {
            <div class="c-item"
                 @key="@contact.Account.Id.Value"
                 @onclick="@(_ => OnContactClick(contact))">
                <AccountCircle UserSid="@contact.Account.Id" ShowPresence="true"/>
                <div class="avatar-name">
                    <SearchMatchHighlighter Match="@GetMatch(contact.Account.Avatar.Name)"/>
                </div>
                @if (contact.IsExisting) {
                    <Checkbox
                        IsChecked="true"
                        IsDisabled="true"
                        Class="!flex-none"/>
                } else {
                    <Checkbox
                        IsChecked="@contact.IsChecked"
                        Class="!flex-none"
                        Change="@(_ => OnContactClick(contact))"/>
                }
            </div>
        }
    </div>
</FormBlock>

<RenderIntoSlot Name="@ButtonsSlotName">
    <Button
        Click="OnCancel"
        Class="btn-cancel btn-modal">
        Cancel
    </Button>
    <Button
        Click="OnAdd"
        Type="@ButtonType.Submit"
        IsDisabled="@(!CanInvite)"
        Class="btn-primary btn-modal">
        Add
    </Button>
</RenderIntoSlot>

@code {
    public const string ButtonsSlotName = "AddMemberContent-PageButtons";

    private SearchBox _searchBoxRef = null!;
    private DialogFrameNarrowViewSettings _viewSettings = null!;
    private bool _canInvite;

    [Inject] private Session Session { get; init; } = null!;
    [Inject] private IContacts Contacts { get; init; } = null!;
    [Inject] private IAuthors Authors { get; init; } = null!;
    [Inject] private IUserPresences UserPresences { get; init; } = null!;
    [Inject] private UICommander UICommander { get; init; } = null!;

    private ChatId ChatId { get; set; } // Shortcut
    private string Filter { get; set; } = "";
    private Contact[] FilteredContacts { get; set; } = Array.Empty<Contact>();
    private Contact[] AllContacts { get; set; } = Array.Empty<Contact>();
    private CancellationTokenSource DisposeTokenSource { get; } = new ();
    private CancellationToken DisposeToken => DisposeTokenSource.Token;

    private bool CanInvite {
        get => _canInvite;
        set {
            if (_canInvite == value)
                return;
            _canInvite = value;
            InvokeStateHasChanged?.Invoke();
            Context?.StateHasChanged();
        }
    }

    [Parameter, EditorRequired] public string ChatSid { get; set; } = "";
    [Parameter, EditorRequired] public EventCallback Close { get; set; }
    [Parameter] public DiveInModalPageContext? Context { get; set; }
    [Parameter] public Action? InvokeStateHasChanged { get; set; }

    public DialogFrameNarrowViewSettings NarrowViewSettings
        => _viewSettings;

    protected override async Task OnInitializedAsync() {
        ChatId = new ChatId(ChatSid);
        _viewSettings = DialogFrameNarrowViewSettings.SubmitButton(OnAdd, "Add");
        if (Context != null)
            Context.NarrowViewSettings = _viewSettings;
        var existingUserIds = new HashSet<UserId>(
            await Authors.ListUserIds(Session, ChatId, DisposeToken));

        var userContacts = await Contacts.ListUserContacts(Session, DisposeToken);
        var contacts = await userContacts
            .Select(async c => {
                // Fine to use ConfigureAwait(false) here
                var account = c.Account;
                if (account == null)
                    return null;

                var presence = await UserPresences.Get(account.Id, DisposeToken).ConfigureAwait(false);
                return new Contact() {
                    Account = account,
                    Presence = presence,
                    IsExisting = existingUserIds.Contains(account.Id),
                };
            })
            .Collect(); // Add concurrency

        AllContacts = contacts
            .SkipNullItems()
            .OrderBy(x => x.Account.Avatar.Name)
            .ToArray();
        FilteredContacts = AllContacts;
    }

    protected override void OnAfterRender(bool firstRender) {
        if (firstRender)
            _ = _searchBoxRef.Focus();
    }

    public void Dispose()
        => DisposeTokenSource.Cancel();

    private void OnFilter(string filter) {
        Filter = filter;

        FilteredContacts = string.IsNullOrWhiteSpace(filter)
            ? AllContacts.ToArray()
            : AllContacts
                .Where(x => x.Account.Avatar.Name.OrdinalIgnoreCaseContains(filter))
                .ToArray();
    }

    private SearchMatch GetMatch(string text) {
        var searchPhrase = Filter.ToSearchPhrase(true, false);
        return searchPhrase.GetMatch(text);
    }

    private void OnContactClick(Contact contact) {
        if (contact.IsExisting)
            return;

        contact.IsChecked = !contact.IsChecked;
        CanInvite = AllContacts.Any(x => !x.IsExisting && x.IsChecked);
    }

    private async Task OnAdd() {
        CanInvite = false;

        var userIds = AllContacts
            .Where(x => !x.IsExisting && x.IsChecked)
            .Select(x => x.Account.Id)
            .ToArray();
        var createAuthorsCommand = new Authors_Invite(Session, ChatId, userIds);
        var (_, error) = await UICommander.Run(createAuthorsCommand, DisposeToken);
        if (error != null)
            return;

        await Close.InvokeAsync();
    }

    private async Task OnCancel()
        => await Close.InvokeAsync();

    // Nested types

    private sealed class Contact {
        public Account Account { get; init; } = null!;
        public Presence Presence { get; init; }
        public bool IsExisting { get; init; }
        public bool IsChecked { get; set; }
    }
}
