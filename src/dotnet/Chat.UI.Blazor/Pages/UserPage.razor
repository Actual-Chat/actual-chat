@page "/u/{UserId}"
@using ActualChat.Contacts
@inherits ComputedStateComponent<UserPage.Model>
@{
    var m = State.LatestNonErrorValue;
    var account = m.Account;
    if (!Account.MustExist.IsSatisfied(account)) {
        if (ReferenceEquals(m, Model.None)) {
            <RequireOtherAccount UserId="@UserId" />
            return;
        }
        // Model isn't loaded yet
        return;
    }
}

<RequireAccount/>
<MainHeader>
    <span>User:&nbsp;</span>
    <span class="text-01">@account.Avatar.Name</span>
</MainHeader>

<div class="user-info_badge">
    <AccountCircle UserId="@UserId" Size="SquareSize.Size12" ShowPresence="true" />
    <AccountName UserId="@UserId" Class="text-02 font-semibold text-lg"/>
</div>

@if (m.CanAddContact || m.CanPeerChat) {
    <div class="user-info_buttons">
        <div class="btn-group btn-group-font-normal">
            @if (m.CanAddContact) {
                <Button Class="btn-primary" Click="OnAddContactClick" IsDisabled="@IsAddingContact">Add to Contacts</Button>
            }
            @if (m.CanPeerChat) {
                <Button Class="btn-primary" Click="OnSendMessageClick">Send Message</Button>
            }
        </div>
    </div>
}

<h4 class="section section-top">Link to this page</h4>
<UserPageLink/>

@code {
    [Inject] public Session Session { get; init; } = null!;
    [Inject] public IAccounts Accounts { get; init; } = null!;
    [Inject] private IChats Chats { get; init; } = null!;
    [Inject] private IContacts Contacts { get; init; } = null!;
    [Inject] private NavigationManager Nav { get; init; } = null!;
    [Inject] private UICommander UICommander { get; init; } = null!;

    private bool IsAddingContact { get; set; }

    [Parameter] public string UserId { get; set; } = "";

    protected override ComputedState<Model>.Options GetStateOptions()
        => new() {
            InitialValue = Model.Loading,
            UpdateDelayer = FixedDelayer.Instant,
        };

    protected override async Task<Model> ComputeState(CancellationToken cancellationToken) {
        var account = await Accounts.Get(Session, UserId, cancellationToken);
        if (account == null)
            return Model.None;

        var contactIds = await Contacts.ListIds(Session, cancellationToken).ConfigureAwait(false);
        var canAddToContacts = !contactIds.Any(cid => cid.IsUserContact(out var userId) && userId == account.Id);
        return new Model {
            Account = account,
            CanAddContact = canAddToContacts,
            CanPeerChat = true,
        };
    }

    private async Task OnAddContactClick() {
        if (IsAddingContact)
            return;

        IsAddingContact = true;
        StateHasChanged();
        try {
            var ownAccount = await Accounts.GetOwn(Session, default).Require();
            var account = await Accounts.Get(Session, UserId, default).Require();
            var contactId = new ContactId(ownAccount.Id, account.Id, ContactKind.User);
            var command = new IContacts.ChangeCommand(Session, contactId, null, new Change<Contact>() {
                Create = new Contact(contactId),
            });
            await UICommander.Run(command);
        }
        finally {
            IsAddingContact = false;
            StateHasChanged();
        }
    }

    private void OnSendMessageClick() {
        var peerChatId = ChatId.FormatShort(UserId);
        Nav.NavigateTo(Links.ChatPage(peerChatId));
    }

    // Nested types

    public sealed record Model {
        public static Model None { get; } = new();
        public static Model Loading { get; } = new() { Account = Account.Loading }; // Should differ by ref. from None

        public Account Account { get; init; } = Account.None;
        public bool CanAddContact { get; init; }
        public bool CanPeerChat { get; init; }
    }
}
