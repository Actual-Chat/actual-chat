@page "/chat"
@page "/chat/{ChatId}"
@page "/direct/{ContactId}"
@using ActualChat.Notification.UI.Blazor
@inherits ComputedStateComponent<ChatPage.Model>
@layout ChatPageLayout
@attribute [Authorize(Policy = KnownPolicies.IsUserActive)]
@{
    var m = _lastRenderedModel = State.LatestNonErrorValue;
    var error = State.Error;
    if (m.IsUnavailable)
        Nav.Unavailable("chat");
    if (m.MustLogin)
        Nav.Login("to view this chat");
    var chat = m.Chat;
}

@if (error != null) {
    <WhenError Error="error"/>
} else if (chat != null) {
    @* @key=... ensures child components are recreated on navigation to another chat *@
    <RenderIntoSlot Name="MainHeader" @key="@(chat.Id + "-header")">
        <CascadingValue Value="chat">
            <ChatHeader/>
        </CascadingValue>
    </RenderIntoSlot>

    <RenderIntoSlot Name="SubHeader" @key="@(chat.Id + "-sub-header")">
        <CascadingValue Value="chat">
            <UnreadMessagesHeader Click="@OnUnreadMessagesClick"/>
        </CascadingValue>
    </RenderIntoSlot>

    <RenderIntoSlot Name="MainFooter" @key="@(chat.Id + "-footer")">
        <CascadingValue Value="chat">
            <ChatFooter/>
        </CascadingValue>
    </RenderIntoSlot>

    if (m.IsRightPanelVisible) {
        <RenderIntoSlot Name="MainRightPanel" @key="@(chat.Id + "-right-panel")">
            <CascadingValue Value="chat">
                <ChatRightPanel/>
            </CascadingValue>
        </RenderIntoSlot>
    }

    <NoComponent @key="chat.Id">
        <CascadingValue Value="chat">
            <ChatView @ref="_chatView" />
            <HistoricalPlaybackPanel/>
        </CascadingValue>
    </NoComponent>
} else {
    <div>Loading...</div>
}

@code {
    private Model? _lastRenderedModel;
    private IComputed? _activeChatIdComputed;
    private ChatView _chatView = null!;

    [Inject] private Session Session { get; init; } = null!;
    [Inject] private IChats Chats { get; init; } = null!;
    [Inject] private ChatUI ChatUI { get; init; } = null!;
    [Inject] private RightPanelUI RightPanelUI { get; init; } = null!;
    [Inject] private NavigationManager Nav { get; init; } = null!;
    [Inject] private DeviceInfo DeviceInfo { get; init; } = null!;

    [Parameter] public string ChatId { get; set; } = "";
    [Parameter] public string ContactId { get; set; } = "";

    protected override void OnParametersSet() {
        base.OnParametersSet();
        ChatUI.ActiveChatId.Value = ChatId;
        _activeChatIdComputed = ChatUI.ActiveChatId.Computed;
    }

    protected override bool ShouldRender()
        => ReferenceEquals(_lastRenderedModel, null)
            || !ReferenceEquals(_lastRenderedModel, State.LatestNonErrorValue);

    protected override Task OnAfterRenderAsync(bool firstRender) {
        if (!firstRender)
            return Task.CompletedTask;

        _ = DeviceInfo.EnsureDeviceRegistered(CancellationToken.None);
        return Task.CompletedTask;
    }

    protected override ComputedState<Model>.Options GetStateOptions()
        => new() {
            InitialValue = Model.None,
            UpdateDelayer = UpdateDelayer.ZeroDelay,
        };

    protected override async Task<Model> ComputeState(CancellationToken cancellationToken) {
        Chat? chat = null;
        if (!ChatId.IsNullOrEmpty())
            chat = await Chats.Get(Session, ChatId, cancellationToken).ConfigureAwait(true);
        if (chat == null)
            return new () { IsUnavailable = true };
        var isRightPanelVisible = await RightPanelUI.IsVisible.Use(cancellationToken);

        // We want to return the same Chat instance while it stays unchanged
        var renderedChat = _lastRenderedModel?.Chat;
        var isTheSameChat = renderedChat != null && renderedChat.Id == chat.Id && renderedChat.Version == chat.Version;
        return new () {
            Chat = isTheSameChat ? renderedChat : chat,
            IsRightPanelVisible = isRightPanelVisible,
        };
    }

    public override async ValueTask DisposeAsync() {
        await base.DisposeAsync();
        _ = BackgroundTask.Run(async () => {
            await Task.Delay(TimeSpan.FromMilliseconds(50)).ConfigureAwait(false);
            // We want to avoid unnecessarily frequent ActiveChatId changes
            // (to Symbol.Empty on disposal & back on the next render)
            if (ChatUI.ActiveChatId.Computed == _activeChatIdComputed)
                ChatUI.ActiveChatId.Value = Symbol.Empty;
        });
    }

    private void OnUnreadMessagesClick()
        => _ = _chatView.NavigateToUnreadEntry();

    public sealed record Model {
        public static Model None { get; } = new();

        public bool IsUnavailable { get; init; }
        public bool MustLogin { get; init; }
        public bool IsRightPanelVisible { get; init; }
        public Chat? Chat { get; init; }
    }
}
