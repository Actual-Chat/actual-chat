@page "/chat/{ChatSid}"
@page "/chat"
@using System.Diagnostics.CodeAnalysis
@inherits ComputedStateComponent<ChatPage.Model>
@layout ListViewLayout
@{
    var m = _rendered = State.Value;
    var chat = m.Chat;
    var hasChat = !m.Chat.Id.IsNone;
    // Log.LogDebug("Rendered for #{ChatId}", m.ChatId);
}

<AutoNavigateOnSignIn SourceUrl="@Links.Chats" TargetUrl="@Links.Chats" />

<RenderIntoSlot Name="MainHeader">
    <ChatHeader/>
</RenderIntoSlot>

<RenderIntoSlot Name="MainFooter">
    <ChatFooter/>
</RenderIntoSlot>

<RenderIntoStack Name="SubHeader" Order="1000_000" Key="BannersSubHeader">
    @if (hasChat) {
        <Banners Chat="@chat"/>
    }
</RenderIntoStack>

<RenderIntoSlot Name="MainRightDrawer">
    @if (hasChat) {
        <ChatRightPanel Chat="@chat"/>
    }
</RenderIntoSlot>

@if (ReferenceEquals(chat, SpecialChat.Loading)) {
    <chat-view-skeleton count="15" />
    return;
}
@if (ReferenceEquals(chat, SpecialChat.NoChatSelected)) {
    <NoChatSelected/>
} else if (ReferenceEquals(chat, SpecialChat.Unavailable)) {
    <ChatNotFound ShowSignIn="@(!m.Account.IsActive())"/>
} else {
    <ChatView @ref="_chatViewRef" Chat="@chat" @key="@ChatSid" />
}

@code {
    private Model? _rendered;
    private ChatView _chatViewRef = null!;
    private bool _isFirstLoad = true;

    [Inject] private Session Session { get; init; } = null!;
    [Inject] private IAccounts Accounts { get; init; } = null!;
    [Inject] private IChats Chats { get; init; } = null!;
    [Inject] private ChatUI ChatUI { get; init; } = null!;
    [Inject] private ChatAudioUI ChatAudioUI { get; init; } = null!;
    [Inject] private BrowserInfo BrowserInfo { get; init; } = null!;
    [Inject] private ILogger<ChatPage> Log { get; init; } = null!;

    [Parameter] public string? ChatSid { get; set; }

    protected override void OnInitialized() {
        // Force chat selection from Url before ComputeState starts working
        var chatId = new ChatId(ChatSid ?? "", ParseOrNone.Option);
        ChatUI.SelectChat(chatId);
        ChatAudioUI.Enable();

        base.OnInitialized();
    }

    protected override ComputedState<Model>.Options GetStateOptions()
        => new() {
            InitialValue = Model.Loading,
            Category = GetStateCategory(),
        };

    protected override Task OnParametersSetAsync() {
        var chatId = new ChatId(ChatSid ?? "", ParseOrNone.Option);
        ChatUI.SelectChat(chatId);

        // No need to call base.OnParametersSetAsync() here, coz
        // ChatUI.SelectChat(...) triggers UICommander.RunNothing() anyway
        return Task.CompletedTask;
    }

    protected override async Task<Model> ComputeState(CancellationToken cancellationToken) {
        // We intentionally use ChatUI.SelectedChatId rather than ChatSid here,
        // coz OnSetParametersAsync anyway propagates ChatSid to SelectedChatId,
        // and moreover, we want to make sure ComputeState gets invalidated
        // specifically when SelectedChatId changes (vs when ChatSid changes).

        // var computed = Computed.GetCurrent()!;
        // computed.Invalidated += c => {
        //     Log.LogDebug("Invalidated: {Computed}", c.DebugDump());
        // };
        try {
            var chatId = await ChatUI.SelectedChatId.Use(cancellationToken);
            // Log.LogDebug("ComputeState(), ChatId: #{ChatId}", chatId);

            var screenSize = await BrowserInfo.ScreenSize.Use(cancellationToken);
            // Let's delay chat loading when it it is invisible and it happens for the first time
            if (_isFirstLoad) {
                _isFirstLoad = false;
                if (screenSize.IsNarrow()) {
                    var panelsUI = Services.GetRequiredService<PanelsUI>();
                    if (panelsUI.Left.IsVisible.Value) {
                        Log.LogDebug("Delay loading for chat #{ChatId}", chatId);
                        await Task.Delay(TimeSpan.FromSeconds(0.75), cancellationToken);
                    }
                }
            }

            var account = await Accounts.GetOwn(Session, cancellationToken);
            try {
                var chat = SpecialChat.NoChatSelected;
                if (!chatId.IsNone) {
                    chat = await Chats.Get(Session, chatId, cancellationToken);
                    chat ??= SpecialChat.Unavailable;
                }
                return new Model(chat, account, screenSize);
            }
            catch (Exception e) when (e is not OperationCanceledException) {
                Log.LogWarning(e, "Failed to get Chat #{ChatId}", chatId);
                return new Model(SpecialChat.Unavailable, account, screenSize);
            }
        }
        finally {
            // Log.LogDebug("ComputeState() - exit: {Computed}", computed.DebugDump());
        }
    }

    protected override bool ShouldRender()
        => ReferenceEquals(_rendered, null)
            || State.HasError
            || !State.Value.IsIdenticalTo(_rendered);

    // Nested types

    public sealed record Model(
        Chat Chat,
        AccountFull Account,
        ScreenSize ScreenSize = ScreenSize.Unknown
    ) {
        public static Model Loading { get; } = new(SpecialChat.Loading, AccountFull.Loading);

        public bool IsIdenticalTo([NotNullWhen(true)] Model? other) {
            if (other == null)
                return false;

            return ReferenceEquals(Chat, other.Chat)
               && ReferenceEquals(Account, other.Account)
               && ScreenSize == other.ScreenSize;
        }
    }
}
