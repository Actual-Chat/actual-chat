@page "/chat"
@page "/chat/{ChatId}"
@page "/direct/{ContactId}"
@inherits ComputedStateComponent<ChatPage.Model>
@inject Session _session
@inject IAuth _auth
@inject IChats _chats
@inject NavigationManager _nav
@inject ChatController _controller

@{
    _lastRenderedModel = State.LatestNonErrorValue ?? new();
    var model = _lastRenderedModel;
    var error = State.Error;
    if (model.IsUnavailable)
        _nav.Unavailable("chat");
    if (model.MustLogin)
        _nav.Login("to view this chat");
    var chat = model.Chat;
}

@if (error != null) {
    <WhenError Error="error"/>
} else if (chat != null) {
    @* @key=... ensures child components are recreated on navigation to another chat *@
    <PageWithHeaderAndFooter @key="chat.Id" Class="chat-page">
        <Header>
            <CascadingValue Value="chat">
                <div class="flex flex-row justify-end md:justify-between mt-0 font-medium bg-primary md:bg-secondary text-primary py-2 px-3 select-none border-b border-accent z-10">
                    <NavbarIcon/>
                    <ChatHeader/>
                    <ChatActivityPanel/>
                </div>
                <div class="w-full flex justify-center px-2">
                    <ChatHeaderPanel/>
                </div>
            </CascadingValue>
        </Header>
        <Body>
            <CascadingValue Value="chat">
                <ChatView/>
                <HistoricalPlaybackPanel/>
            </CascadingValue>
        </Body>
        <Footer>
            <CascadingValue Value="chat">
                <ChatFooter AutoJoin="@AutoJoin"/>
            </CascadingValue>
        </Footer>
    </PageWithHeaderAndFooter>
} else {
    <div>Loading...</div>
}

@code {
    public const string AutoJoinQueryParameter = "auto-join";

    private Model? _lastRenderedModel;

    [Parameter] public string ChatId { get; set; } = "";
    [Parameter] public string ContactId { get; set; } = "";
    [Parameter, SupplyParameterFromQuery(Name = AutoJoinQueryParameter)]
    public string? AutoJoin { get; set; }

    protected override bool ShouldRender()
        => ReferenceEquals(_lastRenderedModel, null)
            || !ReferenceEquals(_lastRenderedModel, State.LatestNonErrorValue);

    protected override async Task<Model> ComputeState(CancellationToken cancellationToken) {
        Chat? chat = null;
        if (!string.IsNullOrEmpty(ChatId))
            chat = await _chats.Get(_session, ChatId, cancellationToken).ConfigureAwait(true);
        else if (!string.IsNullOrEmpty(ContactId))
            chat = await _chats.GetDirectChat(_session, ContactId, cancellationToken).ConfigureAwait(true);
        if (chat == null)
            return new () { IsUnavailable = true };

        // We want to return the same Chat instance while it stays unchanged
        var renderedChat = _lastRenderedModel?.Chat;
        if (renderedChat != null && renderedChat.Id == chat.Id && renderedChat.Version == chat.Version)
            return _lastRenderedModel!;
        return new () { Chat = chat };
    }

    protected override void OnParametersSet() {
        base.OnParametersSet();
        _controller.SetActiveChatId(ChatId);
    }

    public override async ValueTask DisposeAsync() {
        if (ChatId == await _controller.GetActiveChatId()) {
            _controller.SetActiveChatId("");
        }
        await base.DisposeAsync();
    }

    public record Model {
        public bool IsUnavailable { get; init; }
        public bool MustLogin { get; init; }
        public Chat? Chat { get; init; }
    }
}
