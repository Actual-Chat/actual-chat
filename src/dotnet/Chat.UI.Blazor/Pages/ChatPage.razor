@page "/chat/{ChatSid}"
@page "/chat"
@using System.Diagnostics.CodeAnalysis
@inherits ComputedStateComponent<ChatPage.Model>
@layout ListViewLayout
@{
    var m = _rendered = State.Value;
    var chat = m.Chat;
    var chatOrNone = m.Chat ?? Chat.None;
    var chatOrLoading = ReferenceEquals(m, Model.Loading) ? Chat.Loading : chatOrNone;
}

@* @key=...below ensures child components are recreated on navigation to another chat *@

<RenderIntoSlot Name="MainHeader">
    <CascadingValue Value="@chatOrLoading">
        <ChatHeader/>
    </CascadingValue>
</RenderIntoSlot>

<RenderIntoStack Name="SubHeader" Order="1000_000" Key="BannersSubHeader">
    @if (chat != null) {
        <CascadingValue Value="@chat">
            <Banners/>
        </CascadingValue>
    }
</RenderIntoStack>

<RenderIntoSlot Name="MainRightDrawer">
    @if (chat != null) {
        <CascadingValue Value="@chat">
            <ChatRightPanel/>
        </CascadingValue>
    }
</RenderIntoSlot>

<RenderIntoSlot Name="MainFooter">
    <CascadingValue Value="@chatOrLoading">
        <ChatFooter/>
    </CascadingValue>
</RenderIntoSlot>

@if (ReferenceEquals(m, Model.Loading)) {
    return;
}
@if (m.ChatId.IsNone) {
    <NoChatSelected/>
} else if (chat == null) {
    <ChatNotFound ShowSignIn="@(!m.Account.IsActive())"/>
} else {
    <CascadingValue Value="chat" @key="chat.Id.Value">
        <ChatView @ref="_chatViewRef" />
    </CascadingValue>
}

@code {
    private Model? _rendered;
    private ChatView _chatViewRef = null!;
    private bool _canRedirectToAnnouncementsChat = true;

    [Inject] private Session Session { get; init; } = null!;
    [Inject] private IAccounts Accounts { get; init; } = null!;
    [Inject] private IChats Chats { get; init; } = null!;
    [Inject] private ChatUI ChatUI { get; init; } = null!;
    [Inject] private ChatAudioUI ChatAudioUI { get; init; } = null!;
    [Inject] private OnboardingUI OnboardingUI { get; init; } = null!;
    [Inject] private AutoNavigationUI AutoNavigationUI { get; init; } = null!;
    [Inject] private NavbarUI NavbarUI { get; init; } = null!;
    [Inject] private HistoryUI HistoryUI { get; init; } = null!;
    [Inject] private BrowserInfo BrowserInfo { get; init; } = null!;
    [Inject] private ILogger<ChatPage> Log { get; init; } = null!;

    [Parameter] public string? ChatSid { get; set; }

    protected override bool ShouldRender()
        => ReferenceEquals(_rendered, null)
            || State.HasError
            || !ReferenceEquals(_rendered, State.Value);

    protected override Task OnInitializedAsync() {
        AutoNavigationUI.MustNavigateToChatsOnSignIn = false;
        ChatAudioUI.Enable();
        return ChatUI.WhenLoaded; // Nothing happens until we load everything
    }

    protected override async Task OnParametersSetAsync() {
        var chatSid = ChatSid ?? "";
        var chatId = new ChatId(chatSid, ParseOrNone.Option);
        if (chatSid == "") {
            await ChatUI.WhenLoaded;
            chatId = ChatUI.SelectedChatId.Value;
            if (chatId.IsNone && _canRedirectToAnnouncementsChat) {
                _canRedirectToAnnouncementsChat = false;
                chatId = Constants.Chat.AnnouncementsChatId;
            }
            if (!chatId.IsNone)
                HistoryUI.NavigateTo(Links.Chat(chatId));
        }

        ChatUI.SelectChat(chatId);
        // No need to call base.OnParametersSetAsync() here, coz
        // FixChatId calls ChatUI.SelectChat(...), which triggers
        // UICommander.RunNothing() anyway
    }

    protected override ComputedState<Model>.Options GetStateOptions()
        => new() {
            InitialValue = Model.Loading,
            Category = GetStateCategory(),
        };

    protected override async Task<Model> ComputeState(CancellationToken cancellationToken) {
        var model = await ComputeStateInternal(cancellationToken);

        // Ideally we want to return exactly the same model as it was last time,
        // coz otherwise some of components depending on its internals (e.g. lots of them depend on Chat)
        // re-render solely because the reference to it was changed.
        return model.IsIdenticalTo(_rendered) ? _rendered : model;
    }

    private async Task<Model> ComputeStateInternal(CancellationToken cancellationToken)
    {
        // We intentionally use ChatUI.SelectedChatId rather than ChatSid here,
        // coz OnSetParametersAsync anyway propagates ChatSid to SelectedChatId,
        // and moreover, we want to make sure ComputeState gets invalidated
        // specifically when SelectedChatId changes, not when ChatSid changes.

        var chatId = await ChatUI.SelectedChatId.Use(cancellationToken);
        var screenSize = await BrowserInfo.ScreenSize.Use(cancellationToken);
        if (chatId.IsNone) // Kinda weird case: this should never happen due to code in OnParametersSetAsync
            return Model.None(screenSize);

        var account = await Accounts.GetOwn(Session, cancellationToken);
        try {
            var chat = await Chats.Get(Session, chatId, cancellationToken);
            return new Model(chatId, chat, account, screenSize);
        }
        catch (Exception e) when (e is not OperationCanceledException) {
            Log.LogWarning(e, "Failed to get Chat #{ChatId}", chatId);
            return new Model(chatId, null, account, screenSize);
        }
    }

    // Event handlers

    private void OnUnreadCountSubHeaderClick()
        => _ = _chatViewRef.NavigateToUnreadEntry();

    // Nested types

    public sealed record Model(
        ChatId ChatId,
        Chat? Chat,
        AccountFull Account,
        ScreenSize ScreenSize = ScreenSize.Unknown
    ) {
        public static Model Loading { get; } = new(default, null, AccountFull.Loading); // Should differ by ref. from None
        public static Model None(ScreenSize screenSize) => new(default, null, AccountFull.None, screenSize);

        public bool IsIdenticalTo([NotNullWhen(true)] Model? other) {
            if (other == null)
                return false;
            return ChatId == other.ChatId
                   && ReferenceEquals(Chat, other.Chat)
                   && ReferenceEquals(Account, other.Account)
                   && ScreenSize == other.ScreenSize;
        }
    }
}
