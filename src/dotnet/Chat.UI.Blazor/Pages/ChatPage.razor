@page "/chat/{ChatId}"
@using ActualChat.Notification.UI.Blazor
@using ActualChat.Chat.UI.Blazor.Events
@inherits ComputedStateComponent<ChatPage.Model>
@layout ChatLayout
@{
    var m = _lastRenderedModel = State.LatestNonErrorValue;
    if (m.IsUnavailable) {
        <RequireChat ChatId="@m.ParsedChatId.Id.Value" />
        return;
    }
    var error = State.Error; // AY: Add code displaying the error bar later
    var chat = m.Chat;
}

@* @key=... ensures child components are recreated on navigation to another chat *@

@* Left panel can be rendered w/o chat being loaded *@
<RenderIntoSlot Name="MainLeftPanel">
    <LeftPanel/>
</RenderIntoSlot>

@if (chat == null) {
    /* Chat isn't yet fetched, so nothing to render on the right side */
    return;
}
@if (!chat.IsPublic && !m.Account.IsActive()) {
    /* We check account here to avoid excessive render */
    <RequireAccount/>
}

<RenderIntoSlot Name="MainHeader">
    <CascadingValue Value="chat">
        <ChatHeader/>
    </CascadingValue>
</RenderIntoSlot>

<RenderIntoStack Name="SubHeader" Order="-1000_000" Key="HistoricalPlaybackSubHeader">
    <CascadingValue Value="chat">
        <HistoricalPlaybackSubHeader/>
    </CascadingValue>
</RenderIntoStack>
<RenderIntoStack Name="SubHeader" Order="1000_000" Key="UnreadMessagesSubHeader">
    <CascadingValue Value="chat">
        <UnreadMessagesSubHeader Click="@OnUnreadMessagesClick"/>
    </CascadingValue>
</RenderIntoStack>

<RenderIntoSlot Name="MainFooter">
    <CascadingValue Value="chat">
        <ChatFooter/>
    </CascadingValue>
</RenderIntoSlot>

<RenderIntoStack Name="SubFooter" Order="-1000_000" Key="RecordingElsewhereSubHeader">
    <CascadingValue Value="chat">
        <RecordingElsewhereSubHeader/>
    </CascadingValue>
</RenderIntoStack>

<RenderIntoSlot Name="MainRightPanel">
    <CascadingValue Value="chat">
        <ChatRightPanel/>
    </CascadingValue>
</RenderIntoSlot>

<CascadingValue Value="chat" @key="chat.Id">
    <ChatView @ref="_chatViewRef" />
</CascadingValue>

@code {
    private Model? _lastRenderedModel;
    private ChatView _chatViewRef = null!;

    [Inject] private Session Session { get; init; } = null!;
    [Inject] private DeviceInfo DeviceInfo { get; init; } = null!;
    [Inject] private IAccounts Accounts { get; init; } = null!;
    [Inject] private IChats Chats { get; init; } = null!;
    [Inject] private ChatUI ChatUI { get; init; } = null!;
    [Inject] private UICommander UICommander { get; init; } = null!;
    [Inject] private UIEventHub UIEventHub { get; init; } = null!;
    [Inject] private ILogger<ChatPage> Log { get; init; } = null!;

    [Parameter] public string ChatId { get; set; } = "";

    protected override bool ShouldRender()
        => ReferenceEquals(_lastRenderedModel, null)
            || State.HasError
            || !ReferenceEquals(_lastRenderedModel, State.LatestNonErrorValue);

    protected override Task OnAfterRenderAsync(bool firstRender) {
        if (!firstRender)
            return Task.CompletedTask;

        _ = DeviceInfo.EnsureDeviceRegistered(CancellationToken.None);
        return Task.CompletedTask;
    }

    protected override ComputedState<Model>.Options GetStateOptions()
        => new() { InitialValue = Model.Loading };

    protected override async Task<Model> ComputeState(CancellationToken cancellationToken) {
        if (ChatId.IsNullOrEmpty())
            return Model.Loading;

        var accountTask = Accounts.Get(Session, default);
        var account = (Account?) null;

        var parsedChatId = new ParsedChatId(ChatId);
        if (parsedChatId.Kind is ChatIdKind.PeerShort) {
            account ??= await accountTask;
            parsedChatId = account != null
                ? ParsedChatId.FormatFullPeerChatId(account.Id, parsedChatId.UserId1)
                : parsedChatId.Invalid();
        }

        // parsedChatId is either (valid & not short) or invalid at this point
        if (parsedChatId.IsValid && ChatUI.SelectedChatId.Value != parsedChatId.Id) {
            ChatUI.SelectedChatId.Value = parsedChatId.Id;
            if (ChatUI.LinkedChatEntry.Value != null)
                ChatUI.LinkedChatEntry.Value = null;
            _ = UIEventHub.Publish<SelectedChatChangedEvent>(CancellationToken.None);
            UICommander.CancelUpdateDelays();
        }

        account ??= await accountTask;
        if (!parsedChatId.IsValid)
            return new Model(parsedChatId, null, account); // Unavailable

        var chat = await Chats.Get(Session, parsedChatId.Id, cancellationToken);
        if (chat == null)
            return new Model(parsedChatId, null, account); // Unavailable

        var result = new Model(parsedChatId, chat, account);
        return result.IsSame(_lastRenderedModel) ? _lastRenderedModel! : result;
    }

    private void OnUnreadMessagesClick()
        => _ = _chatViewRef.NavigateToUnreadEntry();

    public sealed record Model(ParsedChatId ParsedChatId, Chat? Chat, Account? Account) {
        public static Model Loading { get; } = new(default, null, null);

        public bool IsNone => ParsedChatId.Id.IsEmpty;
        public bool IsUnavailable => !IsNone && Chat is null;

        public bool IsSame(Model? other) {
            if (other == null)
                return false;
            return ParsedChatId == other.ParsedChatId
                && ReferenceEquals(Chat, other.Chat)
                && ReferenceEquals(Account, other.Account);
        }
    }
}
