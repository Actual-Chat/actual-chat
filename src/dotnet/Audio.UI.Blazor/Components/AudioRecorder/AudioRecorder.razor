@namespace ActualChat.Audio.UI.Blazor.Components
@inherits ComputedStateComponent<LanguageId>
@implements IAudioRecorderBackend
@using ActualChat.Audio.UI.Blazor.Module
@using ActualChat.Media
@using System.Buffers.Binary
@using ActualChat.Users
@implements IAsyncDisposable

@{
    var cls = "";
    if (IsRecording)
        cls += "recording";
    else {
        cls += "not-recording";
    }
}

<button class="@(_class ??= this.DefaultClass()) p-1"
        @onclick="ToggleRecording" >
    <svg class="fill-current w-8 h-8 @cls" xmlns="http://www.w3.org/2000/svg" viewBox="-4 -4 32 32">
        <path d="M16 11c0 2.209-1.791 4-4 4s-4-1.791-4-4v-7c0-2.209 1.791-4 4-4s4 1.791 4 4v7zm4-2v2c0 4.418-3.582 8-8 8s-8-3.582-8-8v-2h2v2c0 3.309 2.691 6 6 6s6-2.691 6-6v-2h2zm-7 13v-2h-2v2h-4v2h10v-2h-4z"/>
    </svg>
</button>

@code {
    private static string? _class;

    [Inject] private ILogger<AudioRecorder> Log { get; init; } = null!;
    private ILogger? DebugLog => DebugMode ? Log : null;
    private bool DebugMode => Constants.DebugMode.AudioRecording;

    [Inject] private Session Session { get; init; } = null!;
    [Inject] private IJSRuntime JS { get; init; } = null!;
    [Inject] private IChatUserSettings ChatUserSettings { get; init; } = null!;

    private IJSObjectReference? JSRef { get; set; }
    private DotNetObjectReference<IAudioRecorderBackend> BlazorRef { get; set; } = null!;
    private Channel<RecordingPart> AudioChannel { get; set; } = null!;
    private int Index { get; set; }
    private bool IsRecording => AudioChannel != null!;

    [Parameter]
    public string ChatId { get; set; } = "";
    [Parameter]
    public EventCallback<bool> RecordingStateChanged { get; set; }

    public override async ValueTask DisposeAsync() {
        await base.DisposeAsync().ConfigureAwait(true);

        await StopRecording().ConfigureAwait(true);
        await JSRef.DisposeSilentlyAsync().ConfigureAwait(true);
        // ReSharper disable once ConstantConditionalAccessQualifier
        BlazorRef?.Dispose();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender) {
        if (firstRender) {
            BlazorRef = DotNetObjectReference.Create<IAudioRecorderBackend>(this);
            JSRef = await JS.InvokeAsync<IJSObjectReference>(
                $"{AudioBlazorUIModule.ImportName}.AudioRecorder.create",
                BlazorRef, Session.Id, ChatId, DebugMode
                ).ConfigureAwait(true);
        }
    }

    protected override async Task<LanguageId> ComputeState(CancellationToken cancellationToken) {
        var settings = await ChatUserSettings.Get(Session, ChatId, cancellationToken).ConfigureAwait(true);
        var languageId = settings?.Language ?? State.LatestNonErrorValue;
        if (languageId != State.LatestNonErrorValue && IsRecording) {
            using var _ = Computed.SuspendDependencyCapture();
            await ToggleRecording().ConfigureAwait(true);
            await ToggleRecording().ConfigureAwait(true);
        }
        return  languageId;
    }

    private Task ToggleRecording()
        => IsRecording ? StopRecording() : StartRecording();

    private async Task StartRecording() {
        if (IsRecording) return;
        DebugLog?.LogDebug(nameof(StartRecording));

        AudioChannel = Channel.CreateBounded<RecordingPart>(
            new BoundedChannelOptions(128) {
                SingleWriter = true,
                SingleReader = true,
                AllowSynchronousContinuations = true,
            });
        StateHasChanged();
        if (JSRef != null)
            await JSRef.InvokeVoidAsync("startRecording");
        await RecordingStateChanged.InvokeAsync(IsRecording).ConfigureAwait(true);
    }

    private async Task StopRecording() {
        if (!IsRecording) return;
        DebugLog?.LogDebug(nameof(StopRecording));

        var audioChannel = AudioChannel;
        _ = InvokeAsync(async () => {
            await Task.Delay(TimeSpan.FromSeconds(5)).ConfigureAwait(true);
            if (AudioChannel != audioChannel)
                return; // We don't want to stop the next recording here :)

            Log.LogWarning(nameof(OnRecordingStopped) + " wasn't invoked on time by JS backend");
            await OnRecordingStopped().ConfigureAwait(true);
        });
        if (JSRef != null)
            await JSRef.InvokeVoidAsync("stopRecording");
    }

    // JS backend callback handlers

    [JSInvokable]
    public void OnStartRecording() {
        if (!IsRecording) return;
        DebugLog?.LogDebug(nameof(OnStartRecording));
    }

    [JSInvokable]
    public async Task OnRecordingStopped() {
        // Does the same as StopRecording; we assume here that recording
        // might be recognized as stopped by JS backend as well
        if (!IsRecording) return;
        DebugLog?.LogDebug(nameof(OnRecordingStopped));

        AudioChannel.Writer.Complete();
        AudioChannel = null!;
        StateHasChanged();
        await RecordingStateChanged.InvokeAsync(IsRecording).ConfigureAwait(true);
    }
}

