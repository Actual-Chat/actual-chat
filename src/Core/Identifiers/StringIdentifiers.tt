<#@ template language="C#" #>
<#@ import namespace="System.Collections.Generic" #>
<#
    List<string> entityTypeNames = new () {
        "Chat",
        "AudioRecord",
        "VideoRecord",
        "Stream",
        "User"
    };

#>
using System;
using System.ComponentModel;
using System.Globalization;
using System.Runtime.Serialization;
using System.Text.Json;
using System.Text.Json.Serialization;
using Stl.Text;
// ReSharper disable PartialTypeWithSinglePart
#pragma warning disable 618

namespace ActualChat
{
<#
    foreach(var entityTypeName in entityTypeNames)
    {
        var typeName = entityTypeName + "Id";
#>
    [DataContract]
    [JsonConverter(typeof(<#=typeName#>JsonConverter))]
    [TypeConverter(typeof(<#=typeName#>TypeConverter))]
    public readonly partial struct <#=typeName#> : IEquatable<<#=typeName#>>, IIdentifier<string>
    {
        [Obsolete("Use implicit cast to/from string instead")]
        [DataMember(Order = 0)]
        public string Value { get; }

        public <#=typeName#>(string value)
            => Value = value;

        public override string ToString() => Value;

        public static implicit operator <#=typeName#>(string value) => new(value);
        public static implicit operator string(<#=typeName#> id) => id.Value;

        // Equality
        public bool Equals(<#=typeName#> other) => Value == other.Value;
        public override bool Equals(object? obj) => obj is <#=typeName#> other && Equals(other);
        public override int GetHashCode() => Value.GetHashCode();
        public static bool operator ==(<#=typeName#> left, <#=typeName#> right) => left.Equals(right);
        public static bool operator !=(<#=typeName#> left, <#=typeName#> right) => !left.Equals(right);
    }

    public class <#=typeName#>JsonConverter : JsonConverter<<#=typeName#>>
    {
        public override <#=typeName#> Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
            => new(reader.GetString()!);

        public override void Write(Utf8JsonWriter writer, <#=typeName#> value, JsonSerializerOptions options)
            => writer.WriteStringValue(value.Value);
    }

    public class <#=typeName#>TypeConverter : TypeConverter
    {
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
            => sourceType == typeof(string) || base.CanConvertFrom(context, sourceType);

        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
        {
            if (destinationType == typeof(string))
                return ((IIdentifier<string>) value).Value;
            return base.ConvertTo(context, culture, value, destinationType)!;
        }

        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
        {
            if (value is string s)
                // ReSharper disable once HeapView.BoxingAllocation
                return new <#=typeName#>(s);
            return base.ConvertFrom(context, culture, value)!;
        }
    }


<#
    }
#>
}
