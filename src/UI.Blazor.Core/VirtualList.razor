@typeparam TItem
@inherits ComputedStateComponent<VirtualListResponse<TItem>>
@implements IVirtualListBackend
@using ActualChat.UI.Blazor.Internal
@using Stl.Async
@using System.Collections.Immutable
@using ActualChat.Mathematics
@using Stl.Collections
@inject IJSRuntime _js
@inject JSModule _jsModule
@inject ILogger<VirtualList<TItem>> _log

@{
    var ri = GetNextRenderInfo();
    _log.LogInformation("Render");
}

<div @ref="Ref" class="@Class virtual-list" style="@Style" data-render-index="@ri.RenderIndex">
    <div class="content">
        <div class="items items-unmeasured">
            @foreach (var e in ri.UnmeasuredItems) {
                <div @key="e.Key" class="item" data-key="@e.Key">
                    @Item(e.Item)
                </div>
            }
        </div>
        <div class="spacer spacer-start" style="height: @(ri.SpacerSize)px"></div>
        <div class="items items-displayed">
            @foreach (var e in ri.DisplayedItems) {
                <div @key="e.Key" class="item" data-key="@e.Key" data-size="@e.Size">
                    @Item(e.Item)
                </div>
            }
        </div>
        @if (!ri.Response.HasVeryLastItem) {
            <div class="spacer spacer-end"></div>
        }
    </div>
</div>

@{
    LastRenderInfo = ri;
}

@code {

    public class ItemInfo
    {
        public string Key { get; init; } = null!;
        public TItem Item { get; init; } = default!;
        public double Size { get; set; } = -1;
        public bool IsSizeMeasured => Size >= 0;
    }

    public class RenderInfo
    {
        public long RenderIndex { get; set; } = 0;
        public VirtualListResponse<TItem> Response { get; set; } = null!;
        public Dictionary<string, ItemInfo> ItemByKey { get; set; } = null!;
        public List<ItemInfo> LoadedItems { get; set; } = null!;
        public List<ItemInfo> UnmeasuredItems { get; set; } = null!;
        public List<ItemInfo> DisplayedItems { get; set; } = null!;
        public double SpacerSize { get; set; } // That's "prefix spacer"
        public Range<double> ViewRange { get; set; } // Relative to the top item's top
        public bool MustScroll { get; set; }
        public bool MustScrollWhenAnyItemDisplayed { get; set; }

        // Pre-computed properties
        public Range<double> DisplayedRange { get; private set; }
        public List<(ItemInfo Item, Range<double> Range)> DisplayedItemRanges { get; private set; } = null!;

        // Computed properties
        public bool IsViewLoaded
            => DisplayedRange.Contains(ViewRange) || Response.HasVeryFirstItem && Response.HasVeryLastItem;
        public bool IsVeryFirstItemVisible
            => Response.HasVeryFirstItem && (DisplayedItemRanges.Count == 0 || ViewRange.Contains(DisplayedItemRanges[0].Range));
        public bool IsVeryLastItemVisible
            => Response.HasVeryLastItem && (DisplayedItemRanges.Count == 0 || ViewRange.Contains(DisplayedItemRanges[^1].Range));

        public void UpdateRanges()
        {
            DisplayedItemRanges = GetRanges(DisplayedItems).ToList();
            DisplayedRange = DisplayedItemRanges.Count > 0 ? (DisplayedItemRanges[0].Range.Start, DisplayedItemRanges[^1].Range.End) : default;
        }
    }

    protected IJSObjectReference? ModuleRef { get; set; } // Shouldn't be disposed
    protected IJSObjectReference? JSComponentRef { get; set; }
    protected DotNetObjectReference<IVirtualListBackend>? ComponentRef { get; set; }
    protected RenderInfo? LastRenderInfo { get; set; }
    protected VirtualListQuery? LastQuery { get; set; }
    protected VirtualListQuery NextQuery { get; set; } = new(default);
    protected IVirtualListItemSizeEstimator ItemSizeEstimator { get; set; } = new VirtualListItemSizeEstimator();

    [Parameter] public string Class { get; set; } = "";
    [Parameter] public string Style { get; set; } = "";
    [Parameter] public RenderFragment<TItem> Item { get; set; } = null!;
    [Parameter] public double SpacerSize { get; set; } = 100_000;
    [Parameter] public double LoadZoneSize { get; set; } = 1080;
    [Parameter] public double BufferZoneSize { get; set; } = 2160;
    [Parameter] public Func<VirtualListQuery, CancellationToken, Task<VirtualListResponse<TItem>>> Provider { get; set; } =
        (_, _) => Task.FromResult(new VirtualListResponse<TItem>());

    public ElementReference Ref { get; set; }

    public override async ValueTask DisposeAsync()
    {
        if (JSComponentRef != null) {
            await JSComponentRef.InvokeVoidAsync("dispose");
            await JSComponentRef.DisposeAsync();
        }
        ComponentRef?.Dispose();
        await base.DisposeAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender) {
            ModuleRef = await _jsModule.Import(typeof(IVirtualListBackend).Assembly, "js/virtual-list.js");
            ComponentRef = DotNetObjectReference.Create<IVirtualListBackend>(this);
            JSComponentRef = await ModuleRef.InvokeAsync<IJSObjectReference>("create", Ref, ComponentRef);
        }
        var ri = LastRenderInfo;
        if (ri == null)
            return;
        // _log.LogInformation("AfterRender: {SpacerSize} | {DisplayedRange}, [ {ViewRange} ]", ri.SpacerSize, ri.DisplayedRange, ri.ViewRange);
        if (!ri.IsViewLoaded)
            TryRecomputeState();
        if (JSComponentRef != null)
            await JSComponentRef.InvokeVoidAsync("afterRender", ri.MustScroll, ri.ViewRange.Start);
    }

    [JSInvokable]
    public void UpdateClientSideState(IVirtualListBackend.ClientSideState clientSideState)
    {
        var ri = LastRenderInfo;
        if (ri == null || clientSideState.RenderIndex != ri.RenderIndex) {
            _log.LogDebug("Skipped UpdateClientSideState due to outdated RenderIndex");
            return;
        }

        var prevIsViewLoaded = ri.IsViewLoaded;
        var isItemSizeChanged = false;
        foreach (var (key, size) in clientSideState.ItemSizes) {
            // ReSharper disable once CompareOfFloatsByEqualityOperator
            if (!ri.ItemByKey.TryGetValue(key, out var item) || item.Size == size)
                continue;
            if (item.IsSizeMeasured)
                ItemSizeEstimator.RemoveObservedSize(item.Size);
            ItemSizeEstimator.AddObservedSize(size);
            item.Size = size;
            isItemSizeChanged = true;
        }
        var isViewRangeChanged = clientSideState.ViewRange != ri.ViewRange;
        ri.ViewRange = clientSideState.ViewRange;
        if (isItemSizeChanged) {
            ri.UpdateRanges();
            StateHasChanged();
        }
        // "else" is used here because OnAfterRenderAsync runs all these checks anyway
        else if (isViewRangeChanged || !prevIsViewLoaded || !ri.IsViewLoaded)
            TryRecomputeState();
    }

    protected override Task<VirtualListResponse<TItem>> ComputeState(CancellationToken cancellationToken)
    {
        var query = NextQuery;
        LastQuery = query;
        return Provider.Invoke(query, cancellationToken);
        // var result = await Provider.Invoke(query, cancellationToken);
        // _log.LogInformation("ComputeState -> {ItemKeys}", result.Items.Select(i => i.Key).ToDelimitedString());
        // return result;
    }

    protected void TryRecomputeState()
    {
        if (!State.Computed.IsConsistent()) // Already recomputing
            return;
        NextQuery = GetQuery();
        if (LastQuery != NextQuery)
            State.Recompute().Ignore();
    }

    protected virtual VirtualListQuery GetQuery()
    {
        var ri = LastRenderInfo;
        if (ri == null)
            return new VirtualListQuery(default);
        if (ri.UnmeasuredItems.Count != 0) // Let's wait for measurement to complete first
            return LastQuery!;
        if (ri.DisplayedItems.Count == 0) // No entries -> nothing to "align" to
            return LastQuery!;

        var loaderZone = new Range<double>(ri.ViewRange.Start - LoadZoneSize, ri.ViewRange.End + LoadZoneSize);
        var bufferZone = new Range<double>(ri.ViewRange.Start - BufferZoneSize, ri.ViewRange.End + BufferZoneSize);
        // _log.LogInformation("GetQuery: {ViewRange} < {LoaderZone} < {BufferZone} | {DisplayedRange}", ri.ViewRange, loaderZone, bufferZone, ri.DisplayedRange);
        var displayedItemRanges = ri.DisplayedItemRanges;
        var (firstItem, firstRange) = displayedItemRanges.FirstOrDefault(p => p.Range.IntersectWith(bufferZone).Size() > 0);
        var (lastItem, lastRange) = displayedItemRanges.LastOrDefault(p => p.Range.IntersectWith(bufferZone).Size() > 0);
        // _log.LogDebug("GetQuery: DisplayedItemRanges: {DisplayedItemRanges}", displayedItemRanges.Select(r => (r.Item.Key, r.Range)).ToDelimitedString());
        if (firstItem == null!) {
            // All entries are outside of the buffer zone
            if (displayedItemRanges[0].Range.Start >= bufferZone.End) {
                // And they go after the buffer zone, so we take only the first one & expand to the top
                (firstItem, firstRange) = displayedItemRanges[0];
                (lastItem, lastRange) = displayedItemRanges[0];
            } else {
                // They go before the buffer zone, so we take only the last one & expand to the bottom
                (firstItem, firstRange) = displayedItemRanges[^1];
                (lastItem, lastRange) = displayedItemRanges[^1];
            }
        }
        var keyRange = new Range<string>(firstItem.Key, lastItem.Key);
        var itemSize = ItemSizeEstimator.EstimatedSize;
        var startGap = Math.Max(0, (firstRange.Start - loaderZone.Start) / itemSize);
        var endGap = Math.Max(0, (loaderZone.End - lastRange.End) / itemSize);
        return new VirtualListQuery(keyRange) {
            ExpandStartBy = Math.Round(startGap, 1),
            ExpandEndBy = Math.Round(endGap, 1),
        };
    }

    protected virtual RenderInfo GetNextRenderInfo()
    {
        var ri = new RenderInfo();
        var lri = LastRenderInfo;
        var response = State.LatestNonErrorValue ?? new();
        if (lri == null) {
            // First render
            ri.RenderIndex = 0;
            ri.Response = response;
            ri.LoadedItems = response.Items.Select(i => new ItemInfo { Key = i.Key, Item = i.Value }).ToList();
            ri.ItemByKey = ri.LoadedItems.ToDictionary(e => e.Key);
            ri.UnmeasuredItems = ri.LoadedItems.Where(e => !e.IsSizeMeasured).ToList();
            ri.DisplayedItems = ri.LoadedItems.Where(e => e.IsSizeMeasured).ToList();
            ri.ViewRange = ri.DisplayedRange;
            ri.SpacerSize = SpacerSize;
            ri.MustScrollWhenAnyItemDisplayed = true;
        }
        else {
            ri.RenderIndex = lri.RenderIndex + 1;
            ri.Response = response;
            ri.ViewRange = lri.ViewRange;
            ri.SpacerSize = lri.SpacerSize;
            ri.MustScrollWhenAnyItemDisplayed = lri.MustScrollWhenAnyItemDisplayed;
            if (!ReferenceEquals(lri.Response, response)) {
                ri.LoadedItems = new List<ItemInfo>();
                ri.ItemByKey = new Dictionary<string, ItemInfo>();
                foreach (var (key, item) in response.Items) {
                    var itemInfo = new ItemInfo { Key = key, Item = item };
                    if (lri.ItemByKey.TryGetValue(key, out var oldItemInfo))
                        itemInfo.Size = oldItemInfo.Size;
                    ri.LoadedItems.Add(itemInfo);
                    ri.ItemByKey.Add(key, itemInfo);
                }
            }
            else {
                ri.LoadedItems = lri.LoadedItems;
                ri.ItemByKey = lri.ItemByKey;
            }
            ri.UnmeasuredItems = ri.LoadedItems.Where(e => !e.IsSizeMeasured).ToList();
            ri.DisplayedItems = ri.LoadedItems.Where(e => e.IsSizeMeasured).ToList();
            // Adjust the new spacer size:
            // 1. Find any item that exists in both old & new lists
            var (sharedItem, oldRange) = lri.DisplayedItemRanges.FirstOrDefault(p => ri.ItemByKey.ContainsKey(p.Item.Key));
            if (sharedItem != null!) {
                // 2. Compute its new range
                var (_, newRange) = GetRanges(ri.DisplayedItems).Single(p => p.Item.Key == sharedItem.Key);
                // 3. Update SpacerSize & ViewRange
                var offset = newRange.Start - oldRange.Start;
                ri.SpacerSize -= offset;
                ri.ViewRange = ri.ViewRange.Move(offset);
            }
            else {
                // Everything is new, so let's scroll to the very top
                ri.SpacerSize = SpacerSize;
                ri.ViewRange = new(0, lri.ViewRange.Size());
                ri.MustScrollWhenAnyItemDisplayed = true;
            }
            if (ri.MustScrollWhenAnyItemDisplayed && ri.DisplayedItems.Count > 0) {
                ri.SpacerSize = SpacerSize;
                ri.ViewRange = new(0, lri.ViewRange.Size());
                ri.MustScroll = true;
                ri.MustScrollWhenAnyItemDisplayed = false;
            }
            if (ri.Response.HasVeryFirstItem)
                ri.SpacerSize = 0;
        }
        ri.UpdateRanges();
        return ri;
    }

    private static IEnumerable<(ItemInfo Item, Range<double> Range)> GetRanges(List<ItemInfo> items)
    {
        var range = default(Range<double>);
        foreach (var item in items) {
            range = new(range.End, range.End + item.Size);
            yield return (item, range);
        }
    }
}
