@typeparam TItem
@inherits ComputedStateComponent<VirtualListResponse<TItem>>
@implements IVirtualListBackend
@implements IAsyncDisposable
@using ActualChat.UI.Blazor.Internal
@using Stl.Async
@using System.Collections.Immutable
@using ActualChat.Mathematics
@using Stl.Collections
@inject IJSRuntime _js
@inject JSModule _jsModule
@inject ILogger<VirtualList<TItem>> _log

@{
    var ri = GetNextRenderInfo();
}

<div @ref="Ref" class="@Class virtual-list" style="@Style" data-render-index="@ri.RenderIndex">
    <div class="content">
        <div class="items items-unmeasured">
            @foreach (var e in ri.UnmeasuredEntries) {
                <div @key="e.Key" class="item" data-key="@e.Key">
                    @ChildContent(e.Item)
                </div>
            }
        </div>
        <div class="spacer spacer-start" style="height: @(ri.SpacerSize)px"></div>
        <div class="items items-displayed">
            @foreach (var e in ri.Entries) {
                <div @key="e.Key" class="item" data-key="@e.Key" data-size="@e.Size">
                    @ChildContent(e.Item)
                </div>
            }
        </div>
        @if (!ri.Response.HasVeryLastItem) {
            <div class="spacer spacer-end"></div>
        }
    </div>
</div>

@{
    LastRenderInfo = ri;
}

@code {

    public class Entry
    {
        public string Key { get; init; } = null!;
        public TItem Item { get; init; } = default!;
        public double Size { get; set; } = -1;
        public bool IsSizeMeasured => Size >= 0;
    }

    public class RenderInfo
    {
        public long RenderIndex { get; set; } = 0;
        public VirtualListResponse<TItem> Response { get; set; } = null!;
        public ImmutableDictionary<string, Entry> EntryByKey { get; set; } = ImmutableDictionary<string, Entry>.Empty;
        public List<Entry> LoadedEntries { get; set; } = null!;
        public List<Entry> UnmeasuredEntries { get; set; } = null!;
        public List<Entry> Entries { get; set; } = null!;
        public double SpacerSize { get; set; } // That's "prefix spacer"
        public Range<double> ViewRange { get; set; } // Relative to the top entry's top
        public Range<double> EntryRange { get; private set; }
        public bool IsViewLoaded { get; private set; }
        public bool MustScroll { get; set; }
        public bool MustScrollWhenDisplayedEntries { get; set; }

        public void RecomputeCachedValues()
        {
            EntryRange = (0, Entries.Sum(e => e.Size));
            var visibleEntriesRange = EntryRange.IntersectWith(ViewRange);
            IsViewLoaded = visibleEntriesRange == ViewRange || Response.HasVeryFirstItem && Response.HasVeryLastItem;
        }
    }

    protected IJSObjectReference? ModuleRef { get; set; } // Shouldn't be disposed
    protected IJSObjectReference? JSComponentRef { get; set; }
    protected DotNetObjectReference<IVirtualListBackend>? ComponentRef { get; set; }
    protected RenderInfo? LastRenderInfo { get; set; }
    protected VirtualListQuery? LastQuery { get; set; }
    protected VirtualListQuery NextQuery { get; set; } = new(default);
    protected double ItemSizeSum { get; set; }
    protected long ItemSizeCount { get; set; }
    protected double ItemSizeAverage => ItemSizeSum / ItemSizeCount;

    [Parameter] public string Class { get; set; } = "";
    [Parameter] public string Style { get; set; } = "";
    [Parameter] public RenderFragment<TItem> ChildContent { get; set; } = null!;
    [Parameter] public double SpacerSize { get; set; } = 100_000;
    [Parameter] public double LoadZoneSize { get; set; } = 100;
    [Parameter] public double BufferZoneSize { get; set; } = 200;
    [Parameter] public Func<VirtualListQuery, CancellationToken, Task<VirtualListResponse<TItem>>> Provider { get; set; } =
        (_, _) => Task.FromResult(new VirtualListResponse<TItem>());

    public ElementReference Ref { get; set; }

    public virtual async ValueTask DisposeAsync()
    {
        if (JSComponentRef != null) {
            await JSComponentRef.InvokeVoidAsync("dispose");
            await JSComponentRef.DisposeAsync();
        }
        ComponentRef?.Dispose();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender) {
            ModuleRef = await _jsModule.Import(typeof(IVirtualListBackend).Assembly, "js/virtual-list.js");
            ComponentRef = DotNetObjectReference.Create<IVirtualListBackend>(this);
            JSComponentRef = await ModuleRef.InvokeAsync<IJSObjectReference>("create", Ref, ComponentRef);
        }
        var ri = LastRenderInfo;
        if (ri == null)
            return;
        // _log.LogInformation("AfterRender: {SpacerSize} | {EntryRange}, [ {ViewRange} ]", ri.SpacerSize, ri.EntryRange, ri.ViewRange);
        if (!ri.IsViewLoaded)
            TryRecomputeState();
        if (JSComponentRef != null)
            await JSComponentRef.InvokeVoidAsync("afterRender", ri.MustScroll, ri.ViewRange.Start);
    }

    [JSInvokable]
    public void UpdateClientSideState(IVirtualListBackend.ClientSideState clientSideState)
    {
        var ri = LastRenderInfo;
        if (ri == null || clientSideState.RenderIndex != ri.RenderIndex) {
            _log.LogDebug("Skipped UpdateClientSideState due to outdated RenderIndex");
            return;
        }

        var prevIsViewLoaded = ri.IsViewLoaded;
        var isEntrySizeChanged = false;
        foreach (var (key, size) in clientSideState.ItemSizes) {
            // ReSharper disable once CompareOfFloatsByEqualityOperator
            if (!ri.EntryByKey.TryGetValue(key, out var entry) || entry.Size == size)
                continue;
            entry.Size = size;
            ItemSizeSum += size;
            ItemSizeCount++;
            isEntrySizeChanged = true;
        }
        var isViewRangeChanged = clientSideState.ViewRange != ri.ViewRange;
        ri.ViewRange = clientSideState.ViewRange;
        if (isViewRangeChanged || isEntrySizeChanged)
            ri.RecomputeCachedValues();
        if (isEntrySizeChanged)
            StateHasChanged();
        // "else" is used here because OnAfterRenderAsync runs all these checks anyway
        else if (isViewRangeChanged || !prevIsViewLoaded || !ri.IsViewLoaded)
            TryRecomputeState();
    }

    protected override Task<VirtualListResponse<TItem>> ComputeState(CancellationToken cancellationToken)
    {
        var query = NextQuery;
        LastQuery = query;
        return Provider.Invoke(query, cancellationToken);
        // var result = await Provider.Invoke(query, cancellationToken);
        // _log.LogInformation("ComputeState -> {ItemKeys}", result.Items.Select(i => i.Key).ToDelimitedString());
        // return result;
    }

    protected void TryRecomputeState()
    {
        if (!State.Computed.IsConsistent()) // Already recomputing
            return;
        NextQuery = GetQuery();
        if (LastQuery != NextQuery)
            State.Recompute().Ignore();
    }

    protected virtual VirtualListQuery GetQuery()
    {
        var ri = LastRenderInfo;
        if (ri == null)
            return new VirtualListQuery(default);
        if (ri.UnmeasuredEntries.Count != 0) // Let's wait for measurement to complete first
            return LastQuery!;
        if (ri.Entries.Count == 0) // No entries -> nothing to "align" to
            return LastQuery!;

        var loaderZone = new Range<double>(ri.ViewRange.Start - LoadZoneSize, ri.ViewRange.End + LoadZoneSize);
        var bufferZone = new Range<double>(ri.ViewRange.Start - BufferZoneSize, ri.ViewRange.End + BufferZoneSize);
        // _log.LogInformation("GetQuery: {ViewRange} < {LoaderZone} < {BufferZone} | {EntryRange}", ri.ViewRange, loaderZone, bufferZone, ri.EntryRange);
        var entryRanges = GetEntryRanges(ri.Entries).ToList();
        var (firstEntry, firstRange) = entryRanges.FirstOrDefault(p => p.Range.IntersectWith(bufferZone).Size() > 0);
        var (lastEntry, lastRange) = entryRanges.LastOrDefault(p => p.Range.IntersectWith(bufferZone).Size() > 0);
        // _log.LogDebug("GetQuery: EntryRanges: {EntryRanges}", entryRanges.Select(r => (r.Entry.Key, r.Range)).ToDelimitedString());
        if (firstEntry == null!) {
            // All entries are outside of the buffer zone
            if (entryRanges[0].Range.Start >= bufferZone.End) {
                // And they go after the buffer zone, so we take only the first one & expand to the top
                (firstEntry, firstRange) = entryRanges[0];
                (lastEntry, lastRange) = entryRanges[0];
            } else {
                // They go before the buffer zone, so we take only the last one & expand to the bottom
                (firstEntry, firstRange) = entryRanges[^1];
                (lastEntry, lastRange) = entryRanges[^1];
            }
        }
        var keyRange = new Range<string>(firstEntry.Key, lastEntry.Key);
        var itemSize = ItemSizeAverage;
        var startGap = Math.Max(0, (firstRange.Start - loaderZone.Start) / itemSize);
        var endGap = Math.Max(0, (loaderZone.End - lastRange.End) / itemSize);
        return new VirtualListQuery(keyRange) {
            ExpandStartBy = Math.Round(startGap, 1),
            ExpandEndBy = Math.Round(endGap, 1),
        };
    }

    protected virtual RenderInfo GetNextRenderInfo()
    {
        var ri = new RenderInfo();
        var lri = LastRenderInfo;
        var response = State.LatestNonErrorValue ?? new();
        if (lri == null) {
            // First render
            ri.RenderIndex = 0;
            ri.Response = response;
            ri.LoadedEntries = response.Items.Select(i => new Entry { Key = i.Key, Item = i.Value }).ToList();
            ri.EntryByKey = ri.LoadedEntries.ToImmutableDictionary(e => e.Key);
            ri.UnmeasuredEntries = ri.LoadedEntries.Where(e => !e.IsSizeMeasured).ToList();
            ri.Entries = ri.LoadedEntries.Where(e => e.IsSizeMeasured).ToList();
            ri.ViewRange = ri.EntryRange;
            ri.SpacerSize = SpacerSize;
            ri.MustScrollWhenDisplayedEntries = true;
        }
        else {
            ri.RenderIndex = lri.RenderIndex + 1;
            ri.Response = response;
            ri.ViewRange = lri.ViewRange;
            ri.SpacerSize = lri.SpacerSize;
            ri.MustScrollWhenDisplayedEntries = lri.MustScrollWhenDisplayedEntries;
            if (!ReferenceEquals(lri.Response, response)) {
                ri.LoadedEntries = new List<Entry>();
                ri.EntryByKey = ImmutableDictionary<string, Entry>.Empty;
                foreach (var (key, item) in response.Items) {
                    var entry = lri.EntryByKey.GetValueOrDefault(key) ?? new Entry { Key = key, Item = item };
                    ri.LoadedEntries.Add(entry);
                    ri.EntryByKey = ri.EntryByKey.Add(key, entry);
                }
            }
            else {
                ri.LoadedEntries = lri.LoadedEntries;
                ri.EntryByKey = lri.EntryByKey;
            }
            ri.UnmeasuredEntries = ri.LoadedEntries.Where(e => !e.IsSizeMeasured).ToList();
            ri.Entries = ri.LoadedEntries.Where(e => e.IsSizeMeasured).ToList();
            // Adjust the new spacer size:
            // 1. Find the first entry in lri.ShownEntries that exists in ri.ShownEntries
            var (sharedEntry, oldRange) = GetEntryRanges(lri.Entries)
                .FirstOrDefault(p => ri.EntryByKey.ContainsKey(p.Entry.Key));
            if (sharedEntry != null!) {
                // 2. Compute its new range
                var (_, newRange) = GetEntryRanges(ri.Entries).Single(p => p.Entry == sharedEntry);
                // 3. Update SpacerSize & ViewRange
                var offset = newRange.Start - oldRange.Start;
                ri.SpacerSize -= offset;
                ri.ViewRange = ri.ViewRange.Move(offset);
            }
            else {
                // Everything is new, so let's scroll to the very top
                ri.SpacerSize = SpacerSize;
                ri.ViewRange = new(0, lri.ViewRange.Size());
                ri.MustScrollWhenDisplayedEntries = true;
            }
            if (ri.MustScrollWhenDisplayedEntries && ri.Entries.Count > 0) {
                ri.SpacerSize = SpacerSize;
                ri.ViewRange = new(0, lri.ViewRange.Size());
                ri.MustScroll = true;
                ri.MustScrollWhenDisplayedEntries = false;
            }
            if (ri.Response.HasVeryFirstItem)
                ri.SpacerSize = 0;
        }
        ri.RecomputeCachedValues();
        return ri;
    }

    protected static IEnumerable<(Entry Entry, Range<double> Range)> GetEntryRanges(List<Entry> entries)
    {
        var range = default(Range<double>);
        foreach (var entry in entries) {
            range = new(range.End, range.End + entry.Size);
            yield return (entry, range);
        }
    }
}
