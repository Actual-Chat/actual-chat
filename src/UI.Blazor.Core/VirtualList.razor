@typeparam TItem
@inherits ComputedStateComponent<VirtualListResponse<TItem>>
@implements IVirtualListBackend
@implements IAsyncDisposable
@using ActualChat.UI.Blazor.Internal
@using Stl.Async
@using System.Collections.Immutable
@using ActualChat.Mathematics
@using Stl.Collections
@inject IJSRuntime _js
@inject JSModule _jsModule
@inject ILogger<VirtualList<TItem>> _log

@{
    var ri = GetNextRenderInfo();
}

<div @ref="Ref" class="@Class virtual-list" style="@Style" data-render-index="@ri.RenderIndex">
    <div class="content">
        <div class="items items-measured">
            @foreach (var e in ri.MeasuringEntries) {
                <div @key="e.Key" class="item" data-key="@e.Key">
                    @ChildContent(e.Item)
                </div>
            }
        </div>
        <div class="spacer spacer-start" style="height: @(ri.SpacerSize)px"></div>
        <div class="items items-shown">
            @foreach (var e in ri.ShownEntries) {
                <div @key="e.Key" class="item" data-key="@e.Key">
                    @ChildContent(e.Item)
                </div>
            }
        </div>
        @if (!ri.Response.HasVeryLastItem) {
            <div class="spacer spacer-end"></div>
        }
    </div>
</div>

@{
    LastRenderInfo = ri;
}

@code {

    public class Entry
    {
        public string Key { get; init; } = null!;
        public TItem Item { get; init; } = default!;
        public double Size { get; set; } = -1;
        public bool IsSizeMeasured => Size >= 0;
    }

    public class RenderInfo
    {
        public long RenderIndex { get; set; } = 0;
        public VirtualListResponse<TItem> Response { get; set; } = null!;
        public ImmutableDictionary<string, Entry> EntryByKey { get; set; } = ImmutableDictionary<string, Entry>.Empty;
        public List<Entry> Entries { get; set; } = null!;
        public List<Entry> MeasuringEntries { get; set; } = null!;
        public List<Entry> ShownEntries { get; set; } = null!;
        public double ShownEntriesSize { get; set; }
        public double SpacerSize { get; set; } // That's "prefix spacer"
        public Range<double> Viewport { get; set; } // Relative to the top entry's top
        public bool MustScroll { get; set; }
        public bool MustScrollWhenAnyShownEntries { get; set; }

        // Computed properties
        public bool MustMeasure => MeasuringEntries.Count > 0;
    }

    protected IJSObjectReference? ModuleRef { get; set; } // Shouldn't be disposed
    protected IJSObjectReference? JSComponentRef { get; set; }
    protected DotNetObjectReference<IVirtualListBackend>? ComponentRef { get; set; }
    protected RenderInfo? LastRenderInfo { get; set; }
    protected VirtualListQuery? LastQuery { get; set; }
    protected VirtualListQuery NextQuery { get; set; } = new(default);
    protected double TotalMeasuredItemSize { get; set; }
    protected long TotalMeasuredItemCount { get; set; }
    protected double MeanItemSize => TotalMeasuredItemSize / TotalMeasuredItemCount;

    [Parameter] public string Class { get; set; } = "";
    [Parameter] public string Style { get; set; } = "";
    [Parameter] public RenderFragment<TItem> ChildContent { get; set; } = null!;
    [Parameter] public double SpacerSize { get; set; } = 100_000;
    [Parameter] public double LoadZoneSize { get; set; } = 100;
    [Parameter] public Func<VirtualListQuery, CancellationToken, Task<VirtualListResponse<TItem>>> Provider { get; set; } =
        (_, _) => Task.FromResult(new VirtualListResponse<TItem>());

    public ElementReference Ref { get; set; }

    public virtual async ValueTask DisposeAsync()
    {
        if (JSComponentRef != null) {
            await JSComponentRef.InvokeVoidAsync("dispose");
            await JSComponentRef.DisposeAsync();
        }
        ComponentRef?.Dispose();
    }

    protected override async Task<VirtualListResponse<TItem>> ComputeState(CancellationToken cancellationToken)
    {
        var query = NextQuery;
        LastQuery = query;
        var result = await Provider.Invoke(query, cancellationToken);
        _log.LogInformation("ComputeState -> {ItemKeys}", result.Items.Select(i => i.Key).ToDelimitedString());
        return result;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender) {
            ModuleRef = await _jsModule.Import(typeof(IVirtualListBackend).Assembly, "js/virtual-list.js");
            ComponentRef = DotNetObjectReference.Create<IVirtualListBackend>(this);
            JSComponentRef = await ModuleRef.InvokeAsync<IJSObjectReference>("create", Ref, ComponentRef);
        }
        var ri = LastRenderInfo;
        if (ri == null)
            return;
        if (ri.MustMeasure || ri.MustScroll)
            JSComponentRef?.InvokeVoidAsync("afterRender", ri.MustMeasure, false, ri.MustScroll, ri.Viewport.Start).Ignore();
        if (ri.ShownEntries.Count == 0)
            TryRecomputeState();
    }

    [JSInvokable]
    public void UpdateClientSideState(IVirtualListBackend.ClientSideState clientSideState)
    {
        var ri = LastRenderInfo;
        if (ri == null || clientSideState.RenderIndex < ri.RenderIndex)
            return;

        var entrySizeChanged = false;
        foreach (var (key, size) in clientSideState.ItemSizes) {
            // ReSharper disable once CompareOfFloatsByEqualityOperator
            if (!ri.EntryByKey.TryGetValue(key, out var entry) || entry.Size == size)
                continue;
            entry.Size = size;
            TotalMeasuredItemSize += size;
            TotalMeasuredItemCount++;
            entrySizeChanged = true;
        }
        var viewportChanged = clientSideState.Viewport != ri.Viewport;
        if (viewportChanged)
            ri.Viewport = clientSideState.Viewport;
        if (entrySizeChanged)
            StateHasChanged();
        if (viewportChanged || entrySizeChanged || ri.ShownEntries.Count == 0)
            TryRecomputeState();
    }

    protected void TryRecomputeState()
    {
        if (!State.Computed.IsConsistent()) // Already recomputing
            return;
        NextQuery = GetQuery();
        if (LastQuery != NextQuery)
            State.Recompute().Ignore();
    }

    protected virtual VirtualListQuery GetQuery()
    {
        var ri = LastRenderInfo;
        if (ri == null)
            return new VirtualListQuery(default);
        if (ri.ShownEntries.Count == 0)
            return LastQuery!;

        var loaderZone = new Range<double>(ri.Viewport.Start - LoadZoneSize, ri.Viewport.End + LoadZoneSize);
        var entryRanges = GetEntryRanges(ri.ShownEntries).ToList();
        var (firstEntry, firstRange) = entryRanges.FirstOrDefault(p => p.Range.IntersectWith(loaderZone).Size() > 0);
        var (lastEntry, lastRange) = entryRanges.LastOrDefault(p => p.Range.IntersectWith(loaderZone).Size() > 0);
        if (firstEntry == null!) {
            // All entries are outside of the loader zone
            if (entryRanges[0].Range.Start >= loaderZone.End) {
                // And they go after the loader zone
                (firstEntry, firstRange) = entryRanges[0];
                (lastEntry, lastRange) = entryRanges[0];
            } else {
                // They go before the loader zone
                (firstEntry, firstRange) = entryRanges[^1];
                (lastEntry, lastRange) = entryRanges[^1];
            }
        }
        var keyRange = new Range<string>(firstEntry.Key, lastEntry.Key);
        var itemSize = MeanItemSize;
        var startGap = Math.Max(0, (firstRange.Start - loaderZone.Start) / itemSize);
        var endGap = Math.Max(0, (loaderZone.End - lastRange.End) / itemSize);
        return new VirtualListQuery(keyRange) {
            ExpandStartBy = Math.Round(startGap, 1),
            ExpandEndBy = Math.Round(endGap, 1),
        };
    }

    protected virtual RenderInfo GetNextRenderInfo()
    {
        var ri = new RenderInfo();
        var lri = LastRenderInfo;
        var response = State.LatestNonErrorValue ?? new();
        if (lri == null) {
            // First render
            ri.RenderIndex = 0;
            ri.Response = response;
            ri.Entries = response.Items.Select(i => new Entry { Key = i.Key, Item = i.Value }).ToList();
            ri.EntryByKey = ri.Entries.ToImmutableDictionary(e => e.Key);
            ri.MeasuringEntries = ri.Entries.Where(e => !e.IsSizeMeasured).ToList();
            ri.ShownEntries = ri.Entries.Where(e => e.IsSizeMeasured).ToList();
            ri.ShownEntriesSize = ri.Entries.Sum(e => e.Size);
            ri.Viewport = new(0, ri.ShownEntriesSize);
            ri.SpacerSize = SpacerSize;
            ri.MustScrollWhenAnyShownEntries = true;
        }
        else {
            ri.RenderIndex = lri.RenderIndex + 1;
            ri.Response = response;
            ri.Viewport = lri.Viewport;
            ri.SpacerSize = lri.SpacerSize;
            ri.MustScrollWhenAnyShownEntries = lri.MustScrollWhenAnyShownEntries;
            if (!ReferenceEquals(lri.Response, response)) {
                ri.Entries = new List<Entry>();
                ri.EntryByKey = ImmutableDictionary<string, Entry>.Empty;
                foreach (var (key, item) in response.Items) {
                    var entry = lri.EntryByKey.GetValueOrDefault(key) ?? new Entry { Key = key, Item = item };
                    ri.Entries.Add(entry);
                    ri.EntryByKey = ri.EntryByKey.Add(key, entry);
                }
            }
            else {
                ri.Entries = lri.Entries;
                ri.EntryByKey = lri.EntryByKey;
            }
            ri.MeasuringEntries = ri.Entries.Where(e => !e.IsSizeMeasured).ToList();
            ri.ShownEntries = ri.Entries.Where(e => e.IsSizeMeasured).ToList();
            ri.ShownEntriesSize = ri.Entries.Sum(e => e.Size);
            // Adjust the new spacer size:
            // 1. Find the first entry in lri.ShownEntries that exists in ri.ShownEntries
            var (sharedEntry, oldRange) = GetEntryRanges(lri.ShownEntries)
                .FirstOrDefault(p => ri.EntryByKey.ContainsKey(p.Entry.Key));
            if (sharedEntry != null!) {
                // 2. Compute its new range
                var (_, newRange) = GetEntryRanges(ri.ShownEntries).Single(p => p.Entry == sharedEntry);
                // 3. Compute new spacer size
                ri.SpacerSize += oldRange.Start - newRange.Start;
            }
            else {
                // Everything is new, so let's scroll to the very top
                ri.SpacerSize = SpacerSize;
                ri.Viewport = new(0, lri.Viewport.Size());
                ri.MustScrollWhenAnyShownEntries = true;
            }
            if (ri.MustScrollWhenAnyShownEntries && ri.ShownEntries.Count > 0) {
                ri.SpacerSize = SpacerSize;
                ri.Viewport = new(0, lri.Viewport.Size());
                ri.MustScroll = true;
                ri.MustScrollWhenAnyShownEntries = false;
            }
            if (ri.Response.HasVeryFirstItem)
                ri.SpacerSize = 0;
        }
        return ri;
    }

    protected static IEnumerable<(Entry Entry, Range<double> Range)> GetEntryRanges(List<Entry> entries)
    {
        var range = default(Range<double>);
        foreach (var entry in entries) {
            range = new(range.End, range.End + entry.Size);
            yield return (entry, range);
        }
    }
}
