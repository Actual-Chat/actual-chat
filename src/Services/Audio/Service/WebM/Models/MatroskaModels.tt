<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".cs" encoding="utf-8" #>
<#@ Assembly Name="System.Core.dll" #>
<#@ Assembly Name="System.Xml.dll" #>
<#@ Assembly Name="System.Xml.Linq.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Text" #>
<#
    string XmlFile = "../ebml.xml";
    string MatroskaXmlFile = "../ebml_matroska.xml";
    XNamespace ns = "urn:ietf:rfc:8794";
#>
using System;
using System.Collections.Generic;
using System.CodeDom.Compiler;
using System.Runtime.CompilerServices;
// ReSharper disable UnusedAutoPropertyAccessor.Global
// ReSharper disable InconsistentNaming
// ReSharper disable ClassNeverInstantiated.Global
// ReSharper disable IdentifierTypo


//--------------------------------------------------------------------------------------------------------
// <auto-generated>
//     This C# code class was auto-generated at <#= DateTime.Now #>.
//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
//
//     Based on "https://github.com/ietf-wg-cellar/matroska-specification/blob/master/ebml_matroska.xml".
// </auto-generated>
//--------------------------------------------------------------------------------------------------------
namespace ActualChat.Audio.WebM.Models
{
<#
    var isList = new List<string>
    {
        "Seek",
        "Cluster",
        "TrackEntry",
        "SimpleBlock",
        "Block",
        "BlockAdditional",
        "BlockGroup",
        "BlockVirtual",
        "EncryptedBlock",
        "Tag",
        "SimpleTag",
        "Target",
        "ContentCompression",
        "ContentEncoding",
        "CuetrackPosition",
        "CuePoint",
        "CueReference",
        "SignatureSlot",
        "SignatureElementList",
        "SignedElement"
    };

    var isRoot = new List<string>
    {
        "EBML",
        "Segment",
        "Cluster"
    };

    var elementsEbml = XElement.Load(Path.Combine(Path.GetDirectoryName(this.Host.TemplateFile), XmlFile)).Elements()
        .Select(e => new Element
        { 
            Name = e.Attribute("name").Value.Replace("CRC-32", "CRC32"),
            UseNameInsteadOfBinary = UseNameInsteadOfBinary(e.Attribute("name").Value),
            IsList = isList.Contains(e.Attribute("name").Value),
            IsRoot = isRoot.Contains(e.Attribute("name").Value),
            Path = e.Attribute("path").Value,
            Level = e.Attribute("path").Value.Count(c => c == '\\'),
            Id = e.Attribute("id").Value,
            ElementType = e.Attribute("type").Value,
            Required = (e.Attribute("minOccurs") != null ? int.Parse(e.Attribute("minOccurs").Value) : 0) > 0,
            Documentation = e.Element(ns + "documentation") != null ? e.Element(ns + "documentation").Value : ""
        });

    var elementsMatroska = XElement.Load(Path.Combine(Path.GetDirectoryName(this.Host.TemplateFile), MatroskaXmlFile)).Elements()
        .Select(e => new Element
        { 
            Name = e.Attribute("name").Value,
            UseNameInsteadOfBinary = UseNameInsteadOfBinary(e.Attribute("name").Value),
            IsList = isList.Contains(e.Attribute("name").Value),
            IsRoot = isRoot.Contains(e.Attribute("name").Value),
            Path = e.Attribute("path").Value,
            Level = e.Attribute("path").Value.Count(c => c == '\\'),
            Id = e.Attribute("id").Value,
            ElementType = e.Attribute("type").Value,
            Required = (e.Attribute("minOccurs") != null ? int.Parse(e.Attribute("minOccurs").Value) : 0) > 0,
            Documentation = e.Element(ns + "documentation") != null ? e.Element(ns + "documentation").Value : ""
        });

    var elements = elementsEbml.Union(elementsMatroska).Concat(new[]
    {
        new Element { 
            Name = "Unknown",
            UseNameInsteadOfBinary = false,
            IsList = false,
            IsRoot = false,
            Path = string.Empty,
            Level = 0,
            Id = "0x7FFF",
            ElementType = "None",
            Required = false,
            Documentation = "Unknown element"
        }
    }).ToList();

    var deprecated = new List<string> { "TrackTimestampScale" };
   
    var ebml = elements.FirstOrDefault(e => e.Name == "EBML");
    Loop(elements, ebml, "", deprecated);

    var segment = elements.FirstOrDefault(e => e.Name == "Segment");
    Loop(elements, segment, "", deprecated);
    
    var skip = new List<string> { "Block", "SimpleBlock", "SimpleTag", "TrackTimestampScale" };

    foreach (var master in elements.Where(e => (e.ElementType == "master" || e.ElementType == "None") && !skip.Contains(e.Name)).OrderBy(e => e.Path))
    {
        var className = master.Name;
        if (className == "Tag")
        {
            className = "TagItem";
        }
        if (className == "ContentEncoding")
        {
            className = "ContentEncodingItem";
        }
#>
    [GeneratedCode("MatroskaModels.tt", "1.0.0.0")]
    [MatroskaElementDescriptor(MatroskaSpecification.<#=master.Name#>)]
    public sealed class <#=className#> : <#= master.IsRoot ? "RootEntry" : "BaseModel"#>
    {
        public override ElementDescriptor Descriptor => MatroskaSpecification.<#=master.Name#>Descriptor;

<#
        var subs = master.SubElements.Where(sub => !sub.IsRoot);
        foreach (var sub in subs)
        {
            string field = sub.Name;
            if (sub.Name == "Tag")
            {
                field = "TagItem";
            }
            if (sub.Name == "ContentEncoding")
            {
                field = "ContentEncodingItem";
            }

            string a;
            if (sub.IsList && field != "SignedElement")
            {
                a = string.Format(new string(' ', 8) + "[MatroskaElementDescriptor(MatroskaSpecification.{0}, typeof({1}))]", sub.Name, field);
            }
            else
            {
                a = string.Format(new string(' ', 8) + "[MatroskaElementDescriptor(MatroskaSpecification.{0})]", sub.Name);
            }
            WriteLine(a);
            WriteLine(new string(' ', 8) + GetProperty(sub, field));
            if (sub != subs.Last())
            {
                WriteLine("");
            }
        }
#>

        public override ulong GetSize() {
            var size = 0UL;
<#
        foreach (var sub in subs)
        {
            string field = sub.Name;
            if (sub.Name == "Tag")
            {
                field = "TagItem";
            }
            if (sub.Name == "ContentEncoding")
            {
                field = "ContentEncodingItem";
            }

            var stringEncoding = string.Empty;
            if (sub.ElementType == "string")
            {
                stringEncoding = ", true";
            }
            else if (sub.ElementType == "utf-8")
            {
                stringEncoding = ", false";
            }
            
            var name = Pluralize(sub, field);

            if (sub.ElementType != "master" && !(sub.ElementType == "binary" && sub.UseNameInsteadOfBinary))
            {
#>
            size += EbmlHelper.GetElementSize(MatroskaSpecification.<#= sub.Name #>, <#= sub.Name == "TrackType" ? "(ulong?)" : ""#><#= name #><#= stringEncoding #>);
<#
            }
            else
            {
#>
            size += <#= name #><#= sub.Required ? "" : "?"#>.GetSize()<#= sub.Required ? "" : "?? 0UL"#>;
<#
            }
        }
#>
            return size;
        }
    }

<#  } #>

    public static class ModelExtensions
    {

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Write(this BaseModel? model, ref SpanWriter writer)
        {
            if (model == null)
                return true;
            
            switch (model.Descriptor.Identifier.EncodedValue) {
<#

    var masters = elements.Where(e => e.ElementType == "master" && !skip.Contains(e.Name)).OrderBy(e => e.Path).ToList();

    foreach (var master in masters)
    {
        var hasSubs = master.SubElements.Any(sub => !sub.IsRoot);
        if (!hasSubs)
            continue;
        
        var className = master.Name;
        if (className == "Tag")
        {
            className = "TagItem";
        }
        if (className == "ContentEncoding")
        {
            className = "ContentEncodingItem";
        }
#>
                case MatroskaSpecification.<#=master.Name#>:
                    return ((<#=className#>)model).Write(ref writer);
<#
    }
#>
                default:
                    throw new EbmlDataFormatException($"Unexpected ebml element '{model.Descriptor.Identifier}'");
            }
        }

<#
    foreach (var master in elements.Where(e => e.ElementType == "master" && !skip.Contains(e.Name)).OrderBy(e => e.Path))
    {
        var className = master.Name;
        if (className == "Tag")
        {
            className = "TagItem";
        }
        if (className == "ContentEncoding")
        {
            className = "ContentEncodingItem";
        }
#>
      
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Write(this <#= className#>? model, ref SpanWriter writer)
        {
            if (model == null)
                return true;
            
            if (!EbmlHelper.WriteEbmlMasterElement(MatroskaSpecification.<#=master.Name#>, model.GetSize(), ref writer))
                return false;
<#
        var subs = master.SubElements.Where(sub => !sub.IsRoot).ToList();
        if (subs.Count > 0)
        {
            foreach (var sub in subs)
            {
                string field = sub.Name;
                if (sub.Name == "Tag")
                {
                    field = "TagItem";
                }
                if (sub.Name == "ContentEncoding")
                {
                    field = "ContentEncodingItem";
                }
                
                var stringEncoding = string.Empty;
                if (sub.ElementType == "string")
                {
                    stringEncoding = ", true";
                }
                else if (sub.ElementType == "utf-8")
                {
                    stringEncoding = ", false";
                }
                
                var name = Pluralize(sub, field);
                if (sub.ElementType != "master" && !(sub.ElementType == "binary" && sub.UseNameInsteadOfBinary))
                {
#>
            EbmlHelper.WriteEbmlElement(MatroskaSpecification.<#= sub.Name #>, <#= sub.Name == "TrackType" ? "(ulong?)" : ""#>model.<#= name #><#= stringEncoding #>, ref writer);
<#
                }
                else
                {
#>
            model.<#= name #><#= sub.Required ? "" : "?"#>.Write(ref writer);
<#
                }
            }
        }
#>            
            return true;
        }
<#
    }
#>


        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static BaseModel CreateInstance(this ElementDescriptor descriptor)
        {
            if (descriptor.Type != ElementType.MasterElement)
                throw new InvalidOperationException("Can't create instances of non-master element");

            switch (descriptor.Identifier.EncodedValue) {
<#
    foreach (
        var master in elements.Where(e => e.ElementType == "master" && !skip.Contains(e.Name)).OrderBy(e => e.Path))
    {
        var className = master.Name;
        if (className == "Tag")
        {
            className = "TagItem";
        }
        if (className == "ContentEncoding")
        {
            className = "ContentEncodingItem";
        }
#>
                case MatroskaSpecification.<#=master.Name#>:
                    return new <#=className#>();
<#
    }
#>
                default:
                    throw new InvalidOperationException("Unknown master element: " + descriptor.Identifier);
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void FillScalar(this BaseModel model, ElementDescriptor containerDescriptor, ElementDescriptor descriptor, int size, ref SpanReader reader)
        {
            switch (containerDescriptor.Identifier.EncodedValue) {
<#
    foreach (var master in masters)
    {
        var hasSubs = master.SubElements.Any(sub => !sub.IsRoot && sub.ElementType != "master" && !sub.IsList);
        if (!hasSubs)
            continue;
        
        var className = master.Name;
        if (className == "Tag")
        {
            className = "TagItem";
        }
        if (className == "ContentEncoding")
        {
            className = "ContentEncodingItem";
        }
#>
                case MatroskaSpecification.<#=master.Name#>:
                    ((<#=className#>)model).FillScalar(descriptor, size, ref reader);
                    break;
<#
    }
#>
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void FillComplex(this BaseModel model, ElementDescriptor containerDescriptor, ElementDescriptor descriptor, BaseModel propertyModel)
        {
            switch (containerDescriptor.Identifier.EncodedValue) {
<#
    foreach (var master in masters)
    {
        var hasComplex = master.SubElements.Any(sub => !sub.IsRoot && sub.ElementType == "master" && !sub.IsList);
        if (!hasComplex)
            continue;
        
        var className = master.Name;
        if (className == "Tag")
        {
            className = "TagItem";
        }
        if (className == "ContentEncoding")
        {
            className = "ContentEncodingItem";
        }
#>
                case MatroskaSpecification.<#=master.Name#>:
                    ((<#=className#>)model).FillComplex(descriptor, propertyModel);
                    break;
<#
    }
#>
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void FillListEntry(this BaseModel model, ElementDescriptor containerDescriptor, ElementDescriptor descriptor, object listEntry)
        {
            switch (containerDescriptor.Identifier.EncodedValue) {
<#
    foreach (var master in masters)
    {
        var hasList = master.SubElements.Any(sub => !sub.IsRoot && sub.IsList);
        if (!hasList)
            continue;
        
        var className = master.Name;
        if (className == "Tag")
        {
            className = "TagItem";
        }
        if (className == "ContentEncoding")
        {
            className = "ContentEncodingItem";
        }
#>
                case MatroskaSpecification.<#=master.Name#>:
                    ((<#=className#>)model).FillListEntry(descriptor, listEntry);
                    break;
<#
    }
#>
            }
        }

<#
    foreach (var master in masters)
    {
        var className = master.Name;
        if (className == "Tag")
        {
            className = "TagItem";
        }
        if (className == "ContentEncoding")
        {
            className = "ContentEncodingItem";
        }
        var subs =
            master.SubElements.Where(sub => !sub.IsRoot && sub.ElementType != "master" && !sub.IsList).ToList();
        if (subs.Count > 0)
        {
#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static void FillScalar(this <#= className #> model, ElementDescriptor descriptor, int size, ref SpanReader reader)
        {
            if (descriptor.Type == ElementType.MasterElement)
                throw new InvalidOperationException("Can't read master elements directly from the reader");
            
            switch (descriptor.Identifier.EncodedValue) {
<#
            foreach (var sub in subs)
            {
                string field = sub.Name;
                if (sub.Name == "Tag")
                {
                    field = "TagItem";
                }
                if (sub.Name == "ContentEncoding")
                {
                    field = "ContentEncodingItem";
                }
                var propertyName = Pluralize(sub, field);
                var methodSuffix = sub.ElementType switch
                {
                    "utf-8" => "Utf8String(size)!",
                    "string" => "AsciiString(size)!",
                    "binary" => "Bytes(size)!",
                    "date" => "DateTime()!.Value",
                    "float" => "Float(size)!.Value",
                    "uinteger" => "ULong(size)!.Value",
                    "integer" => "Long(size)!.Value",
                    _ => "???"
                };
                var methodPrefix = sub.Name == "TrackType" 
                    ? "(TrackType?)" 
                    : string.Empty;
#>
                case MatroskaSpecification.<#= sub.Name #>:
                    model.<#= propertyName #> = <#= methodPrefix #>reader.Read<#= methodSuffix #>;
                    break;
<#
            }
#>
                default:
                    throw new EbmlDataFormatException($"Unexpected ebml element '{descriptor.Identifier}'");
            }
        }

<#
        }
        var complexSubs =
            master.SubElements.Where(sub => !sub.IsRoot && sub.ElementType == "master" && !sub.IsList)
                .ToList();
        if (complexSubs.Count > 0)
        {
#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static void FillComplex(this <#= className #> model, ElementDescriptor descriptor, BaseModel propertyModel)
        {
            if (descriptor.Type != ElementType.MasterElement)
                throw new InvalidOperationException("ElementDescriptor should have 'master' type");
            
            switch (descriptor.Identifier.EncodedValue) {
<#
            foreach (var sub in complexSubs)
            {
                string field = sub.Name;
                if (sub.Name == "Tag")
                {
                    field = "TagItem";
                }
                if (sub.Name == "ContentEncoding")
                {
                    field = "ContentEncodingItem";
                }
                var propertyName = Pluralize(sub, field);
                var optionalSuffix = sub.Required ? string.Empty : "?";
                var cast = $"({field}{optionalSuffix})";
#>
                case MatroskaSpecification.<#= sub.Name #>:
                    model.<#= propertyName #> = <#=cast#>propertyModel;
                    break;
<#
            }
#>
                default:
                    throw new EbmlDataFormatException($"Unexpected ebml element '{descriptor.Identifier}'");
            }
        }

<#
        }
        
        var listSubs =
            master.SubElements.Where(sub => !sub.IsRoot && sub.IsList)
                .ToList();
        if (listSubs.Count > 0)
        {
#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static void FillListEntry(this <#= className #> model, ElementDescriptor descriptor, object listItem)
        {
            if (descriptor.Type != ElementType.MasterElement && descriptor.Type != ElementType.Binary)
                throw new InvalidOperationException("ElementDescriptor should have 'master' or 'binary' type");
            
            switch (descriptor.Identifier.EncodedValue) {
<#
            foreach (var sub in listSubs)
            {
                string field = sub.Name;
                if (sub.Name == "Tag")
                {
                    field = "TagItem";
                }
                if (sub.Name == "ContentEncoding")
                {
                    field = "ContentEncodingItem";
                }
                var propertyName = Pluralize(sub, field);
                var propertyType = GetPropertyType(sub, field);
                var cast = $"({propertyType})";
#>
                case MatroskaSpecification.<#= sub.Name #>:
                {
                    var list = model.<#= propertyName #> as IList<<#=field#>> ?? new List<<#=field#>>(4);
                    list.Add((<#=field#>)listItem);
                    model.<#= propertyName #> = <#=cast#>list;
                    break;
                }
<#
            }
#>
                default:
                    throw new EbmlDataFormatException($"Unexpected ebml element '{descriptor.Identifier}'");
            }
        }

<#
        }

    }
    
    
#>
    }
}

<#+
    public bool UseNameInsteadOfBinary(string elementName)
    {
        return elementName.Contains("Block") && elementName != "BlockAddIDExtraData";
    }

    public void Loop(List<Element> all, Element current, string parentPath, List<string> skip)
    {
        current.SubElements = all
            .Where(e => e.Path.StartsWith(parentPath + "\\" + current.Name) && e.Level == current.Level + 1)
            .Where(s => !skip.Contains(s.Name))
            .ToList();
        foreach (var sub in current.SubElements)
        {
            Loop(all, sub, current.Path, skip);
        }
    }

    public string GetProperty(Element property, string field)
    {
        var propertyType = GetPropertyType(property, field);
        var name = Pluralize(property, field);

        string fixRequired = "";
        if (property.Required && !propertyType.Contains("long") && !propertyType.Contains("double") && !propertyType.Contains("TrackType"))
        {
            fixRequired = " = null!;";
        }

        return "public " + propertyType + " " + name + " { get; set; }" + fixRequired;
    }

    public string GetPropertyType(Element property, string field)
    {
        string propertyType;
        switch (property.ElementType)
        {
            case "utf-8":
                propertyType = "string";
                break;

            case "string":
                propertyType = "string";
                break;

            case "binary":
                propertyType = property.UseNameInsteadOfBinary ? field : "byte[]";
                break;

            case "date":
                propertyType = "DateTime";
                break;

            case "float":
                propertyType = "double";
                break;

            case "uinteger":
                propertyType = property.Name == "TrackType" ? "TrackType" : "ulong";
                break;

            case "integer":
                propertyType = "long";
                break;

            case "master":
                propertyType = field;
                break;
            
            default:
                propertyType = "???";
                break;
        }

        if (property.IsList)
        {
            return $"IReadOnlyList<{propertyType}>" + (!property.Required ? "?" : "");
        }
        return propertyType + (!property.Required || propertyType == "TrackType" ? "?" : "");
    }

    public string Pluralize(Element property, string field)
    {
        var name = field;
        if (property.IsList)
        {
            if (property.Name.EndsWith("y"))
            {
                name = property.Name.Replace("y", "ies");
            }
            else
            {
                name = name + "s";
            }
        }
        return name;
    }


    public class Element
    {
        public string Name;
        public bool UseNameInsteadOfBinary;
        public bool IsList;
        public bool IsRoot;
        public string Path;
        public string Id;
        public string ElementType;
        public bool Required;
        public string Documentation;
        public int Level;       

        public List<Element> SubElements = new List<Element>();
    }
#>