@page "/voice"
@inherits ComputedStateComponent<int>
@using Stl.Async
@using Stl.Text
@using Stl.Time
@using ActualChat.Distribution
@using System.Threading.Channels
@implements IAudioRecorderBackend
@inject IJSRuntime _js
@inject JSModule _jsModule;
@inject IAudioRecorder _audioRecorder
@inject Session _session
@inject UICommandRunner _cmd
@inject ILogger<AudioPage> _log
@inject IAudioStreamingService _audioStreaming

<h1>Voice Transcription</h1>

<AuthorizeView>
    <NotAuthorized>
        <SignInDropdown Why="to use this page" />
    </NotAuthorized>
    <Authorized>
        <Row>
            <Column ColumnSize="ColumnSize.Is6.OnDesktop.Is12.OnTablet">
                <Paragraph>
                </Paragraph>

                <Form @onsubmit="StartRecording" Margin="Margin.Is3.OnY">
                    <Addons>
                        <Addon AddonType="AddonType.Start">
                            <Button Type="@ButtonType.Button" Clicked="ToggleRecording" Color="@ToggleColor">
                                <Blazorise.Icon Name="@FontAwesomeIcons.Microphone"/>
                                @ToggleText
                            </Button>
                        </Addon>
                    </Addons>
                </Form>
            </Column>
        </Row>
    </Authorized>
</AuthorizeView>

@code {
    private IJSObjectReference? ModuleRef { get; set; }
    private DotNetObjectReference<IAudioRecorderBackend>? ComponentRef { get; set; }
    private ChannelWriter<AudioMessage>? Writer { get; set; }
    private int Index { get; set; }

    private bool IsRecording { get; set; } = false;
    private Color ToggleColor { get; set; } = Color.Secondary;
    private string ToggleText { get; set; } = "Start Recording";

    public override void Dispose()
    {
        base.Dispose();
        ComponentRef?.Dispose();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (ModuleRef != null || !firstRender)
            return;
        ModuleRef = await _jsModule.Import(typeof(AudioPage).Assembly, "js/audio-recorder.js");
        ComponentRef = DotNetObjectReference.Create<IAudioRecorderBackend>(this);
        await ModuleRef.InvokeVoidAsync("initialize", ComponentRef);
    }

    protected override Task<int> ComputeState(CancellationToken cancellationToken)
    {
        return Task.FromResult(1);
    }

    private async Task StartRecording()
    {
        await ModuleRef!.InvokeVoidAsync("startRecording");
    }

    private async Task StopRecording()
    {
        await ModuleRef!.InvokeVoidAsync("stopRecording");
    }

    private async Task ToggleRecording()
    {
        if (IsRecording)
        {
            await StopRecording();
            ToggleColor = Color.Secondary;
            ToggleText = "Start Recording";
        }
        else
        {
            await StartRecording();
            ToggleColor = Color.Primary;
            ToggleText = "Recording...";
        }
        IsRecording = !IsRecording;

        StateHasChanged();
    }

    [JSInvokable]
    public Task RecordingStarted()
    {
        if (Writer == null)
        {
            // var result = await _cmd.Run(new InitializeAudioRecorderCommand
            // {
            //     Session = _session,
            //     AudioFormat = new AudioFormat { Codec = AudioCodec.Opus, ChannelCount = 1, SampleRate = 48_000 },
            //     ClientStartOffset = CpuClock.Now
            // });
            //
            // RecordingId = result.Result;
            
            var channel = Channel.CreateBounded<AudioMessage>(
                new BoundedChannelOptions(100) {
                    FullMode = BoundedChannelFullMode.Wait,
                    SingleReader = true,
                    SingleWriter = true,
                    AllowSynchronousContinuations = true
                });
            Writer = channel.Writer;

            var audioConfig = new AudioRecordingConfiguration(
                new AudioFormat { Codec = AudioCodec.Opus, ChannelCount = 1, SampleRate = 48_000 },
                "RU-ru",
                CpuClock.Now.EpochOffset.TotalSeconds);
            _ = _audioStreaming.UploadStream(audioConfig, channel.Reader, CancellationToken.None);

            // var reader = await _audioStreaming.GetStream($"{RecordingId}-0000", CancellationToken.None);
            // await foreach (var audioMessage in reader.ReadAllAsync()) {
            //     Console.WriteLine($"Got from server: {audioMessage.Chunk.Length} bytes");
            // }
        }
        
        return Task.CompletedTask;
    }

    [JSInvokable]
    public async Task AudioDataAvailable(string dataAsBase64)
    {
        if (Writer != null) {
            var base64 = Base64Encoded.Decode(dataAsBase64);

            await Writer.WriteAsync(new AudioMessage(Index++, CpuClock.Now.EpochOffset.TotalSeconds, base64.Data));
        }
    }

    [JSInvokable]
    public Task RecordingStopped()
    {
        // _cmd.Run(new CompleteAudioRecording(RecordingId)).Ignore();

        Writer?.Complete();
        Writer = null;
        return Task.CompletedTask;
    }
}
