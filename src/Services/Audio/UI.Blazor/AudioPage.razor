@page "/voice"
@inherits ComputedStateComponent<int>
@using Stl.Async
@using Stl.Text
@using Stl.Time
@using ActualChat.Distribution
@implements IAudioRecorderBackend
@inject IJSRuntime _js
@inject JSModule _jsModule;
@inject IAudioRecorder _audioRecorder
@inject Session _session
@inject UICommandRunner _cmd
@inject ILogger<AudioPage> _log
@inject IStreamingService<AudioMessage> _audioStreaming

<h1>Voice Transcription</h1>

<AuthorizeView>
    <NotAuthorized>
        <SignInDropdown Why="to use this page" />
    </NotAuthorized>
    <Authorized>
        <Row>
            <Column ColumnSize="ColumnSize.Is6.OnDesktop.Is12.OnTablet">
                <Paragraph>
                </Paragraph>

                <Form @onsubmit="StartRecording" Margin="Margin.Is3.OnY">
                    <Addons>
                        <Addon AddonType="AddonType.Start">
                            <Button Type="@ButtonType.Button" Clicked="ToggleRecording" Color="@ToggleColor">
                                <Blazorise.Icon Name="@FontAwesomeIcons.Microphone"/>
                                @ToggleText
                            </Button>
                        </Addon>
                    </Addons>
                </Form>
            </Column>
        </Row>
    </Authorized>
</AuthorizeView>

@code {
    private IJSObjectReference? ModuleRef { get; set; }
    private DotNetObjectReference<IAudioRecorderBackend>? ComponentRef { get; set; }
    private Symbol RecordingId { get; set; } = Symbol.Empty;
    private int Index { get; set; } = 0;

    private bool IsRecording { get; set; } = false;
    private Color ToggleColor { get; set; } = Color.Secondary;
    private string ToggleText { get; set; } = "Start Recording";

    public override void Dispose()
    {
        base.Dispose();
        ComponentRef?.Dispose();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (ModuleRef != null || !firstRender)
            return;
        ModuleRef = await _jsModule.Import(typeof(AudioPage).Assembly, "js/audio-recorder.js");
        ComponentRef = DotNetObjectReference.Create<IAudioRecorderBackend>(this);
        await ModuleRef.InvokeVoidAsync("initialize", ComponentRef);
    }

    protected override Task<int> ComputeState(CancellationToken cancellationToken)
    {
        return Task.FromResult(1);
    }

    private async Task StartRecording()
    {
        await ModuleRef!.InvokeVoidAsync("startRecording");
    }

    private async Task StopRecording()
    {
        await ModuleRef!.InvokeVoidAsync("stopRecording");
    }

    private async Task ToggleRecording()
    {
        if (IsRecording)
        {
            await StopRecording();
            ToggleColor = Color.Secondary;
            ToggleText = "Start Recording";
        }
        else
        {
            await StartRecording();
            ToggleColor = Color.Primary;
            ToggleText = "Recording...";
        }
        IsRecording = !IsRecording;

        StateHasChanged();
    }

    [JSInvokable]
    public async Task RecordingStarted()
    {
        if (RecordingId.IsEmpty)
        {
            var result = await _cmd.Run(new InitializeAudioRecorderCommand
            {
                Session = _session,
                AudioFormat = new AudioFormat { Codec = AudioCodec.Opus, ChannelCount = 1, SampleRate = 16_000 },
                ClientStartOffset = CpuClock.Now
            });

            RecordingId = result.Result;

            var reader = await _audioStreaming.GetStream($"{RecordingId}-0000", CancellationToken.None);
            await foreach (var audioMessage in reader.ReadAllAsync()) {
                Console.WriteLine($"Got from server: {audioMessage.Chunk.Length} bytes");
            }
        }
    }

    [JSInvokable]
    public Task AudioDataAvailable(string dataAsBase64)
    {
        _cmd.Run(new AppendAudioCommand(RecordingId, Index++, CpuClock.Now, dataAsBase64)).Ignore();

        return Task.CompletedTask;
    }

    [JSInvokable]
    public Task RecordingStopped()
    {
        _cmd.Run(new CompleteAudioRecording(RecordingId)).Ignore();

        RecordingId = Symbol.Empty;
        return Task.CompletedTask;
    }
}
