@using System.Threading.Channels
@using Stl
@inject IJSRuntime _js
@inject JSModule _jsModule;
@inject IAudioStreamProvider _streamProvider
@inject BlazorCircuitContext _circuitContext

<audio id="player"></audio>

@code {
    private CancellationTokenSource? _cancellationTokenSource;
    private IJSObjectReference ModuleRef { get; set; } = null!;
    
    [Parameter]
    public string StreamId { get; set; } = null!;
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (ModuleRef != null! || !firstRender)
            return;
        ModuleRef = await _jsModule.Import(typeof(AudioPage).Assembly, "js/audio-player.js");
        await ModuleRef.InvokeVoidAsync("initialize");
    }


    protected override async Task OnParametersSetAsync()
    {
        await base.OnParametersSetAsync();
        
        if (!_circuitContext.IsPrerendering && !StreamId.IsNullOrEmpty()) {
            _cancellationTokenSource = new CancellationTokenSource();
            var audioReader = await _streamProvider.GetStream(StreamId, _cancellationTokenSource.Token);
            _ = ReadAudio(audioReader, _cancellationTokenSource.Token);
        }
    }

    private Task AppendAudio(byte[] chunk)
    {
        return ModuleRef.InvokeVoidAsync("appendAudio", chunk).AsTask();
    }
    
    private async Task ReadAudio(ChannelReader<BlobPart> audioReader, CancellationToken cancellationToken)
    {
        try {
            while (await audioReader.WaitToReadAsync(cancellationToken))
            while (audioReader.TryRead(out var blob)) {
                cancellationToken.ThrowIfCancellationRequested();

                await AppendAudio(blob.Data);
            }
        }
        catch (ChannelClosedException) { }
    }
    
}