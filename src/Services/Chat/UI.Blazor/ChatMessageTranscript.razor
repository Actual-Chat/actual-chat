@using ActualChat.Streaming
@using System.Threading.Channels

@inject IStreamingService<TranscriptMessage> _streamingService
@inject BlazorCircuitContext _circuitContext

<span class="content">@Text</span>

@code {
    private CancellationTokenSource? _cancellationTokenSource;
    private string Text { get; set; } = "...";
    
    [Parameter]
    public string StreamId { get; set; } = null!;


    protected override async Task OnParametersSetAsync()
    {
        if (_cancellationTokenSource != null) {
            // we should never call those statements
            _cancellationTokenSource.Cancel();
            _cancellationTokenSource.Dispose();
        }
        if (!_circuitContext.IsPrerendering) {
            _cancellationTokenSource = new CancellationTokenSource();
            var transcriptReader = await _streamingService.GetStream(StreamId, _cancellationTokenSource.Token);
            _ = ReadTranscript(transcriptReader, _cancellationTokenSource.Token);
        }

        await base.OnParametersSetAsync();

    }

    private async Task ReadTranscript(ChannelReader<TranscriptMessage> transcriptReader, CancellationToken token)
    {
        try {
            while (await transcriptReader.WaitToReadAsync(token))
            while (transcriptReader.TryRead(out var message)) {
                token.ThrowIfCancellationRequested();

                var (text, index, _, _) = message;
                Text = Text.Length >= index 
                    ? $"{Text[..index]}{text}" 
                    : $"{Text}{text.PadLeft(index - Text.Length + text.Length)}";
                
                StateHasChanged();
            }
        }
        catch (ChannelClosedException) { }
    }

}