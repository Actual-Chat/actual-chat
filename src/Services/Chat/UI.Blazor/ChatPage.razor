@page "/chat"
@page "/chat/{ChatId}"
@using ActualChat.Comparison
@using Stl.Mathematics
@inherits ComputedStateComponent<ChatPageModel>
@inject IChatService _chats
@inject IAuthService _auth
@inject Session _session
@inject UICommandRunner _cmd
@inject NavigationManager _nav
@inject ILogger<ChatPage> _log

@{
    var error = State.Error;
    var model = State.LatestNonErrorValue;
    if (model.IsUnavailable)
        _nav.Unavailable("chat");
    if (model.MustLogin)
        _nav.Login("to view this chat");
    var chat = model.Chat ?? new();
}

<div class="chat-page">
    <div class="header">
        <h1>"@(chat.Title.NullIfEmpty() ?? "Loading...")" chat</h1>

        <WhenError Error="@error"/>
    </div>
    <div class="content">
        <VirtualList
            SpacerSize="6000" LoadZoneSize="2000" BufferZoneSize="4000"
            Provider="GetMessages"
            KeyComparer="LongAsStringKeyComparer.Default">
            <Item>
                <div class="message">
                    <UserNameBadge UserId="@context.Value.CreatorId"/>
                    <span class="content">@context.Value.Content</span>
                </div>
            </Item>
        </VirtualList>
    </div>

    <div class="footer">
        <ChatMessageEditor ChatId="@chat.Id"/>
    </div>
</div>

@code {
    [CascadingParameter]
    public Task<AuthState> AuthStateTask { get; set; } = null!;
    [Parameter]
    public string ChatId { get; set; } = "";

    protected override Task OnParametersSetAsync()
    {
        if (ChatId.IsNullOrEmpty())
            _nav.NavigateTo($"/chat/{ChatConstants.DefaultChatId}");
        return base.OnParametersSetAsync();
    }

    protected override async Task<ChatPageModel> ComputeState(CancellationToken cancellationToken)
    {
        var chatId = ChatId.NullIfEmpty() ?? ChatConstants.DefaultChatId;
        var user = (await AuthStateTask).User;
        var chat = await _chats.TryGet(_session, chatId, cancellationToken);
        if (chat == null)
            return new ChatPageModel() { IsUnavailable = true };
        if (!user.IsAuthenticated && !chat.IsPublic)
            return new ChatPageModel() { MustLogin = true };
        return new ChatPageModel() { Chat = chat };
    }

    private async Task<VirtualListResponse<ChatEntry>> GetMessages(VirtualListQuery query, CancellationToken cancellationToken)
    {
        var model = await State.Use(cancellationToken);
        var chatId = model.Chat?.Id;
        if (chatId.IsNullOrEmpty())
            return VirtualListResponse.New(Enumerable.Empty<ChatEntry>(), entry => entry.Id.ToString(), true, true);

        var idLogCover = ChatConstants.IdLogCover;
        var range = await _chats.GetIdRange(_session, chatId, cancellationToken);
        if (query.IncludedRange == default) {
            query = query with {
                IncludedRange = new Range<string>((range.End - idLogCover.MinTileSize).ToString(), range.End.ToString())
            };
        }

        var startId = long.Parse(query.IncludedRange.Start);
        if (query.ExpandStartBy > 0)
            startId -= (long) query.ExpandStartBy;
        startId = MathEx.Max(range.Start, startId);

        var endId = long.Parse(query.IncludedRange.End);
        if (query.ExpandEndBy > 0)
            endId += (long) query.ExpandEndBy;
        endId = MathEx.Min(range.End, endId);

        var ranges = idLogCover.GetTileCover((startId, endId + 1));
        var pages = await Task.WhenAll(ranges.Select(r => _chats.GetPage(_session, chatId, r, cancellationToken)));
        var result = VirtualListResponse.New(
            pages.SelectMany(p => p.Entries),
            entry => entry.Id.ToString(),
            startId == range.Start,
            endId == range.End);
        return result;
    }
}
